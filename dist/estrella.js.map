{
  "version": 3,
  "sources": ["../node_modules/miniglob/src/miniglob.js", "../node_modules/miniglob/src/miniglob.js", "../src/util.js", "../src/error.ts", "../src/estrella.js", "../src/extra.ts", "../src/termstyle.ts", "../src/log.ts", "../src/cli.ts", "../src/file.ts", "../src/chmod.ts", "../src/global.ts", "../src/memoize.js", "../src/screen.js", "../src/tslint.js", "../src/tsutil.ts", "../src/run.ts", "../src/exec.ts", "../src/io.ts", "../src/timeout.ts", "../src/signal.ts", "../src/tsapi.ts", "../src/typeinfo.ts", "../src/config.ts", "../src/hash.ts"],
  "sourcesContent": ["//\n// miniglob is a port of golang path/filepath\n//\n// Original Go source code Copyright (c) 2009 The Go Authors.\n// All rights reserved. See LICENSE-go for complete license.\n//\n// This code licensed under MIT, Copyright (c) 2018 Rasmus Andersson.\n// See LICENSE for complete license.\n//\nconst { readdirSync, statSync } = require('fs')\nconst DIRSEP = (() => {try {return require('path').sep}catch(_){return '/'}})()\nconst DIRSEP_BYTE = DIRSEP.charCodeAt(0)\nconst DIRSEP_RE_PG = DIRSEP == ':' ? /\\:+/g : DIRSEP == '\\\\' ? /\\\\+/g : /\\/+/g\nconst WIN32 = process.platform == 'win32'\n\n\nexport class PatternError extends Error {\n  constructor() { super('bad pattern') }\n}\n\n\nexport function glob(pattern) {\n  if (pattern.indexOf(\"**\") < 0) {\n    return glob0(pattern)\n  }\n  let matches = []\n  let filesVisited = new Set()\n  deepglob('', pattern.split(/\\*{2,}/), 0, matches, filesVisited)\n  return matches\n}\n\n\nfunction log() {\n  // console.log.apply(console, arguments)\n}\n\n\n// volumeNameLen returns length of the leading volume name on Windows.\n// It returns 0 elsewhere.\nconst volumeNameLen = WIN32 ? path => {\n  if (path.length < 2) {\n    return 0\n  }\n  // with drive letter\n  let c = path[0]\n  if (path[1] == ':' && ('a' <= c && c <= 'z' || 'A' <= c && c <= 'Z')) {\n    return 2\n  }\n  // TODO: check for UNC\n  return 0\n} : path => 0\n\n\n// cleanGlobPath prepares path for glob matching.\n// cleanGlobPath(path :string) : [prefixLen int, cleaned string]\n//\nconst cleanGlobPath = (\n  WIN32 ? (path, volumeNameLen) => { // (prefixLen int, cleaned string)\n    let vollen = volumeNameLen(path)\n    if (path == \"\") {\n      return [0, \".\"]\n    }\n    if (vollen+1 == path.length && isPathSep(path, path.length-1)) {\n      // /, \\, C:\\ and C:/ -- do nothing to the path\n      return [vollen + 1, path]\n    }\n    if (vollen == path.length && path.length == 2) { // C:\n      return [vollen, path + \".\"] // convert C: into C:.\n    }\n    if (vollen >= path.length) {\n      vollen = path.length - 1\n    }\n    return [vollen, path.substr(0, path.length-1)] // chop off trailing separator\n  } : (path, volumeNameLen) => {\n    if (path == \"\") {\n      return [volumeNameLen, \".\"]\n    }\n    if (path == DIRSEP) {\n      // do nothing to the path\n      return [volumeNameLen, path]\n    }\n    return [volumeNameLen, path.substr(0, path.length-1)] // chop off trailing separator\n  }\n)\n\n\nfunction isPathSep(s, i) {\n  return s.charCodeAt(i) === DIRSEP_BYTE\n}\n\n\n// (\"/foo///\") => \"/foo\"\nfunction stripDirSepRight(s) {\n  let e = s.length - 1, p = e\n  while (s.charCodeAt(p) === DIRSEP_BYTE) {\n    p--\n  }\n  return p != e ? s.substr(0, p + 1) : s\n}\n\n// (\"///foo/\") => \"foo/\"\nfunction stripDirSepLeft(s) {\n  let e = 0, p = e\n  while (s.charCodeAt(p) === DIRSEP_BYTE) {\n    p++\n  }\n  return p != e ? s.substr(p) : s\n}\n\n\n// deepglob(parts :string[]) string[] | null\n//\nfunction deepglob(dir, parts, partIndex, matches, filesVisited) {\n  if (partIndex >= parts.length) {\n    partIndex = parts.length - 1\n  }\n\n  let part = parts[partIndex]\n  let pattern = part\n\n  if (partIndex === 0) {\n    // first part\n    if (part.charCodeAt(part.length - 1) != DIRSEP_BYTE) {\n      // e.g. input=\"part**\"; part=\"part\"; pattern=\"part*\"\n      pattern += '*'\n    } // else e.g. input=\"part/**\"\n  } else if (partIndex === parts.length-1) {\n    // last part\n    if (part.charCodeAt(0) != DIRSEP_BYTE) {\n      // e.g. input=\"**part\"; part=\"part\"; pattern=\"*part\"\n      pattern = '*' + pattern\n    } // else e.g. input=\"**/part\"\n  } else {\n    // mid part\n    if (part.charCodeAt(0) != DIRSEP_BYTE) {\n      // e.g. input=\"**part**\"; part=\"part\"; pattern=\"*part\"\n      pattern = '*' + pattern\n    } // else e.g. input=\"**/part**\"\n    if (part.charCodeAt(part.length - 1) != DIRSEP_BYTE) {\n      // e.g. input=\"**part**\"; part=\"part\"; pattern=\"part*\"\n      pattern += '*'\n    } // else e.g. input=\"**part/**\"\n  }\n\n\n  function markVisit(path) {\n    if (filesVisited.has(path)) {\n      return false\n    }\n    filesVisited.add(path)\n    return true\n  }\n\n\n  function maybeAddFile(path) {\n    let filename = path\n    let p = filename.lastIndexOf(DIRSEP)\n    if (p != -1) {\n      filename = filename.substr(p + 1)\n    }\n\n    let nextPartIndex = Math.min(partIndex + 1, parts.length - 1)\n    let pat = parts.slice(nextPartIndex).join('*')\n\n    if (pat.charCodeAt(0) == DIRSEP_BYTE) {\n      pat = stripDirSepLeft(pat)\n    } else if (pat[0] != '*') {\n      pat = '*' + pat\n    }\n\n    if (match(pat, filename)) {\n      matches.push(path)\n    }\n  }\n\n  if (dir) {\n    if (pattern[0] != DIRSEP) {\n      pattern = dir + DIRSEP + pattern\n    } else {\n      pattern = dir + pattern\n    }\n  }\n\n  let isDirPattern = false\n  if (pattern.charCodeAt(pattern.length-1) === DIRSEP_BYTE) {\n    isDirPattern = true\n    pattern = stripDirSepRight(pattern)\n  }\n\n  let paths = glob0(pattern)\n\n  for (let path of paths) {\n    let st = statSync(path)\n\n    if (st.isDirectory()) {\n      if (markVisit(path)) {\n        walkdir(path, (path, st) => {\n          if (markVisit(path)) {\n            if (st.isDirectory()) {\n              deepglob(path, parts, partIndex + 1, matches, filesVisited)\n            } else {\n              maybeAddFile(path)\n            }\n          }\n        })\n      }\n    } else if (!isDirPattern && markVisit(path)) {\n      maybeAddFile(path)\n    }\n  }\n\n  return matches\n}\n\n\nfunction walkdir(dir, callback) {\n  dir = pclean(dir)\n  let st = statSync(dir)\n  if (st.isDirectory()) {\n    _walkdir(dir, callback, new Set([st.ino]))\n  }\n}\n\n\nfunction _walkdir(dir, callback, visitedInodes) {\n  for (let name of readdirSync(dir)) {\n    let path = pjoin(dir, name)\n    let st = stat(path)\n    let result = callback(path, st)\n    if (\n      (result || result === undefined) &&\n      st && st.isDirectory() && !visitedInodes.has(st.ino)\n    ) {\n      visitedInodes.add(st.ino)\n      _walkdir(path, callback, visitedInodes)\n    }\n  }\n}\n\n\n// Glob returns the names of all files matching pattern or null\n// if there is no matching file. The syntax of patterns is the same\n// as in Match. The pattern may describe hierarchical names such as\n// /usr/*/bin/ed (assuming the Separator is '/').\n//\n// Glob ignores file system errors such as I/O errors reading directories.\n// The only possible error is 'bad pattern', when pattern is malformed.\n//\n// glob(pattern :string) : string[] | null (matches)\nfunction glob0(pattern) {\n  let matches = []\n\n  if (!hasMeta(pattern)) {\n    if (stat(pattern)) {\n      return [pattern]\n    }\n    return matches\n  }\n\n  // dirname, basename\n  let volumeLen = volumeNameLen(pattern)\n  let i = pattern.length - 1\n  while (i >= volumeLen && !isPathSep(pattern, i)) {\n    i--\n  }\n  let dir = pattern.substr(0,i+1)\n  let file = pattern.substr(i+1)\n\n  ;[volumeLen, dir] = cleanGlobPath(dir, volumeLen)\n\n  if (!hasMeta(dir.substr(volumeLen))) {\n    _glob(dir, file, matches)\n  } else {\n    // Prevent infinite recursion. See golang issue 15879.\n    if (dir == pattern) {\n      throw new PatternError()\n    }\n    const m = glob0(dir) // :string[]\n    for (let d of m) {\n      _glob(d, file, matches)\n    }\n  }\n\n  return matches\n}\n\n\n// glob searches for files matching pattern in the directory dir\n// and appends them to matches. If the directory cannot be\n// opened, it returns the existing matches. New matches are\n// added in lexicographical order.\n//\n// _glob(dir :string, pattern :string, matches :string[])\n//\nfunction _glob(dir, pattern, matches) {\n  const fi = stat(dir)\n  if (fi === null) {\n    return\n  }\n  if (!fi.isDirectory()) {\n    return\n  }\n\n  let names\n  try {\n    names = readdirSync(dir)\n  } catch (_) {\n    return\n  }\n  names.sort()\n\n  for (let n of names) {\n    if (match(pattern, n)) {\n      matches.push(pjoin(dir, n))\n    }\n  }\n}\n\n\n// hasMeta reports whether path contains any of the magic characters\n// recognized by match.\nfunction hasMeta(path /*string*/) /*bool*/ {\n  for (let i = 0; i < path.length; ++i) {\n    switch (path.charCodeAt(i)) {\n      case 0x2A: // *\n      case 0x3F: // ?\n      case 0x5B: // [\n      case 0x7B: // {\n        return true\n    }\n  }\n  return false\n}\n\n\n// strContainsCh(s :string, c :int) : bool\nfunction strContainsCh(s, c) {\n  for (let i = 0; i < s.length; ++i) {\n    if (s.charCodeAt(i) === c) {\n      return true\n    }\n  }\n  return false\n}\n\n\n// Match reports whether name matches the shell file name pattern.\n// The pattern syntax is:\n//\n//  pattern:\n//    { term }\n//  term:\n//    '*'         matches any sequence of non-Separator characters\n//    '?'         matches any single non-Separator character\n//    '[' [ '^' ] { character-range } ']'\n//                character class (must be non-empty)\n//    c           matches character c (c != '*', '?', '\\\\', '[')\n//    '\\\\' c      matches character c\n//\n//  character-range:\n//    c           matches character c (c != '\\\\', '-', ']')\n//    '\\\\' c      matches character c\n//    lo '-' hi   matches character c for lo <= c <= hi\n//\n// Match requires pattern to match all of name, not just a substring.\n// The only possible returned error is ErrBadPattern, when pattern\n// is malformed.\n//\n// On Windows, escaping is disabled. Instead, '\\\\' is treated as\n// path separator.\n//\n// match(pattern :string, name :string) : bool (matched)\n//\nexport function match(pattern, name) {\n  Pattern:\n  while (pattern.length > 0) {\n    let star = false // :bool\n    let chunk = \"\" // :string\n\n    let patternin = pattern\n    ;[star, chunk, pattern] = scanChunk(pattern)\n    log(`scanChunk(%o) => %o`, patternin, [star, chunk, pattern])\n\n    if (star && chunk == \"\") {\n      log('ret')\n      // Trailing * matches rest of string unless it has a /.\n      return !strContainsCh(name, DIRSEP_BYTE)\n    }\n\n    // Look for match at current position.\n    let [t, ok] = matchChunk(chunk, name)\n    log(`matchChunk(%o, %o) => %o`, chunk, name, [t, ok])\n\n    // if we're the last chunk, make sure we've exhausted the name\n    // otherwise we'll give a false result even if we could still match\n    // using the star\n    if (ok && (t.length == 0 || pattern.length > 0)) {\n      name = t\n      continue\n    }\n\n    if (star) {\n      // Look for match skipping i+1 bytes.\n      // Cannot skip /.\n      for (let i = 0; i < name.length && name.charCodeAt(i) != DIRSEP_BYTE; i++) {\n        ;[t, ok] = matchChunk(chunk, name.substr(i+1))\n        if (ok) {\n          // if we're the last chunk, make sure we exhausted the name\n          if (pattern.length == 0 && t.length > 0) {\n            continue\n          }\n          name = t\n          continue Pattern\n        }\n      }\n    }\n\n    return false\n  }\n\n  return name.length == 0\n}\n\n\n// scanChunk gets the next segment of pattern, which is a non-star string\n// possibly preceded by a star.\n//\n// scanChunk(pattern :string) : [star bool, chunk string, rest string]\nfunction scanChunk(pattern) {\n  let star = false\n  while (pattern.length > 0 && pattern.charCodeAt(0) == 0x2A) {  // *\n    pattern = pattern.substr(1)\n    star = true\n  }\n  let inrange = false\n  let i = 0 >> 0 // int\n\n  Scan:\n  for (; i < pattern.length; i++) {\n    switch (pattern.charCodeAt(i)) {\n    case 0x5C: // \\\n      if (!WIN32) {\n        // error check handled in matchChunk: bad pattern.\n        if (i + 1 < pattern.length) {\n          i++\n        }\n      }\n      break\n    case 0x5B: // [\n      inrange = true\n      break\n    case 0x5D: // ]\n      inrange = false\n      break\n    case 0x2A: // *\n      if (!inrange) {\n        break Scan\n      }\n      break\n    }\n  }\n  return [ star, pattern.substr(0,i), pattern.substr(i) ]\n}\n\n\n// matchChunk checks whether chunk matches the beginning of s.\n// If so, it returns the remainder of s (after the match).\n// Chunk is all single-character operators: literals, char classes, and ?.\n//\n// matchChunk(chunk :string, s :string) [rest string, ok bool]\n//\nfunction matchChunk(chunk, s) {\n  log('enter matchChunk(%o, %o)', chunk, s)\n\n  while (chunk.length > 0) {\n    if (s.length == 0) {\n      return [\"\", false]\n    }\n\n    switch (chunk.charCodeAt(0)) {\n\n    case 0x5B: { // [\n      // character class\n      // let [r, n] = utf8.DecodeRuneInString(s)\n      let r = s.codePointAt(0)\n      let n = r <= 0xFFFF ? 1 : 2\n      s = s.substr(n)\n      chunk = chunk.substr(1)\n      log('\"[\" s reduced to %o, chunk reduced to %o, r = 0x%s', s, chunk, r.toString(16))\n\n      // We can't end right after '[', we're expecting at least\n      // a closing bracket and possibly a caret.\n      if (chunk.length == 0) {\n        throw new PatternError()\n      }\n      // possibly negated\n      let negated = chunk.charCodeAt(0) == 0x5E // ^\n      if (negated) {\n        log('\"[\" negation from \"^\"')\n        chunk = chunk.substr(1)\n      }\n      // parse all ranges\n      let match = false\n      let nrange = 0\n      while (true) {\n        if (chunk.length > 0 && chunk.charCodeAt(0) == 0x5D /*]*/ && nrange > 0) {\n          log('\"[\" loop break at A')\n          chunk = chunk.substr(1)\n          break\n        }\n\n        let ok, lo // bool, unichar\n        let debug_chunk = chunk\n        ;[ lo, chunk, ok ] = getEsc(chunk) // [ok bool, r rune, nchunk string]\n        log('\"[\" loop getEsc(%o) => %o', debug_chunk, [ lo, chunk, ok ])\n        if (!ok) {\n          log('\"[\" loop return at B from failed getEsc')\n          return [\"\", false]\n        }\n\n        let hi = lo\n        if (chunk.charCodeAt(0) == 0x2D /*-*/) {\n          ;[ hi, chunk, ok ] = getEsc(chunk.substr(1))\n          if (!ok) {\n            return [\"\", false]\n          }\n        }\n\n        if (lo <= r && r <= hi) {\n          match = true\n        }\n\n        nrange++\n      }\n      if (match == negated) {\n        return [\"\", false]\n      }\n      break\n    }\n\n    case 0x3F: // ?\n      if (s.charCodeAt(0) == DIRSEP_BYTE) {\n        return [\"\", false]\n      }\n      // _, n := utf8.DecodeRuneInString(s)\n      let r = s.codePointAt(0)\n      let n = r <= 0xFFFF ? 1 : 2\n      s = s.substr(n)\n      chunk = chunk.substr(1)\n      break\n\n    case 0x5C: // \\\n      if (!WIN32) {\n        log('\"\\\\\" consume')\n        chunk = chunk.substr(1)\n        if (chunk.length == 0) {\n          throw new PatternError()\n        }\n      }\n      // fallthrough\n\n    default:\n      if (chunk.charCodeAt(0) != s.charCodeAt(0)) {\n        log('[def] chunk[0] != s[0] (%o != %o) (0x%s != 0x%s) -- return',\n          chunk[0], s[0], chunk.charCodeAt(0).toString(16), s.charCodeAt(0).toString(16))\n        return [\"\", false]\n      }\n      s = s.substr(1)\n      chunk = chunk.substr(1)\n      log('[def] s reduced to %o, chunk reduced to %o', s, chunk)\n      break\n\n    }\n  }\n\n  return [ s, true ]\n}\n\n\n// getEsc gets a possibly-escaped character from chunk, for a character class.\n//\n// getEsc(chunk :string) : [ r rune, nchunk string, ok bool ]\n//\nfunction getEsc(chunk) {\n  let r = 0\n  let nchunk = ''\n  let c = chunk.charCodeAt(0)\n  if (chunk.length == 0 || c == 0x2D /*-*/ || c == 0x5D /*]*/) {\n    throw new PatternError()\n  }\n  if (c == 0x5C /*\\*/ && !WIN32) {\n    chunk = chunk.substr(1)\n    if (chunk.length == 0) {\n      throw new PatternError()\n    }\n  }\n  r = chunk.codePointAt(0)\n  let n = r <= 0xFFFF ? 1 : 2\n  if (r == 0xFFFF && n == 1) {\n    throw new PatternError()\n  }\n  nchunk = chunk.substr(n)\n  if (nchunk.length == 0) {\n    throw new PatternError()\n  }\n  return [ r, nchunk, true ]\n}\n\n\nfunction stat(path) {\n  try { return statSync(path) } catch (_) {}\n  return null\n}\n\n\nfunction pjoin(path1, path2) {\n  return (path1 == '.' || path1 == '') ? path2 : path1 + DIRSEP + path2\n}\n\n\n// pclean(\"foo//bar//\") => \"foo/bar\"\nfunction pclean(path) {\n  let endi = path.length - 1, i = endi\n  while (i && path.charCodeAt(i) === DIRSEP_BYTE) { --i }\n  if (i != endi) {\n    path = path.substr(0, i + 1)\n  }\n  return path.split(DIRSEP_RE_PG).join(DIRSEP)\n}\n", "//\n// miniglob is a port of golang path/filepath\n//\n// Original Go source code Copyright (c) 2009 The Go Authors.\n// All rights reserved. See LICENSE-go for complete license.\n//\n// This code licensed under MIT, Copyright (c) 2018 Rasmus Andersson.\n// See LICENSE for complete license.\n//\nconst { readdirSync, statSync } = require('fs')\nconst DIRSEP = (() => {try {return require('path').sep}catch(_){return '/'}})()\nconst DIRSEP_BYTE = DIRSEP.charCodeAt(0)\nconst DIRSEP_RE_PG = DIRSEP == ':' ? /\\:+/g : DIRSEP == '\\\\' ? /\\\\+/g : /\\/+/g\nconst WIN32 = process.platform == 'win32'\n\n\nexport class PatternError extends Error {\n  constructor() { super('bad pattern') }\n}\n\n\nexport function glob(pattern) {\n  if (pattern.indexOf(\"**\") < 0) {\n    return glob0(pattern)\n  }\n  let matches = []\n  let filesVisited = new Set()\n  deepglob('', pattern.split(/\\*{2,}/), 0, matches, filesVisited)\n  return matches\n}\n\n\nfunction log() {\n  // console.log.apply(console, arguments)\n}\n\n\n// volumeNameLen returns length of the leading volume name on Windows.\n// It returns 0 elsewhere.\nconst volumeNameLen = WIN32 ? path => {\n  if (path.length < 2) {\n    return 0\n  }\n  // with drive letter\n  let c = path[0]\n  if (path[1] == ':' && ('a' <= c && c <= 'z' || 'A' <= c && c <= 'Z')) {\n    return 2\n  }\n  // TODO: check for UNC\n  return 0\n} : path => 0\n\n\n// cleanGlobPath prepares path for glob matching.\n// cleanGlobPath(path :string) : [prefixLen int, cleaned string]\n//\nconst cleanGlobPath = (\n  WIN32 ? (path, volumeNameLen) => { // (prefixLen int, cleaned string)\n    let vollen = volumeNameLen(path)\n    if (path == \"\") {\n      return [0, \".\"]\n    }\n    if (vollen+1 == path.length && isPathSep(path, path.length-1)) {\n      // /, \\, C:\\ and C:/ -- do nothing to the path\n      return [vollen + 1, path]\n    }\n    if (vollen == path.length && path.length == 2) { // C:\n      return [vollen, path + \".\"] // convert C: into C:.\n    }\n    if (vollen >= path.length) {\n      vollen = path.length - 1\n    }\n    return [vollen, path.substr(0, path.length-1)] // chop off trailing separator\n  } : (path, volumeNameLen) => {\n    if (path == \"\") {\n      return [volumeNameLen, \".\"]\n    }\n    if (path == DIRSEP) {\n      // do nothing to the path\n      return [volumeNameLen, path]\n    }\n    return [volumeNameLen, path.substr(0, path.length-1)] // chop off trailing separator\n  }\n)\n\n\nfunction isPathSep(s, i) {\n  return s.charCodeAt(i) === DIRSEP_BYTE\n}\n\n\n// (\"/foo///\") => \"/foo\"\nfunction stripDirSepRight(s) {\n  let e = s.length - 1, p = e\n  while (s.charCodeAt(p) === DIRSEP_BYTE) {\n    p--\n  }\n  return p != e ? s.substr(0, p + 1) : s\n}\n\n// (\"///foo/\") => \"foo/\"\nfunction stripDirSepLeft(s) {\n  let e = 0, p = e\n  while (s.charCodeAt(p) === DIRSEP_BYTE) {\n    p++\n  }\n  return p != e ? s.substr(p) : s\n}\n\n\n// deepglob(parts :string[]) string[] | null\n//\nfunction deepglob(dir, parts, partIndex, matches, filesVisited) {\n  if (partIndex >= parts.length) {\n    partIndex = parts.length - 1\n  }\n\n  let part = parts[partIndex]\n  let pattern = part\n\n  if (partIndex === 0) {\n    // first part\n    if (part.charCodeAt(part.length - 1) != DIRSEP_BYTE) {\n      // e.g. input=\"part**\"; part=\"part\"; pattern=\"part*\"\n      pattern += '*'\n    } // else e.g. input=\"part/**\"\n  } else if (partIndex === parts.length-1) {\n    // last part\n    if (part.charCodeAt(0) != DIRSEP_BYTE) {\n      // e.g. input=\"**part\"; part=\"part\"; pattern=\"*part\"\n      pattern = '*' + pattern\n    } // else e.g. input=\"**/part\"\n  } else {\n    // mid part\n    if (part.charCodeAt(0) != DIRSEP_BYTE) {\n      // e.g. input=\"**part**\"; part=\"part\"; pattern=\"*part\"\n      pattern = '*' + pattern\n    } // else e.g. input=\"**/part**\"\n    if (part.charCodeAt(part.length - 1) != DIRSEP_BYTE) {\n      // e.g. input=\"**part**\"; part=\"part\"; pattern=\"part*\"\n      pattern += '*'\n    } // else e.g. input=\"**part/**\"\n  }\n\n\n  function markVisit(path) {\n    if (filesVisited.has(path)) {\n      return false\n    }\n    filesVisited.add(path)\n    return true\n  }\n\n\n  function maybeAddFile(path) {\n    let filename = path\n    let p = filename.lastIndexOf(DIRSEP)\n    if (p != -1) {\n      filename = filename.substr(p + 1)\n    }\n\n    let nextPartIndex = Math.min(partIndex + 1, parts.length - 1)\n    let pat = parts.slice(nextPartIndex).join('*')\n\n    if (pat.charCodeAt(0) == DIRSEP_BYTE) {\n      pat = stripDirSepLeft(pat)\n    } else if (pat[0] != '*') {\n      pat = '*' + pat\n    }\n\n    if (match(pat, filename)) {\n      matches.push(path)\n    }\n  }\n\n  if (dir) {\n    if (pattern[0] != DIRSEP) {\n      pattern = dir + DIRSEP + pattern\n    } else {\n      pattern = dir + pattern\n    }\n  }\n\n  let isDirPattern = false\n  if (pattern.charCodeAt(pattern.length-1) === DIRSEP_BYTE) {\n    isDirPattern = true\n    pattern = stripDirSepRight(pattern)\n  }\n\n  let paths = glob0(pattern)\n\n  for (let path of paths) {\n    let st = statSync(path)\n\n    if (st.isDirectory()) {\n      if (markVisit(path)) {\n        walkdir(path, (path, st) => {\n          if (markVisit(path)) {\n            if (st.isDirectory()) {\n              deepglob(path, parts, partIndex + 1, matches, filesVisited)\n            } else {\n              maybeAddFile(path)\n            }\n          }\n        })\n      }\n    } else if (!isDirPattern && markVisit(path)) {\n      maybeAddFile(path)\n    }\n  }\n\n  return matches\n}\n\n\nfunction walkdir(dir, callback) {\n  dir = pclean(dir)\n  let st = statSync(dir)\n  if (st.isDirectory()) {\n    _walkdir(dir, callback, new Set([st.ino]))\n  }\n}\n\n\nfunction _walkdir(dir, callback, visitedInodes) {\n  for (let name of readdirSync(dir)) {\n    let path = pjoin(dir, name)\n    let st = stat(path)\n    let result = callback(path, st)\n    if (\n      (result || result === undefined) &&\n      st && st.isDirectory() && !visitedInodes.has(st.ino)\n    ) {\n      visitedInodes.add(st.ino)\n      _walkdir(path, callback, visitedInodes)\n    }\n  }\n}\n\n\n// Glob returns the names of all files matching pattern or null\n// if there is no matching file. The syntax of patterns is the same\n// as in Match. The pattern may describe hierarchical names such as\n// /usr/*/bin/ed (assuming the Separator is '/').\n//\n// Glob ignores file system errors such as I/O errors reading directories.\n// The only possible error is 'bad pattern', when pattern is malformed.\n//\n// glob(pattern :string) : string[] | null (matches)\nfunction glob0(pattern) {\n  let matches = []\n\n  if (!hasMeta(pattern)) {\n    if (stat(pattern)) {\n      return [pattern]\n    }\n    return matches\n  }\n\n  // dirname, basename\n  let volumeLen = volumeNameLen(pattern)\n  let i = pattern.length - 1\n  while (i >= volumeLen && !isPathSep(pattern, i)) {\n    i--\n  }\n  let dir = pattern.substr(0,i+1)\n  let file = pattern.substr(i+1)\n\n  ;[volumeLen, dir] = cleanGlobPath(dir, volumeLen)\n\n  if (!hasMeta(dir.substr(volumeLen))) {\n    _glob(dir, file, matches)\n  } else {\n    // Prevent infinite recursion. See golang issue 15879.\n    if (dir == pattern) {\n      throw new PatternError()\n    }\n    const m = glob0(dir) // :string[]\n    for (let d of m) {\n      _glob(d, file, matches)\n    }\n  }\n\n  return matches\n}\n\n\n// glob searches for files matching pattern in the directory dir\n// and appends them to matches. If the directory cannot be\n// opened, it returns the existing matches. New matches are\n// added in lexicographical order.\n//\n// _glob(dir :string, pattern :string, matches :string[])\n//\nfunction _glob(dir, pattern, matches) {\n  const fi = stat(dir)\n  if (fi === null) {\n    return\n  }\n  if (!fi.isDirectory()) {\n    return\n  }\n\n  let names\n  try {\n    names = readdirSync(dir)\n  } catch (_) {\n    return\n  }\n  names.sort()\n\n  for (let n of names) {\n    if (match(pattern, n)) {\n      matches.push(pjoin(dir, n))\n    }\n  }\n}\n\n\n// hasMeta reports whether path contains any of the magic characters\n// recognized by match.\nfunction hasMeta(path /*string*/) /*bool*/ {\n  for (let i = 0; i < path.length; ++i) {\n    switch (path.charCodeAt(i)) {\n      case 0x2A: // *\n      case 0x3F: // ?\n      case 0x5B: // [\n      case 0x7B: // {\n        return true\n    }\n  }\n  return false\n}\n\n\n// strContainsCh(s :string, c :int) : bool\nfunction strContainsCh(s, c) {\n  for (let i = 0; i < s.length; ++i) {\n    if (s.charCodeAt(i) === c) {\n      return true\n    }\n  }\n  return false\n}\n\n\n// Match reports whether name matches the shell file name pattern.\n// The pattern syntax is:\n//\n//  pattern:\n//    { term }\n//  term:\n//    '*'         matches any sequence of non-Separator characters\n//    '?'         matches any single non-Separator character\n//    '[' [ '^' ] { character-range } ']'\n//                character class (must be non-empty)\n//    c           matches character c (c != '*', '?', '\\\\', '[')\n//    '\\\\' c      matches character c\n//\n//  character-range:\n//    c           matches character c (c != '\\\\', '-', ']')\n//    '\\\\' c      matches character c\n//    lo '-' hi   matches character c for lo <= c <= hi\n//\n// Match requires pattern to match all of name, not just a substring.\n// The only possible returned error is ErrBadPattern, when pattern\n// is malformed.\n//\n// On Windows, escaping is disabled. Instead, '\\\\' is treated as\n// path separator.\n//\n// match(pattern :string, name :string) : bool (matched)\n//\nexport function match(pattern, name) {\n  Pattern:\n  while (pattern.length > 0) {\n    let star = false // :bool\n    let chunk = \"\" // :string\n\n    let patternin = pattern\n    ;[star, chunk, pattern] = scanChunk(pattern)\n    log(`scanChunk(%o) => %o`, patternin, [star, chunk, pattern])\n\n    if (star && chunk == \"\") {\n      log('ret')\n      // Trailing * matches rest of string unless it has a /.\n      return !strContainsCh(name, DIRSEP_BYTE)\n    }\n\n    // Look for match at current position.\n    let [t, ok] = matchChunk(chunk, name)\n    log(`matchChunk(%o, %o) => %o`, chunk, name, [t, ok])\n\n    // if we're the last chunk, make sure we've exhausted the name\n    // otherwise we'll give a false result even if we could still match\n    // using the star\n    if (ok && (t.length == 0 || pattern.length > 0)) {\n      name = t\n      continue\n    }\n\n    if (star) {\n      // Look for match skipping i+1 bytes.\n      // Cannot skip /.\n      for (let i = 0; i < name.length && name.charCodeAt(i) != DIRSEP_BYTE; i++) {\n        ;[t, ok] = matchChunk(chunk, name.substr(i+1))\n        if (ok) {\n          // if we're the last chunk, make sure we exhausted the name\n          if (pattern.length == 0 && t.length > 0) {\n            continue\n          }\n          name = t\n          continue Pattern\n        }\n      }\n    }\n\n    return false\n  }\n\n  return name.length == 0\n}\n\n\n// scanChunk gets the next segment of pattern, which is a non-star string\n// possibly preceded by a star.\n//\n// scanChunk(pattern :string) : [star bool, chunk string, rest string]\nfunction scanChunk(pattern) {\n  let star = false\n  while (pattern.length > 0 && pattern.charCodeAt(0) == 0x2A) {  // *\n    pattern = pattern.substr(1)\n    star = true\n  }\n  let inrange = false\n  let i = 0 >> 0 // int\n\n  Scan:\n  for (; i < pattern.length; i++) {\n    switch (pattern.charCodeAt(i)) {\n    case 0x5C: // \\\n      if (!WIN32) {\n        // error check handled in matchChunk: bad pattern.\n        if (i + 1 < pattern.length) {\n          i++\n        }\n      }\n      break\n    case 0x5B: // [\n      inrange = true\n      break\n    case 0x5D: // ]\n      inrange = false\n      break\n    case 0x2A: // *\n      if (!inrange) {\n        break Scan\n      }\n      break\n    }\n  }\n  return [ star, pattern.substr(0,i), pattern.substr(i) ]\n}\n\n\n// matchChunk checks whether chunk matches the beginning of s.\n// If so, it returns the remainder of s (after the match).\n// Chunk is all single-character operators: literals, char classes, and ?.\n//\n// matchChunk(chunk :string, s :string) [rest string, ok bool]\n//\nfunction matchChunk(chunk, s) {\n  log('enter matchChunk(%o, %o)', chunk, s)\n\n  while (chunk.length > 0) {\n    if (s.length == 0) {\n      return [\"\", false]\n    }\n\n    switch (chunk.charCodeAt(0)) {\n\n    case 0x5B: { // [\n      // character class\n      // let [r, n] = utf8.DecodeRuneInString(s)\n      let r = s.codePointAt(0)\n      let n = r <= 0xFFFF ? 1 : 2\n      s = s.substr(n)\n      chunk = chunk.substr(1)\n      log('\"[\" s reduced to %o, chunk reduced to %o, r = 0x%s', s, chunk, r.toString(16))\n\n      // We can't end right after '[', we're expecting at least\n      // a closing bracket and possibly a caret.\n      if (chunk.length == 0) {\n        throw new PatternError()\n      }\n      // possibly negated\n      let negated = chunk.charCodeAt(0) == 0x5E // ^\n      if (negated) {\n        log('\"[\" negation from \"^\"')\n        chunk = chunk.substr(1)\n      }\n      // parse all ranges\n      let match = false\n      let nrange = 0\n      while (true) {\n        if (chunk.length > 0 && chunk.charCodeAt(0) == 0x5D /*]*/ && nrange > 0) {\n          log('\"[\" loop break at A')\n          chunk = chunk.substr(1)\n          break\n        }\n\n        let ok, lo // bool, unichar\n        let debug_chunk = chunk\n        ;[ lo, chunk, ok ] = getEsc(chunk) // [ok bool, r rune, nchunk string]\n        log('\"[\" loop getEsc(%o) => %o', debug_chunk, [ lo, chunk, ok ])\n        if (!ok) {\n          log('\"[\" loop return at B from failed getEsc')\n          return [\"\", false]\n        }\n\n        let hi = lo\n        if (chunk.charCodeAt(0) == 0x2D /*-*/) {\n          ;[ hi, chunk, ok ] = getEsc(chunk.substr(1))\n          if (!ok) {\n            return [\"\", false]\n          }\n        }\n\n        if (lo <= r && r <= hi) {\n          match = true\n        }\n\n        nrange++\n      }\n      if (match == negated) {\n        return [\"\", false]\n      }\n      break\n    }\n\n    case 0x3F: // ?\n      if (s.charCodeAt(0) == DIRSEP_BYTE) {\n        return [\"\", false]\n      }\n      // _, n := utf8.DecodeRuneInString(s)\n      let r = s.codePointAt(0)\n      let n = r <= 0xFFFF ? 1 : 2\n      s = s.substr(n)\n      chunk = chunk.substr(1)\n      break\n\n    case 0x5C: // \\\n      if (!WIN32) {\n        log('\"\\\\\" consume')\n        chunk = chunk.substr(1)\n        if (chunk.length == 0) {\n          throw new PatternError()\n        }\n      }\n      // fallthrough\n\n    default:\n      if (chunk.charCodeAt(0) != s.charCodeAt(0)) {\n        log('[def] chunk[0] != s[0] (%o != %o) (0x%s != 0x%s) -- return',\n          chunk[0], s[0], chunk.charCodeAt(0).toString(16), s.charCodeAt(0).toString(16))\n        return [\"\", false]\n      }\n      s = s.substr(1)\n      chunk = chunk.substr(1)\n      log('[def] s reduced to %o, chunk reduced to %o', s, chunk)\n      break\n\n    }\n  }\n\n  return [ s, true ]\n}\n\n\n// getEsc gets a possibly-escaped character from chunk, for a character class.\n//\n// getEsc(chunk :string) : [ r rune, nchunk string, ok bool ]\n//\nfunction getEsc(chunk) {\n  let r = 0\n  let nchunk = ''\n  let c = chunk.charCodeAt(0)\n  if (chunk.length == 0 || c == 0x2D /*-*/ || c == 0x5D /*]*/) {\n    throw new PatternError()\n  }\n  if (c == 0x5C /*\\*/ && !WIN32) {\n    chunk = chunk.substr(1)\n    if (chunk.length == 0) {\n      throw new PatternError()\n    }\n  }\n  r = chunk.codePointAt(0)\n  let n = r <= 0xFFFF ? 1 : 2\n  if (r == 0xFFFF && n == 1) {\n    throw new PatternError()\n  }\n  nchunk = chunk.substr(n)\n  if (nchunk.length == 0) {\n    throw new PatternError()\n  }\n  return [ r, nchunk, true ]\n}\n\n\nfunction stat(path) {\n  try { return statSync(path) } catch (_) {}\n  return null\n}\n\n\nfunction pjoin(path1, path2) {\n  return (path1 == '.' || path1 == '') ? path2 : path1 + DIRSEP + path2\n}\n\n\n// pclean(\"foo//bar//\") => \"foo/bar\"\nfunction pclean(path) {\n  let endi = path.length - 1, i = endi\n  while (i && path.charCodeAt(i) === DIRSEP_BYTE) { --i }\n  if (i != endi) {\n    path = path.substr(0, i + 1)\n  }\n  return path.split(DIRSEP_RE_PG).join(DIRSEP)\n}\n", "import * as fs from \"fs\"\nimport * as Path from \"path\"\nimport * as os from \"os\"\nimport { performance } from \"perf_hooks\"\nimport { stdoutStyle } from \"./termstyle\"\nimport { inspect } from \"util\"\n\nexport const json = (val, pretty, showHidden) => JSON.stringify(val, showHidden, pretty)\nexport const clock = () => performance.now()\n\n// running on Windows?\nexport const isWindows = process.platform.startsWith(\"win\")\n\n// generic symbols\nexport const TYPE = Symbol(\"TYPE\")\n\n// runtimeRequire(id :string) :any\nexport function runtimeRequire(id) {\n  // _runtimeRequire is defined at compile time by build.js (== require)\n  try { return _runtimeRequire(id) } catch { return null }\n}\nruntimeRequire.resolve = id => {\n  try { return _runtimeRequire.resolve(id) } catch { return \"\" }\n}\n\n// isCLI is true if estrella is invoked directly and not imported as a module\nexport const isCLI = module.id == \".\" || process.mainModule.filename == __filename\n\n\nexport function repr(val, prettyOrOptions) {\n  let options = {\n    colors: stdoutStyle.ncolors > 0,\n  }\n  if (typeof prettyOrOptions == \"object\") {\n    options = { ...prettyOrOptions }\n  } else if (prettyOrOptions !== undefined) {\n    options.compact = !prettyOrOptions\n  }\n  return inspect(val, options)\n}\n\n\nexport function resolveModulePackageFile(moduleSpec) {\n  const mainfile = runtimeRequire.resolve(moduleSpec)\n  let dir = Path.dirname(Path.resolve(mainfile))\n  let lastdir = Path.sep // lastdir approach to support Windows (not just check for \"/\")\n  while (dir != lastdir) {\n    let pfile = Path.join(dir, \"package.json\")\n    if (fs.existsSync(pfile)) {\n      return pfile\n    }\n    dir = Path.dirname(dir)\n  }\n  throw new Error(`package.json not found for module ${moduleSpec}`)\n}\n\n\nexport function getModulePackageJSON(moduleSpec) {\n  const pfile = resolveModulePackageFile(moduleSpec)\n  return jsonparseFile(pfile)\n}\n\n\nlet _tmpdir = \"\"\n\nexport function tmpdir() {\n  if (!_tmpdir) {\n    // Some systems return paths with symlinks.\n    // esbuild does \"realpath\" on some pathnames and thus reporting with esbuild's metafile\n    // may be incorrect if this is not canonical.\n    _tmpdir = fs.realpathSync.native(os.tmpdir())\n  }\n  return _tmpdir\n}\n\n\nexport function fmtDuration(ms) {\n  return (\n    ms >= 59500 ? (ms/60000).toFixed(0) + \"min\" :\n    ms >= 999.5 ? (ms/1000).toFixed(1) + \"s\" :\n    ms.toFixed(2) + \"ms\"\n  )\n}\n\nexport function fmtByteSize(bytes) {\n  return (\n    bytes >= 1024*1000 ? (bytes/(1024*1000)).toFixed(1) + \"MB\" :\n    bytes >= 1000 ? (bytes/1024).toFixed(1) + \"kB\" :\n    bytes + \"B\"\n  )\n}\n\nexport function findInPATH(executableName) {\n  const exeFileMode = isWindows ? 0xFFFFFFFF : fs.constants.X_OK\n  const PATH = new Set((process.env.PATH || \"\").split(Path.delimiter))\n\n  for (let dir of PATH) {\n    let path = Path.join(Path.resolve(dir), executableName)\n    if (isWindows) {\n      path += \".cmd\"\n    }\n    while (true) {\n      try {\n        let st = fs.statSync(path)\n        if (st.isSymbolicLink()) {\n          path = fs.realpathSync.native(path)\n          continue // try again\n        } else if (st.isFile() && (st.mode & exeFileMode)) {\n          return path\n        }\n      } catch (_) {\n        if (isWindows && path.endsWith(\".cmd\")) {\n          path = Path.join(Path.resolve(dir), executableName) + \".exe\"\n          continue // try with .exe extension\n        }\n      }\n      break\n    }\n  }\n  return null\n}\n\n\n// jsonparse parses \"relaxed\" JSON which can be in JavaScript format\nexport function jsonparse(jsonText, filename /*optional*/) {\n  try {\n    return JSON.parse(json)\n  } catch (err) {\n    return require(\"vm\").runInNewContext(\n      '(' + jsonText + ')',\n      { /* sandbox */ },\n      { filename, displayErrors: true }\n    )\n  }\n}\n\nexport function jsonparseFile(filename) {\n  const json = fs.readFileSync(filename, \"utf8\")\n  try {\n    return jsonparse(json)\n  } catch (err) {\n    throw new Error(`failed to parse ${filename}: ${err.message || err}`)\n  }\n}\n\n\n// ~/hello => /home/user/hello\nexport function expandTildePath(path) {\n  const homedir = os.homedir()\n  if (path == \"~\") {\n    return homedir\n  }\n  if (path.startsWith(\"~\" + Path.sep)) {\n    return homedir + path.substr(1)\n  }\n  return path\n}\n\n// /home/user/hello => ~/hello\nexport function tildePath(path) {\n  const s = Path.resolve(path)\n  const homedir = os.homedir()\n  if (s.startsWith(homedir)) {\n    return \"~\" + s.substr(homedir.length)\n  }\n  return s\n}\n", "import * as extra from \"./extra\"\nimport { stderrStyle } from \"./termstyle\"\nimport { getModulePackageJSON } from \"./util\"\nimport * as typeinfo from \"./typeinfo\"\n\n\nexport class UserError extends Error {\n  constructor(msg :string) {\n    super(msg)\n    this.name = \"UserError\"\n  }\n}\n\n\n// captureStackTrace captures a stack trace, returning the formatted stack.\n// If sourcemap is true, then translate locations via source map (loads debug module.)\nexport function captureStackTrace(cons? :Function, sourcemap? :boolean) :string {\n  const Error_prepareStackTrace = Error.prepareStackTrace\n  if (!sourcemap) {\n    Error.prepareStackTrace = undefined\n  }\n  let stack = \"\"\n  try {\n    const e :any = {}\n    Error.captureStackTrace(e, cons)\n    // note: accessing e.stack invokes Error.prepareStackTrace so this must be done\n    // before restoring Error.prepareStackTrace\n    stack = e.stack as string\n  } finally {\n    Error.prepareStackTrace = Error_prepareStackTrace\n  }\n  return stack\n}\n\n\nexport function bugReportMessage(mode :\"confident\"|\"guess\", reportContextField? :string) {\n  return extra.debug().bugReportMessage(mode, reportContextField)\n}\n\n\nexport function printErrorAndExit(err :any, origin? :string) {\n  return extra.debug().printErrorAndExit(err, origin)\n}\n\n\n// attempt to install source-map-support just-in-time when an error occurs to avoid\n// taking the startup cost of 10-20ms for loading the source-map-support module.\nfunction Error_prepareStackTrace(error: Error, stack: NodeJS.CallSite[]) {\n  Error.prepareStackTrace = undefined\n  try {\n    extra.debug().installSourceMapSupport()\n    if (Error.prepareStackTrace !== Error_prepareStackTrace) {\n      return Error.prepareStackTrace!(error, stack)\n    }\n  } catch(_) {}\n  return error.stack || String(error)\n}\n\n\n// install process-level exception and rejection handlers\nError.prepareStackTrace = Error_prepareStackTrace\nprocess.on(\"uncaughtException\", printErrorAndExit)\nprocess.on(\"unhandledRejection\", (reason :{} | null | undefined, _promise :Promise<any>) => {\n  printErrorAndExit(reason||\"PromiseRejection\", \"unhandledRejection\")\n})\n", "#!/usr/bin/env node\nimport * as esbuild from \"esbuild\"\nimport * as fs from \"fs\"\nimport * as os from \"os\"\nimport * as Path from \"path\"\nimport * as glob from \"miniglob\"\n\nimport \"./global\"\nimport { bugReportMessage, UserError } from \"./error\"\nimport {\n  clock,\n  findInPATH,\n  fmtByteSize,\n  fmtDuration,\n  json,\n  jsonparse,\n  jsonparseFile,\n  repr,\n  runtimeRequire,\n  tildePath,\n  tmpdir,\n  isCLI,\n} from \"./util\"\nimport { termStyle, stdoutStyle as style, stderrStyle } from \"./termstyle\"\nimport { memoize, isMemoized } from \"./memoize\"\nimport { screen } from \"./screen\"\nimport { tslint, defaultTSRules } from \"./tslint\"\nimport * as tsutil from \"./tsutil\"\nimport { prog, parseopt } from \"./cli\"\nimport log from \"./log\"\nimport * as cli from \"./cli\"\nimport * as run from \"./run\"\nimport * as tsapi from \"./tsapi\"\nimport { file, scandir, fileModificationLogAppend } from \"./file\"\nimport { chmod } from \"./chmod\"\nimport * as typeinfo from \"./typeinfo\"\nimport { createBuildConfig } from \"./config\"\nimport { sha1 } from \"./hash\"\nimport * as extra from \"./extra\"\n\nconst { dirname, basename } = Path\n\nconst CLI_DOC = {\n  usage: \"usage: $0 [options]\",\n  flags: [\n    [\"-w, watch\"         ,\"Watch source files for changes and rebuild.\"],\n    [\"-g, debug\"         ,\"Do not optimize and define DEBUG=true.\"],\n    [\"-r, run\"           ,\"Run the output file after a successful build.\"],\n    [\"-sourcemap\"        ,\"Generate sourcemap.\"],\n    [\"-inline-sourcemap\" ,\"Generate inline sourcemap.\"],\n    [\"-no-color\"         ,\"Disable use of colors.\"],\n    [\"-no-clear\"         ,\"Disable clearing of the screen, regardless of TTY status.\"],\n    [\"-no-diag\"          ,\"Disable TypeScript diagnostics.\"],\n    [\"-color\"            ,\"Color terminal output, regardless of TTY status.\"],\n    [\"-diag\"             ,\"Only run TypeScript diagnostics (no esbuild.)\"],\n    [\"-quiet\"            ,\"Only log warnings and errors but nothing else.\"],\n    [\"-silent\"           ,\"Don't log anything, not even errors.\"],\n    [\"-estrella-version\" ,\"Print version of estrella and exit 0.\"],\n    [\"-estrella-debug\"   ,\"Enable debug logging of estrella itself.\"],\n  ],\n}\n\nconst CLI_DOC_STANDALONE = {\n  usage: \"usage: $0 [options] <srcfile> ...\",\n  flags: CLI_DOC.flags.concat([\n    [\"-o, outfile\" ,\"Write output to <file> instead of stdout.\", \"<file>\"],\n    [\"-bundle\"     ,\"Include all dependencies.\"],\n    [\"-minify\"     ,\"Simplify and compress generated code.\"],\n    [\"-outdir\"     ,\"Write output to <dir> instead of stdout.\", \"<dir>\"],\n    [\"-esbuild\"    ,\"Pass arbitrary JSON to esbuild's build function.\", \"<json>\"],\n  ]),\n  trailer: `\n<srcfile> is a filename, or \"-\" for stdin.\n\nExample of using estrella without a build script:\n  $0 -o out/app.js main.ts\n    This compile main.ts and writes the output to out/app.js\n\nExample of using estrella with a build script:\n  1. Create a file called build.js with the following contents:\n       #!/usr/bin/env node\n       const { build } = require(\"estrella\")\n       build({\n         entry: \"main.ts\",\n         outfile: \"out/main.js\",\n       })\n  2. Make that file executable and run it:\n       chmod +x build.js\n       ./build.js\n  You can now customize your build behavior by changing build.js.\n  Try ./build.js -help\n\nSee https://github.com/rsms/estrella#readme for documentation.\n  `\n}\n\n// cli_ready resolved when CLI arguments have been fully processed.\n//\n// Parsing of CLI arguments happens in two phases when estrella runs from a user script.\n//   1. estrella built-in arguments are parsed, a cliopts.parse function is added.\n//   2. the user script executes, possibly calling cliopts.parse to parse custom arguments.\n//   3. a runloop frame later, cli_ready resolves.\n// This enables user scripts to extend the CLI options.\n//\n// Note that when estrella is run directly, CLI arguments are parsed in a single phase\n// and this does not apply. In that case cli_ready is resolved immediately.\n//\nlet cli_ready = Promise.resolve()\n\n// cliopts and cliargs are special objects exported in the API.\n// They are populated by this script's body when estrella runs from a user script,\n// otherwise these are populated by main()\nlet cliopts = {}, cliargs = []\n\nconst IS_MAIN_CALL = Symbol(\"IS_MAIN_CALL\")\n\nfunction EMPTYFUN(){}\n\n// setErrorExitCode(code:number=1) causes the program to exit with the provied code\n// in case it exits cleanly.\n// This is used to make it possible to exit with an error when there are multiple\n// builds happening.\n//\nlet _setErrorExitCode = false\nfunction setErrorExitCode(code) {\n  if (!_setErrorExitCode) {\n    _setErrorExitCode = true\n    let overrideCode = code || 1\n    process.exitCode = overrideCode\n    process.on(\"exit\", code => { process.exit(code || overrideCode) })\n  }\n}\n\n\n// len returns the length of some collection (array, object or string)\nfunction len(v) {\n  switch (typeof v) {\n    case \"object\":\n      if (Array.isArray(v))\n        return v.length\n      return Object.keys(v).length\n    case \"string\":\n      return v.length\n    default:\n      return 0\n  }\n}\n\n\nfunction processAPIConfig(config) {\n  // support use of both entry and entryPoints\n  log.debug(()=>`input config ${repr(config)}`)\n  if (!config.entryPoints) {\n    config.entryPoints = []\n  }\n  if (config.entry) {\n    if (Array.isArray(config.entry)) {\n      config.entryPoints = config.entryPoints.concat(config.entry)\n    } else if (typeof config.entry == \"object\") {\n      // entry points is a map of \"infile => outfile\"\n      if (config.entryPoints.length != 0) {\n        // The user specified both entryPoints AND entry.\n        // We could merge the objects here but that would be pretty complicated.\n        // It's such an edge case that... no, let's just let the user know.\n        throw new UserError(\n          `Both config.entryPoints and .entry can not be set when .entry is an object`)\n      }\n      config.entryPoints = config.entry\n    } else {\n      config.entryPoints.push(config.entry)\n    }\n  }\n  delete config.entry\n  const nentries = len(config.entryPoints)\n  if (nentries == 0 && !config.stdin) {\n    // No entryPoints provided. Try to read from tsconfig include or files\n    log.debug(()=> `missing entryPoints; attempting inference`)\n    config.entryPoints = guessEntryPoints(config)\n    if (config.entryPoints.length == 0) {\n      let msg = tsutil.getTSConfigForConfig(config) ? \" (could not guess from tsconfig.json)\" : \"\"\n      throw new UserError(`config.entryPoints is empty or not set${msg}`)\n    }\n  }\n\n  // normalize sourcemap value to boolean|\"inline\"|\"external\"\n  if (config.sourcemap) {\n    if (config.sourcemap != \"inline\" && config.sourcemap != \"external\") {\n      config.sourcemap = true\n    }\n  } else {\n    config.sourcemap = false\n  }\n\n  // if outfile is empty or missing, use a temporary file (esbuild needs a file to write to.)\n  // Note: outfile=\"-\" is handled by build1, prior to calling processAPIConfig.\n  if (!config.outfile && !config.outdir) {\n    config.setOutfile(\"-\") // set since it's used by updateProjectID\n    const projectID = config.updateProjectID()\n    config.setOutfile(Path.join(tmpdir(), `esbuild.${projectID}.out.js`))\n    config.outfileIsTemporary = true\n    // Note: We let config.outfileCopyToStdout be false (default) since the expected behavior\n    // in the case of outfile=\"\" is for nothing to appear on stdout but only contents returned\n    // through the API, to onEnd.\n  }\n\n  config.updateProjectID()\n  log.debug(()=>`effective config for project#${config.projectID}: ${repr(config)}`)\n}\n\n\nfunction patchSourceMap(mapfile, overrides) {\n  const timeStarted = clock()\n  const map = JSON.parse(fs.readFileSync(mapfile))\n  for (let k in overrides) {\n    let v = overrides[k]\n    if (v === undefined) {\n      delete map[k]\n    } else {\n      if (typeof v == \"function\") {\n        v = v(map[k])\n      }\n      map[k] = v\n    }\n  }\n  fs.writeFileSync(mapfile, JSON.stringify(map))\n  log.debug(() =>\n    `patched source map ${mapfile} with overrides ${repr(overrides)}` +\n    ` (${fmtDuration(clock() - timeStarted)})`)\n}\n\n\n// guessEntryPoints(config :BuildConfig) :string[]\nfunction guessEntryPoints(config) {\n  // guess from tsconfig.json file\n  const tsconfig = tsutil.getTSConfigForConfig(config)\n  if (tsconfig) {\n    log.debug(() => `tsconfig file found at ${tsutil.getTSConfigFileForConfig(config)}`)\n    if (tsconfig.files) {\n      return tsconfig.files\n    }\n    if (tsconfig.include) {\n      let files = []\n      for (let pat of tsconfig.include) {\n        log.debug(`guessing entry points: glob.glob(${pat}) =>`, glob.glob(pat))\n        files = files.concat(glob.glob(pat))\n      }\n      if (tsconfig.exclude) {\n        for (let pat of tsconfig.exclude) {\n          files = files.filter(fn => !glob.match(pat, fn))\n        }\n      }\n      // return the first file remaining (if any)\n      return files.slice(0, 1)\n    }\n  }\n  return []\n}\n\n\nfunction esbuildOptionsFromConfig(config) {\n  let esbuildOptions = {}\n  let unknownOptions = {}\n\n  // esbuildOptionKeyMap maps legacy esbuild BuildOptions keys to current ones\n  const esbuildOptionKeyMap = {\n    \"name\": \"globalName\", // changed in v0.5 or so\n  }\n\n  for (let k of Object.keys(config)) {\n    if (typeinfo.estrella.BuildConfig.has(k)) {\n      // skip estrella-specific option\n      continue\n    }\n    if (!typeinfo.esbuild.BuildOptions.has(k)) {\n      unknownOptions[k] = config[k]\n    }\n    k = esbuildOptionKeyMap[k] || k  // possibly renamed\n    esbuildOptions[k] = config[k]\n  }\n\n  if (Object.keys(unknownOptions).length > 0) {\n    log.info(\n      `Notice: Potentially invalid esbuild.BuildOption(s): ${repr(unknownOptions)}\\n` +\n      bugReportMessage(\"guess\", json(Object.keys(unknownOptions)))\n    )\n  }\n\n  if (!esbuildOptions.outfile) {\n    delete esbuildOptions.outfile\n  }\n\n  return esbuildOptions\n}\n\n\nlet _logInfoOnceRecord = new Set()\n\nfunction logInfoOnce(...v) {\n  if (log.level >= log.INFO) {\n    const k = v.join(\" \")\n    if (!_logInfoOnceRecord.has(k)) {\n      _logInfoOnceRecord.add(k)\n      log.info(...v)\n    }\n  }\n}\n\n\n// build wraps the \"real\" build function build1.\n// build does the following:\n// - makes a mutable copy of config\n// - wraps build1 in a CancellablePromise\n//\nfunction build(config /* estrella.BuildConfig */) {\n  config = createBuildConfig(\n    config || {},\n    ( // default cwd\n      config[IS_MAIN_CALL] ? process.cwd() :\n      process.mainModule && dirname(process.mainModule.filename) || __dirname\n    ),\n  )\n\n  const resolver = { resolve(){}, reject(){} }\n  const cancelCallbacks = []\n\n  // (f :()=>void) :void\n  function addCancelCallback(f) {\n    if (config.isCancelled) {\n      f()\n    } else {\n      cancelCallbacks.push(f)\n    }\n  }\n\n  function cancel(reason) {\n    if (!config.isCancelled) {\n      log.debug(`build cancelled`, {reason})\n      config.isCancelled = true\n      for (let f of cancelCallbacks) {\n        f && f()\n      }\n      cancelCallbacks.length = 0\n      if (reason) {\n        resolver.reject(reason)\n      } else {\n        resolver.resolve(true)\n      }\n    }\n  }\n\n  let ctx = {\n    addCancelCallback,\n    buildCounter: 0,\n    rebuild() {\n      log.warn(\"rebuild() called before initial build completed. Ignoring\")\n      return Promise.resolve(true)\n    },\n  }\n\n  const p = cli_ready.then(() => new Promise((resolve, reject) => {\n    if (config.isCancelled) {\n      log.debug(`build cancelled immediately`)\n      return false\n    }\n    resolver.resolve = resolve\n    resolver.reject = reject\n    build1(config, ctx).then(resolve).catch(reject)\n  }))\n\n  p.rebuild = () => ctx.rebuild()\n  Object.defineProperty(p, \"buildCounter\", { get() { return ctx.buildCounter } })\n  p.cancel = cancel\n\n  return p\n} // build()\n\n\n// build1 is the \"real\" build function -- build() wraps it with cancellation.\nasync function build1(config, ctx) {\n  const isMainCall = IS_MAIN_CALL in config\n  delete config[IS_MAIN_CALL]\n\n  let opts = cliopts, args = cliargs\n\n  if (config.run === undefined) {\n    config.run = opts.run\n  }\n\n  // if outfile is \"-\", use a temporary file (esbuild needs a file to write to)\n  if (\n    config.outfile == \"-\" ||\n    opts.outfile == \"-\" ||\n    (isMainCall && !opts.outfile && !opts.outdir)\n  ) {\n    config.setOutfile(\"-\") // set since it's used by updateProjectID\n    const projectID = config.updateProjectID()\n    opts.outfile = Path.join(tmpdir(), `esbuild.${projectID}.out.js`)\n    config.setOutfile(opts.outfile)\n    config.outfileIsTemporary = true\n    config.outfileCopyToStdout = true\n  }\n\n  if (!isMainCall) {\n    // process config when build is called as a function\n    processAPIConfig(config)\n  } else {\n    // BEGIN special logic for when running this script directly as a program\n\n    if (args.length == 0) {\n      // no <srcfile>'s provided, default to stdin unless its a TTY,\n      // else try to read tsconfig file in current directory.\n      if (!process.stdin.isTTY) {\n        args = [\"-\"]\n      } else {\n        const guess = guessEntryPoints(config)\n        log.debug(() => `no input files provided; best guess: ${repr(guess)}`)\n        if (guess.length == 0) {\n          log.error(`missing <srcfile> argument (see ${prog} -help)`)\n          process.exit(1)\n        }\n\n        args.splice(args.length-1, 0, ...guess)\n\n        // infer outfile or outdir\n        const tsconfig = tsutil.getTSConfigForConfig(config)\n        if (!opts.outfile && !opts.outdir && tsconfig) {\n          opts.outfile = tsconfig.outFile\n          if (!opts.outfile) {\n            opts.outdir = tsconfig.outDir\n          }\n        }\n\n        if (args.length == 0) {\n          log.error(`missing <srcfile> argument (see ${prog} -help)`)\n          process.exit(1)\n        }\n      }\n    }\n\n    // handle stdin args (\"-\")\n    args = args.filter(a => {\n      if (a != \"-\") {\n        return true\n      }\n      if (!config.stdin) { // guard to deduplicate multiple \"-\" args\n        config.stdin = {\n          contents: fs.readFileSync(/*STDIN_FILENO*/0, \"utf8\"),\n          sourcefile: \"stdin\",\n          resolveDir: process.cwd(),\n          loader: 'ts', // TODO make user-configurable on the CLI\n        }\n      }\n      return false\n    })\n\n    config.setOutfile(opts.outfile || undefined)\n    args.length > 0 && (config.entryPoints = args)\n    opts.outdir     && (config.outdir = opts.outdir)\n    opts.bundle     && (config.bundle = opts.bundle)\n    opts.minify     && (config.minify = opts.minify)\n\n    if (opts.esbuild) {\n      const esbuildProps = jsonparse(opts.esbuild, \"-esbuild\")\n      if (!esbuildProps || typeof esbuildProps != \"object\") {\n        log.error(\n          `-esbuild needs a JS object, for example '{key:\"value\"}'. Got ${typeof esbuildProps}.`\n        )\n        return false\n      }\n      log.debug(()=>`applying custom esbuild config ${repr(esbuildProps)}`)\n      for (let k in esbuildProps) {\n        config[k] = esbuildProps[k]\n      }\n    }\n    // END special logic for when running this script directly as a program\n  } // isMainCall\n\n  // smash config options and CLI options together\n  const debug = config.debug = opts.debug = !!(opts.debug || config.debug)\n  const silent = config.silent = opts.silent = !!(opts.silent || config.silent)\n  const quiet = config.quiet = opts.quiet = silent || !!(opts.quiet || config.quiet)\n  opts.watch = !!(opts.watch || config.watch)\n  if (!config.watch || typeof config.watch != \"object\") {\n    config.watch = opts.watch\n  }\n\n  if (config.color !== undefined) {\n    // update ANSI color setting\n    log.colorMode = config.color\n    style.reconfigure(process.stdout, config.color)\n    stderrStyle.reconfigure(process.stderr, config.color)\n  }\n\n  if (quiet && log.level < log.DEBUG) {\n    // when -quiet or -silent is set but -estrella-debug is NOT set, then reduce log verbosity\n    log.level = silent ? log.SILENT : log.WARN\n  }\n\n  config.sourcemap = (\n    opts[\"inline-sourcemap\"] ? \"inline\" :\n    opts.sourcemap ? true :\n    config.sourcemap\n  )\n  if (config.outfileIsTemporary && config.outfileCopyToStdout && config.sourcemap === true) {\n    // when writing to stdout, \"sourcemap:true\" means \"inline\" rather than \"yes, write a map file\".\n    config.sourcemap = \"inline\"\n  }\n\n  config.clear = (\n    opts[\"no-clear\"] ? false :\n    config.clear === undefined ? !!process.stdout.isTTY :\n    config.clear\n  )\n\n  log.debug(()=>`project directory ${repr(config.cwd)} (config.cwd)`)\n\n  if (!config.title) {\n    config.title = config.name || tildePath(config.cwd)\n  }\n\n  // set tslintOptions to the effective tslint option based\n  // - CLI arguments -diag and -no-diag\n  // - config property \"tslint\" and the older depreacted \"tsc\" property\n  // tslintOptions : boolean | \"auto\" | \"on\" | \"off\" | TSLintBasicOptions\n  // Note that opts.diag has already been adjusted for -no-diag so no need to look for that here.\n  let tslintOptions = (\n    opts.diag === true ? \"on\" :\n    opts.diag === false ? \"off\" :\n    \"auto\"\n  )\n  if (tslintOptions !== \"off\" && (!config.entryPoints || len(config.entryPoints) == 0)) {\n    log.debug(`disabling tslint (no entryPoints)`)\n    tslintOptions = \"off\"\n  } else if (tslintOptions !== \"off\") {\n    if (config.tsc !== undefined) {\n      log.info(\"the 'tsc' property is deprecated. Please rename to 'tslint'.\")\n      if (config.tslint === undefined) {\n        config.tslint = config.tsc\n      }\n    }\n    if (config.tslint && config.tslint !== \"auto\") {\n      tslintOptions = config.tslint\n    }\n\n    const tslintIsAuto = (\n      tslintOptions === \"auto\" ||\n      (typeof tslintOptions == \"object\" && (config.tslint.mode === \"auto\" || !config.tslint.mode))\n    )\n\n    if (tslintIsAuto) {\n      // \"auto\" mode: only run tslint if a tsconfig file is found.\n      // This matches the behavior of calling the tslint() function directly.\n      if (!tsutil.getTSConfigFileForConfig(config)) {\n        log.debug(() => {\n          const dir = tsutil.tsConfigFileSearchDirForConfig(config)\n          const searchfiles = Array.from(tsutil.searchTSConfigFile(dir, config.cwd))\n          return (\n            `skipping tslint in auto mode since no tsconfig.json file was found in project.\\n` +\n            `Tried the following filenames:${searchfiles.map(f => `\\n  ${tildePath(f)}`)}`\n          )\n        })\n        tslintOptions = \"off\"\n      }\n    } else if (config.tslint !== undefined && config.tslint !== \"auto\") {\n      tslintOptions = config.tslint\n    }\n  }\n\n\n  // Configure \"run\"\n  if (config.run) {\n    run.configure(config)\n  }\n\n\n  let lastClearTime = 0\n  function clear() {\n    screen.clear()\n    lastClearTime = clock()\n  }\n\n\n  let isInsideCallToUserOnEnd = false\n  const userOnEnd = config.onEnd\n\n  // onEnd is called by onBuildSuccess OR onBuildFail\n  let onEnd = (\n    userOnEnd ? async (buildResults, defaultReturn) => {\n      isInsideCallToUserOnEnd = true\n      let returnValue = undefined\n      try {\n        const r = userOnEnd(config, buildResults, ctx)\n        returnValue = r instanceof Promise ? await r : r\n      } catch (err) {\n        log.debug(()=>`error in onEnd handler: ${err.stack||err}`)\n        throw err\n      } finally {\n        isInsideCallToUserOnEnd = false\n      }\n      const ok = returnValue === undefined ? defaultReturn : !!returnValue\n      return ok\n\n    } : (_buildResults, ok) => {\n      return ok\n    }\n  )\n\n  function wrapOnEnd(f) {\n    let onEndInner = onEnd\n    onEnd = async (buildResults, ok) => {\n      const ok2 = await f(buildResults, ok)\n      if (ok2 !== undefined) {\n        ok = ok2\n      }\n      return onEndInner(buildResults, ok)\n    }\n  }\n\n  // Note: wrapOnEnd stacks functions, meaning that a function defined earlier in this source\n  // file will be called later in time.\n\n  // chmod handler\n  if (config.outfileMode && config.outfile) {\n    wrapOnEnd(async (buildResults, ok) => {\n      log.debug(\"onEnd chmod\")\n      if (buildResults.errors.length == 0) {\n        try {\n          chmod(config.outfileAbs, config.outfileMode)\n        } catch (err) {\n          log.error(\"configuration error: outfileMode: \" + err.message)\n          setErrorExitCode(1)\n        }\n      }\n    })\n  }\n\n  // tmp outfile handler\n  if (config.outfileCopyToStdout && !config.run && config.write !== false) {\n    wrapOnEnd(async (buildResults, ok) => {\n      log.debug(\"onEnd copyToStdout\")\n      if (buildResults.errors.length == 0) {\n        return new Promise((resolve, reject) => {\n          const r = fs.createReadStream(config.outfileAbs)\n          r.on(\"end\", () => resolve(ok))\n          r.on(\"error\", reject)\n          r.pipe(process.stdout)\n        })\n      }\n    })\n  }\n\n  // add contents of output to onEnd when writing to a temporary file (not stdout)\n  if (config.outfileIsTemporary && !config.outfileCopyToStdout && config.write !== false) {\n    wrapOnEnd(async (buildResults, ok) => {\n      log.debug(\"onEnd load results\")\n      buildResults.js = fs.readFileSync(config.outfile, {encoding:\"utf8\"})\n      if (config.sourcemap === true) {\n        try {\n          buildResults.map = fs.readFileSync(config.outfile + \".map\", {encoding:\"utf8\"})\n        } catch (err) {\n          log.debug(\n            `failed to load temporary source map at ${config.outfile}.map: ${err.stack||err}`)\n        }\n        // strip \"sourceMappingURL ...\" from js\n        const i = buildResults.js.lastIndexOf(\"\\n//# sourceMappingURL\")\n        if (i != -1) {\n          buildResults.js = buildResults.js.substr(0, i+1) // +1 = keep LF\n        }\n      }\n    })\n  }\n\n  // print \"Watching files for changes...\" the first time a watcher starts\n  if (config.watch) {\n    wrapOnEnd(async (buildResults, ok) => {\n      // Note: Tests rely on this message, so if you change it, update those tests too.\n      logInfoOnce(\"Watching files for changes...\")\n    })\n  }\n\n  // definitions\n  let define = {\n    DEBUG: debug ? \"true\" : \"false\",\n    ...(config.define || {})\n  }\n\n  // options to esbuild\n  const esbuildOptions = {\n    // default values\n    minify: !debug,\n    sourcemap: config.sourcemap,\n    sourcesContent: false, // to match past versions of estrella\n    color: stderrStyle.ncolors > 0,\n    logLevel: (\n      log.level == log.DEBUG ? \"info\" :\n      config.silent ?          \"silent\" :\n      config.quiet ?           \"error\" :\n                               \"warning\" ),\n\n    // user values\n    ...esbuildOptionsFromConfig(config),\n\n    define,\n  }\n\n  // Incremental rebuild is available if the folllowing test passes:\n  //   (esbuildResult && esbuildResult.rebuild)\n  // This must be set to null whenever esbuildConfig changes.\n  let esbuildResult = null // : esbuild.BuildIncremental\n\n  let lastBuildResults = {\n    warnings: [],\n    errors: [],\n    metafile: null, //{inputs:{},outputs:{}}|null\n  }\n\n  // esbuild can produce a metadata file describing imports\n  // We use this to know what source files to observe in watch mode.\n  if (config.watch) {\n    const projectID = config.projectID\n    esbuildOptions.incremental = true\n    esbuildOptions.metafile = true\n    if ((!esbuildOptions.outfile && !esbuildOptions.outdir) || esbuildOptions.write === false) {\n      // esbuild needs an outfile for the metafile option to work\n      esbuildOptions.outfile = Path.join(tmpdir(), `esbuild.${projectID}.out.js`)\n      config.outfileIsTemporary = true\n      // if write==false, unset it so that esbuild actually writes metafile\n      delete esbuildOptions.write\n    }\n    // cancel incremental esbuild when BuildProcess.cancel is called\n    ctx.addCancelCallback(() => {\n      if (esbuildResult && esbuildResult.rebuild) {\n        esbuildResult.rebuild.dispose()\n      }\n    });\n    // setup metafile.inputs for initial run so that watch has some files\n    if (config.entryPoints && len(config.entryPoints) > 0) {\n      lastBuildResults.metafile = {inputs:{},outputs:{}}\n      if (Array.isArray(config.entryPoints)) {\n        for (let f of config.entryPoints) {\n          lastBuildResults.metafile.inputs[f] = {}\n        }\n      } else { // entryPoints an object {outfile:infile}\n        for (let outfile of Object.keys(config.entryPoints)) {\n          let f = config.entryPoints[outfile]\n          lastBuildResults.metafile.inputs[f] = {}\n        }\n      }\n    }\n  }\n\n  // rebuild function\n  ctx.rebuild = () => { // Promise<boolean>\n    return _esbuild([]).then(ok => {\n      if (isInsideCallToUserOnEnd) {\n        log.warn(`waiting for rebuild() inside onEnd handler may cause a deadlock`)\n      }\n      return ok\n    })\n  }\n\n  function onBuildSuccess(timeStart, result/*esbuild.BuildResult*/) {\n    log.debug(\"esbuild finished with result\", result)\n    esbuildResult = result\n    logWarnings(result.warnings || [])\n    const time = fmtDuration(clock() - timeStart)\n    if (!config.outfile) {\n      log.info(style.green(\n        config.outdir ? `Wrote to dir ${config.outdir} (${time})` :\n                        `Finished (write=false, ${time})`\n      ))\n    } else {\n      let outname = config.outfile\n      if (config.sourcemap &&\n          config.outfileIsTemporary &&\n          config.sourcemap != \"inline\" &&\n          config.write !== false )\n      {\n        // repair \"sources\" filenames in sourcemap\n        patchSourceMap(config.outfileAbs + \".map\", {\n          sources: v => v && v.map(fn => Path.relative(config.cwd, fn)),\n        })\n      }\n      let size = 0\n      try { size = fs.statSync(config.outfileAbs).size } catch(_) {}\n      if (!config.outfileIsTemporary) {\n        log.info(style.green(`Wrote ${outname}`) + ` (${fmtByteSize(size)}, ${time})`)\n      }\n    }\n    lastBuildResults.warnings = result.warnings\n    lastBuildResults.errors = []\n    lastBuildResults.metafile = result.metafile || null\n    return onEnd(lastBuildResults, true)\n  }\n\n  let isInitialBuild = true  // TODO better name and documentation\n\n  function onBuildFail(timeStart, err) {\n    log.debug(\"esbuild finished with error:\", err ? err.stack || err : null)\n    let warnings = err.warnings || []\n    let errors = err.errors || []\n    if (errors.length == 0) {\n      // in this case the err is an Error object and describes the error\n      log.error(err.message)\n      errors.push({\n        text: String(err),\n        location: null,\n      })\n    }\n    // if (/^error: must provide/i.test(stderr)) {\n    //   // unrecoverable error in configuration\n    //   if (!config) { process.exit(1) }\n    // }\n    logWarnings(warnings)\n    lastBuildResults.warnings = warnings\n    lastBuildResults.errors = errors\n    if (!isInitialBuild) {\n      lastBuildResults.metafile = null\n    } else {\n      isInitialBuild = false\n    }\n    return onEnd(lastBuildResults, false)\n  }\n\n  // build function\n  async function _esbuild(fileEvents /*:FileEvent[]*/) {\n    if (config.watch && config.clear) {\n      clear()\n    }\n\n    // build list of changed filenames and check for entryPoint renames\n    let changedFiles = [] // :string[]\n    for (let f of fileEvents) {\n      if (f.type == \"move\") {\n        // renamed file: check entryPoints\n        let didModifyEntryPoints = false\n        if (Array.isArray(config.entryPoints)) {\n          const i = config.entryPoints ? config.entryPoints.indexOf(f.name) : -1\n          if (i != -1) {\n            log.debug(\"detected entryPoint file rename\", f.name, \"->\", f.newname)\n            config.entryPoints[i] = f.newname\n            didModifyEntryPoints = true\n          }\n        } else { // entryPoints is an object {outfile:infile}\n          for (let outfile of Object.keys(entryPoints)) {\n            let infile = entryPoints[outfile]\n            if (infile == f.name) {\n              entryPoints[outfile] = f.newname\n              didModifyEntryPoints = true\n              break\n            }\n          }\n        }\n        if (didModifyEntryPoints) {\n          esbuildOptions.entryPoints = config.entryPoints\n          esbuildResult = null // invalidate incremental esbuild (since config changed)\n        }\n        changedFiles.push(f.newname)\n      } else {\n        changedFiles.push(f.name)\n      }\n    }\n\n    config.entry = config.entryPoints\n\n    if (config.onStart) {\n      try {\n        const r = config.onStart(config, changedFiles, ctx, esbuildOptions)\n        if (r instanceof Promise) {\n          await r\n        }\n      } catch (err) {\n        log.debug(()=>`error in onStart handler: ${err.stack||err}`)\n        // onBuildFail(clock(), `error in onStart handler: ${err.stack||err}`)\n        throw err\n      }\n    }\n\n    if (config.isCancelled) {\n      return\n    }\n\n    const rebuild = !!(esbuildResult && esbuildResult.rebuild)\n\n    log.debug(()=>\n      `invoking ${rebuild ? \"esbuildResult.rebuild\" : \"esbuild.build\"} ` +\n      `in ${process.cwd()} with options: ${repr(esbuildOptions)}`\n    )\n\n    // wrap call to esbuild.build in a temporarily-changed working directory.\n    // TODO: When/if esbuild adds an option to set cwd, use that instead.\n    const tmpcwd = process.cwd()\n    process.chdir(config.cwd)\n    const esbuildPromise = (\n      rebuild ? esbuildResult.rebuild() :\n                esbuild.build(esbuildOptions)\n    )\n    process.chdir(tmpcwd)\n\n    return esbuildPromise.then(\n      onBuildSuccess.bind(null, clock()),\n      onBuildFail.bind(null, clock()),\n    )\n  }\n\n  // start initial build\n  const buildPromise = opts.diag ? null : _esbuild([])\n\n  // TypeScript linter\n  const [tslintProcess, tslintProcessReused] = (\n    tslintOptions !== \"off\" ? startTSLint(tslintOptions, opts, config) :\n    [null,false]\n  )\n  if (tslintProcess && !tslintProcessReused) {\n    // must add error handler now before `await buildPromise`\n    tslintProcess.catch(e => {\n      log.error(e.stack || String(e))\n      return false\n    })\n    ctx.addCancelCallback(() => { tslintProcess.cancel() })\n    // if -diag is set on the command line and screen clearing is enabled, clear the screen now\n    // as our buildPromise is already resolved (no build will occur and thus no clear from that.)\n    if (cliopts.diag && config.watch && config.clear) {\n      screen.clear()\n    }\n  }\n\n  // await build\n  let ok = true\n  if (buildPromise) {\n    log.debug(\"awaiting esbuild\")\n    ok = await buildPromise\n    if (config.isCancelled) {\n      return false\n    }\n  }\n\n  // watch mode?\n  if (config.watch) {\n    function getESBuildMeta() { // :Object|null\n      return lastBuildResults.metafile\n    }\n    await extra.watch().watchFiles(config, getESBuildMeta, ctx, fileEvents => {\n      // This function is invoked whenever source files changed.\n      // Note that the watchFiles() function takes care of updating source file tracking.\n      const n = fileEvents.length\n      const fv = fileEvents.map(f =>\n        f.type == \"move\" ? f.newname :\n                           f.name )\n      log.info(`${n} ${n > 1 ? \"files\" : \"file\"} changed: ${fv.join(\", \")}`)\n      return _esbuild(fileEvents)\n    })\n    log.debug(\"fswatch ended\")\n    return true\n  }\n\n  // otherwise, when not in watch mode, wait for tslint and exit\n  if (tslintProcess) {\n    let tscWaitTimer = null\n    if (!ok) {\n      log.debug(\"cancelling eslint since esbuild reported an error\")\n      tslintProcess.cancel()\n    } else {\n      log.debug(\"awaiting eslint\")\n      if (!tslintProcessReused && !opts.diag) {\n        tscWaitTimer = setTimeout(() => log.info(\"Waiting for TypeScript... (^C to skip)\"), 1000)\n      }\n      ok = await tslintProcess.catch(() => false) // error handled earlier\n    }\n    clearTimeout(tscWaitTimer)\n  }\n\n  if (!config.isCancelled && !ok) {\n    setErrorExitCode()\n  }\n\n  // wait for any running commands\n  if (ok) {\n    const exitCode = await run.waitAll()\n    process.exitCode = exitCode\n  }\n\n  return ok\n} // build1()\n\n\nconst tslintProcessCache = new Map() // configKey => TSLintProcess\n\n\nfunction startTSLint(tslintOptions, cliopts, config) { // : [tslintProcess, tslintProcessReused]\n  // assert(tslintOptions !== \"off\")\n\n  let mode = tslintOptions\n  let tscBasicOptions = {}\n  if (tslintOptions && typeof tslintOptions == \"object\") {\n    mode = undefined\n    tscBasicOptions = tslintOptions\n    if (tscBasicOptions.mode == \"off\") {\n      log.debug(() => `tslint disabled by tslint config {mode:\"off\"}`)\n      return [null, false]\n    }\n  }\n\n  if (config.tsrules && config.tsrules.length) {\n    log.info(\"The 'tsrules' property is deprecated. Please use 'tslint.rules' instead\")\n    tscBasicOptions.rules = { ...config.tsrules, ...tscBasicOptions.rules }\n  }\n\n  // have tslint clear the screen when it restarts ONLY when -diag (no build) is set.\n  const clearScreen = cliopts.diag && config.watch && config.clear\n\n  const tsconfigFile = tsutil.getTSConfigFileForConfig(config) // string|null\n\n  // tslint processes are kept to a minimum since they may screw with screen clearing and\n  // multiple log streams is confusing.\n  const cacheKey = `${tsconfigFile || config.cwd}`\n  const existingTSLintProcess = tslintProcessCache.get(cacheKey)\n  if (existingTSLintProcess) {\n    log.debug(() => `tslint sharing process (no new process created)`)\n    return [existingTSLintProcess, true]\n  }\n\n  let srcdir = config.cwd\n  if (config.entryPoints) {\n    if (Array.isArray(config.entryPoints)) {\n      if (config.entryPoints.length > 0) {\n        srcdir = dirname(config.entryPoints[0])\n      }\n    } else { // entryPoints is an object {outfile:infile}\n      for (let outfile of Object.keys(config.entryPoints)) {\n        srcdir = dirname(config.entryPoints[outfile])\n        break\n      }\n    }\n  }\n\n  const options = {\n    colors: style.ncolors > 0,\n    quiet: config.quiet,\n    mode,\n\n    ...tscBasicOptions,\n\n    watch: config.watch,\n    cwd: config.cwd,\n    clearScreen,\n    srcdir,\n    tsconfigFile,\n    onRestart() {\n      log.debug(\"tsc restarting\")\n      // // called when tsc begin to deliver a new session of diagnostic messages.\n      // if (config.clear && clock() - lastClearTime > 5000) {\n      //   // it has been a long time since we cleared the screen.\n      //   // tsc likely reloaded the tsconfig.\n      //   screen.clear()\n      // }\n      //\n      // if (config.clear && clock() - lastClearTime > 5e3) {\n      //                                     ^\n      // ReferenceError: lastClearTime is not defined\n    },\n  }\n\n  log.debug(() => `starting tslint with options ${repr(options)}`)\n  const tslintProcess = tslint(options)\n  tslintProcessCache.set(cacheKey, tslintProcess)\n\n  return [tslintProcess, false]\n}\n\n\nfunction logWarnings(warnings) {\n  if (warnings.length > 0) {\n    // TODO: include warnings[N].location\n    log.warn(\"[warn] \" + warnings.map(m => m.text).join(\"\\n\"))\n  }\n}\n\n\nfunction logErrors(errors) {\n  if (errors.length > 0) {\n    // TODO: include errors[N].location\n    log.error(errors.map(m => m.text).join(\"\\n\"))\n  }\n}\n\n\nfunction main() {\n  return build({[IS_MAIN_CALL]:1}).catch(e => {\n    console.error(stderrStyle.red(prog + \": \" + (e ? (e.stack || e) : \"error\")))\n    const exitCode = process.exitCode || 0\n    process.exit(\n      exitCode > 0 ? exitCode : 1\n    )\n  }).then(ok => {\n    const exitCode = process.exitCode || 0\n    process.exit(\n      ok ? exitCode :\n      exitCode > 0 ? exitCode : 1\n    )\n  })\n}\n\n\n// ------------------------------------------------------------------------\n// parse CLI and dispatch main\n\nfunction postProcessCLIOpts() {\n  if (cliopts[\"no-color\"]) {\n    cliopts.color = false\n  }\n  if (cliopts[\"no-diag\"]) {\n    cliopts.diag = false\n  }\n\n  // update ANSI color setting\n  log.colorMode = cliopts.color\n  style.reconfigure(process.stdout, cliopts.color)\n  stderrStyle.reconfigure(process.stderr, cliopts.color)\n\n  if (cliopts.color !== undefined) {\n    // user explicitly asked to either turn on or off color\n    // const nocolor  = process.argv.includes(\"-no-color\") || process.argv.includes(\"--no-color\")\n    // const yescolor = process.argv.includes(\"-color\") || process.argv.includes(\"--color\")\n  }\n\n  // just print version and exit?\n  if (cliopts[\"estrella-version\"]) {\n    console.log(`estrella ${VERSION}${DEBUG ? \" (debug)\" : \"\"}`)\n    process.exit(0)\n  }\n\n  // update log.debug function\n  if (cliopts[\"estrella-debug\"]) {\n    log.level = log.DEBUG\n  }\n\n  // -diag disables -run\n  if (cliopts.diag && cliopts.run) {\n    log.info(`Disabling -run since -diag is set`)\n    cliopts.run = undefined\n  }\n\n  log.debug(()=> `Parsed initial CLI arguments: ${repr({options:cliopts, args:cliargs},2)}`)\n}\n\nif (isCLI) {\n  // Note: esbuild replaces the module object, so when running from a esbuild bundle,\n  // module.id is undefined.\n  ;[cliopts, cliargs] = cli.parseopt(process.argv.slice(2), CLI_DOC_STANDALONE)\n  postProcessCLIOpts()\n  main()\n} else {\n\n  // parse CLI arguments\n  // Note: cliopts and cliargs are special objects exported in the API.\n  // Note: This is only invoked when estrella runs from a user script, not when run directly.\n  ;[cliopts, cliargs] = cli.parseopt(process.argv.slice(2),{\n    ...CLI_DOC,\n    unknownFlagAsArg: true,\n    help(flags, _cliopts, _cliargs) {\n      cli_ready = new Promise(resolve => {\n        process.nextTick(() => {\n          console.log(cli.fmtUsage(flags, CLI_DOC.usage, CLI_DOC.trailer))\n          process.exit(0)\n          resolve()\n        })\n      })\n    },\n  })\n\n  postProcessCLIOpts()\n\n\n  // extra unparsed arguments?\n  if (cliargs.length > 0) {\n    cli_ready.then(() => {\n      if (cliargs.length > 0) {\n        // user script did not parse args\n        cli.printUnknownOptionsAndExit(cliargs)\n      }\n    })\n  }\n\n  // parse(...flags :cli.Flags[]) : [cli.Options, string[]]\n  cliopts.parse = (...flags) => {\n    log.debug(() =>\n      `Parsing custom CLI arguments ${json(cliargs.join)} via cliopts.parse(` +\n      repr(flags) + \")\"\n    )\n\n    const optsAndArgs = cli.parseopt(cliargs, {\n      ...CLI_DOC,\n      flags: CLI_DOC.flags.concat(flags),\n    })\n\n    log.debug(()=>\n      `Parsed extra CLI arguments: ` +\n      json({options: optsAndArgs[0], args: optsAndArgs[1]}, 2)\n    )\n\n    // clear cliargs so to not cause an error for missing options\n    cliargs.splice(0, cliargs.length)\n\n    return optsAndArgs\n  }\n} // end if main\n\n\nfunction watch(path, options, cb) {\n  return extra.watch().watch(path, options, cb)\n}\n\n\nfunction legacy_watchdir(path, filter, options, cb) {\n  log.info(() => `estrella.watchdir is deprecated. Please use estrella.watch instead`)\n  if (cb === undefined) {\n    if (options === undefined) {\n      // watchdir(path, cb)\n      cb = filter\n      options = {}\n    } else {\n      // watchdir(path, filter, cb)\n      cb = options\n      options = { ...options, filter }\n      if (options.recursive !== undefined) {\n        if (!options.recursive) {\n          options.depth = 0\n        }\n        delete options.recursive\n      }\n    }\n  }\n  return watch(path, options, cb)\n}\n\n\nlet _tsapiInstance = undefined\n\n\n// API\nmodule.exports = {\n  // data\n  version: VERSION,\n  prog,    // CLI program name\n  cliopts, // parsed command-line options\n  cliargs, // command-line arguments left after parsing options\n\n  // functions\n  dirname,   // from NodeJS's \"path\" module\n  basename,  // from NodeJS's \"path\" module\n  watch,\n  watchdir: legacy_watchdir,\n  scandir,\n  tslint,\n  defaultTSRules,\n  termStyle,\n  stdoutStyle: style,\n  stderrStyle: stderrStyle,\n  chmod: file.chmod,\n  editFileMode: file.editMode,\n  fmtDuration,\n  tildePath,\n  findInPATH,\n  tsconfig: tsutil.getTSConfigForConfig,\n  tsconfigFile: tsutil.getTSConfigFileForConfig,\n  glob: glob.glob,\n  globmatch: glob.match,\n  file,\n  sha1,\n  log,\n\n  // TypeScript API\n  get ts() {\n    if (_tsapiInstance === undefined) {\n      _tsapiInstance = tsapi.createTSAPI()\n    }\n    return _tsapiInstance\n  },\n\n  // ----------------------------------------------------------------------------\n  // main build function\n  // build(config :BuildConfig) :Promise<boolean>\n  build,\n}\n", "import * as Path from \"path\"\n\nimport { runtimeRequire } from \"./util\"\nimport { log, LogLevel } from \"./log\"\nimport * as file from \"./file\"\nimport * as debugModule from \"./debug/debug\"\nimport * as watchModule from \"./watch/watch\"\n\nexport type DebugModule = typeof debugModule\nexport type WatchModule = typeof watchModule\n\ntype FileModule = typeof file\n\ninterface AuxModule {\n  initModule(logLevel :LogLevel, file :FileModule) :void\n}\n\n// used by tests\nlet estrellaDir = __dirname\nexport function setEstrellaDir(dir :string) {\n  estrellaDir = dir\n}\n\n\nfunction createLazyModuleAccessor<T extends AuxModule>(filename :string) :()=>T {\n  let m : T | null = null\n  return function getLazyModule() :T {\n    if (!m) {\n      log.debug(`loading ${filename} module`)\n      m = runtimeRequire(Path.join(estrellaDir, filename))\n      m!.initModule(log.level, file)\n    }\n    return m!\n  }\n}\n\nexport const debug = createLazyModuleAccessor<DebugModule>(DEBUG ? \"debug.g.js\" : \"debug.js\")\nexport const watch = createLazyModuleAccessor<WatchModule>(DEBUG ? \"watch.g.js\" : \"watch.js\")\n", "import {\n  TermStyle as TermStyleAPI,\n  TermStyleFun,\n  TTYStream,\n  NoTTYStream,\n} from \"../estrella\"\n\n\nexport interface TermStyle extends TermStyleAPI {\n  _hint :boolean|undefined  // original hint\n\n  // Like calling termStyle but instead of returning a new TermStyle object,\n  // the receiver (this) is updated/mutated.\n  reconfigure(w :TTYStream|NoTTYStream, hint? :boolean) :TermStyle\n}\n\n\nfunction numColors(w :TTYStream|NoTTYStream, hint? :boolean) {\n  let ncolors = 0\n  if (hint === true) {\n    // use colors regardless of TTY or not\n    let t = process.env.TERM || \"\"\n    ncolors = (\n      t && ['xterm','screen','vt100'].some(s => t.indexOf(s) != -1) ? (\n        t.indexOf('256color') != -1 ? 8 : 4\n      ) : 2\n    )\n  } else if (hint !== false && w.isTTY) {\n    // unless hint is explicitly false, use colors if stdout is a TTY\n    ncolors = w.getColorDepth()\n  }\n  return ncolors\n}\n\ntype TermStyleFunCons = (open16 :string, open256 :string, close :string) => TermStyleFun\n\n\nexport function termStyle(w :TTYStream|NoTTYStream, hint? :boolean) :TermStyle {\n  return createTermStyle(numColors(w, hint), hint)\n}\n\n\nexport function createTermStyle(ncolors :number, hint? :boolean) :TermStyle {\n  const CODE = (s :string) => `\\x1b[${s}m`\n\n  const effect :(open :string, close :string)=>TermStyleFun = (\n    ncolors > 0 || hint ? (open, close) => {\n      const a = CODE(open), b = CODE(close)\n      return s => a + s + b\n    } :\n    (_) => s => s\n  )\n\n  const color :TermStyleFunCons = (\n\n    // 256 colors support\n    ncolors >= 8 ? (_open16, open256, close) => {\n      // const open = CODE(code), close = CODE('2' + code)\n      let a = '\\x1b[' + open256 + 'm', b = '\\x1b[' + close + 'm'\n      return s => a + s + b\n    } :\n\n    // 16 colors support\n    ncolors > 0 ? (open16, _open256, close) => {\n      let a = '\\x1b[' + open16 + 'm', b = '\\x1b[' + close + 'm'\n      return s => a + s + b\n    } :\n\n    // no colors\n    (_open16, _open256, _close) => s => s\n  )\n\n  return {\n    _hint: hint,\n    ncolors,\n\n    reset     : hint || ncolors > 0 ? \"\\e[0m\" : \"\",\n\n    bold      : effect('1', '22'),\n    italic    : effect('3', '23'),\n    underline : effect('4', '24'),\n    inverse   : effect('7', '27'),\n\n    // name           16c    256c                 close\n    white       : color('37',  '38;2;255;255;255',  '39'),\n    grey        : color('90',  '38;5;244',          '39'),\n    black       : color('30',  '38;5;16',           '39'),\n    blue        : color('34',  '38;5;75',           '39'),\n    cyan        : color('36',  '38;5;87',           '39'),\n    green       : color('32',  '38;5;84',           '39'),\n    magenta     : color('35',  '38;5;213',          '39'),\n    purple      : color('35',  '38;5;141',          '39'),\n    pink        : color('35',  '38;5;211',          '39'),\n    red         : color('31',  '38;2;255;110;80',   '39'),\n    yellow      : color('33',  '38;5;227',          '39'),\n    lightyellow : color('93',  '38;5;229',          '39'),\n    orange      : color('33',  '38;5;215',          '39'),\n\n    reconfigure(w :TTYStream|NoTTYStream, hint? :boolean) :TermStyle {\n      const ncolors = numColors(w, hint)\n      if (ncolors != this.ncolors && hint != this._hint) {\n        Object.assign(this, createTermStyle(ncolors, hint))\n      }\n      return this\n    },\n\n  }\n}\n\nexport const stdoutStyle = termStyle(process.stdout)\nexport const stderrStyle = termStyle(process.stderr)\n", "import { Console } from \"console\"\nimport { stdoutStyle, stderrStyle } from \"./termstyle\"\nimport { memoize } from \"./memoize\"\nimport { prog } from \"./cli\"\nimport { captureStackTrace } from \"./error\"\n\nimport { Log as LogAPI } from \"../estrella\"\n\ndeclare const DEBUG :boolean\n\nexport interface Env {\n  log :typeof log\n}\n\nexport enum LogLevel {\n  Silent = -1,// log nothing\n  Error = 0,  // only log errors\n  Warn,       // log errors and warnings\n  Info,       // log errors, warnings and info\n  Debug,      // log everything\n}\n\nlet log_console = console\nlet log_colorMode :boolean|undefined = undefined\n\nexport const log = new class Log implements LogAPI {\n  readonly SILENT = LogLevel.Silent // = -1\n  readonly ERROR  = LogLevel.Error  // = 0\n  readonly WARN   = LogLevel.Warn   // = 1\n  readonly INFO   = LogLevel.Info   // = 2\n  readonly DEBUG  = LogLevel.Debug  // = 3\n\n  level = LogLevel.Info\n\n  error(...v :any[]) :void {\n    if (log.level >= LogLevel.Error) {\n      evalFunctionInArgs(v)\n      log_console.error(stderrStyle.red(`${prog}:`), ...v)\n    }\n  }\n  warn(...v :any[]) :void {\n    if (log.level >= LogLevel.Warn) {\n      evalFunctionInArgs(v)\n      log_console.error(stderrStyle.magenta(`${prog}:`), ...v)\n    }\n  }\n  info(...v :any[]) :void {\n    if (log.level >= LogLevel.Info) {\n      evalFunctionInArgs(v)\n      log_console.log(...v)\n    }\n  }\n\n  // DEPRECATED in Estrella 1.2.2\n  readonly infoOnce = this.info\n\n  readonly debug = log_debug\n\n  get colorMode() :boolean|undefined {\n    return log_colorMode\n  }\n  set colorMode(colorMode :boolean|undefined) {\n    if (log_colorMode === colorMode) {\n      return\n    }\n    log_colorMode = colorMode\n    if (colorMode === undefined) { // auto\n      log_console = console\n    } else {\n      log_console = new Console({\n        stdout: process.stdout,\n        stderr: process.stderr,\n        colorMode\n      })\n    }\n  }\n}\n\nexport default log\n\nfunction evalFunctionInArgs(args :any[]) {\n  // evaluate first function argument\n  if (typeof args[0] == \"function\") {\n    args[0] = args[0]()\n  }\n}\n\nfunction log_debug(...v :any[]) {\n  if (log.level >= LogLevel.Debug) {\n    let meta = \"\"\n\n    if (DEBUG) {\n      // stack traces are only useful in debug builds (not mangled)\n      const stack = captureStackTrace(log_debug)\n      const frames = stack.split(\"\\n\", 5)\n      const f = frames[1]  // stack frame\n      let m = f && /at (\\w+)/.exec(f)\n      if (m) {\n        meta = \" \" + m[1]\n      } else if (!m && frames[2]) {\n        if (m = frames[2] && /at (\\w+)/.exec(frames[2])) {\n          meta = ` ${m[1]} \u2192 ${stdoutStyle.italic(\"f\")}`\n        }\n      }\n    }\n\n    evalFunctionInArgs(v)\n\n    if (v.length == 0 || (v.length == 1 && (v[0] === \"\" || v[0] === undefined))) {\n      // Nothing to be logged.\n      // This is sometimes useful when logging something complex conditionally, for example:\n      //   log.debug(() => {\n      //     if (expensiveComputation()) {\n      //       return \"redirecting foobar to fuzlol\"\n      //     }\n      //   })\n      return\n    }\n\n    log_console.log(stdoutStyle.bold(stdoutStyle.blue(`[DEBUG${meta}]`)), ...v)\n  }\n}\n", "import * as Path from \"path\"\nimport { json } from \"./util\"\n\n\n// parse CLI program name (as invoked)\nexport const prog = (() :string => {\n  const $_ = process.env[\"_\"]\n  const scriptfile = process.argv[1]\n  if (!scriptfile) {\n    // unlikely\n    return $_ || process.argv[0]\n  }\n  if ($_ && !Path.isAbsolute($_)) {\n    // accurate in some shells (like bash, but not in zsh)\n    return $_\n  }\n  let prefix = \"\"\n  if ($_) {\n    const nodeExecName = Path.basename(process.execPath)\n    if ($_.endsWith(Path.sep + nodeExecName)) {\n      // the script was invoked by explicitly calling node.\n      // e.g. \"node build.js\"\n      prefix = nodeExecName + \" \"\n    }\n  }\n  if (scriptfile.startsWith(process.cwd())) {\n    let rel = Path.relative(process.cwd(), scriptfile)\n    if (!rel.startsWith(\"node_modules\"+Path.sep) &&\n        rel.indexOf(Path.sep+\"node_modules\"+Path.sep) == -1\n    ) {\n      if (Path.sep == \"/\") {\n        // on posix systems, this is needed to avoid PATH resolution\n        rel = \"./\" + rel\n      }\n      return rel\n    }\n  }\n  return prefix + Path.basename(scriptfile)\n})()\n\n\nexport function printUsageAndExit(usage :string, errmsg? :string|null) {\n  const msg = usage.trim().replace(/\\$0\\b/g, prog)\n  if (errmsg) {\n    console.error(`${prog}: ${errmsg}\\n` + msg)\n    process.exit(1)\n  } else {\n    console.log(msg)\n    process.exit(0)\n  }\n}\n\n// parseopt types\nexport interface Doc {\n  usage?   :Usage|null\n  flags    :Flags[]\n  trailer? :string\n\n  // if true, treat an unknown flag as an argument (no error)\n  unknownFlagAsArg? :boolean\n\n  // help is a function which is invoked INSTEAD OF printing help and exiting the process.\n  // The function receives three values:\n  //   flags   -- available flags\n  //   options -- flag values parsed so far\n  //   args    -- remaining, unprocessed input arguments\n  // options and args are the same values returned by parseopt()\n  //\n  help? :( (flags: FlagInfo[], options :Options, args :string[]) => void ) | null\n}\nexport type Usage = string | (()=>string)\nexport type Flags = (Flag | null | undefined | false)[]  // falsy elements are ignored\nexport type Flag  = string | [ string|string[] , string?, string? ]\nexport interface FlagInfo {\n  names        :string[]\n  description? :string\n  valueName?   :string\n  valueType?   :string\n  valueParser? :(v:string)=>any\n}\nexport type Options = { [k :string] :any }\n\n// parseopt parses command-line arguments.\n// Returns options and unparsed remaining arguments.\n//\n// flag format:\n//\n//   flag      = flagname | flagspec\n//   flagname  = \"-\"* <text>\n//   flagnames = Array< flagname+ >\n//   flagspec  = Tuple< flagnames | flagname >\n//\n// flag format examples:\n//\n//   \"verbose\"\n//   Simple boolean flag that can be set with -verbose or --verbose.\n//\n//   [ \"v\", \"Show version\" ]\n//   Boolean flag \"v\" with description text shown in program usage.\n//\n//   [ \"v, version\", \"Show version\" ]\n//   [ [\"v\", \"version\"], \"Show version\" ]\n//   Boolean flag \"v\" with alternate name \"version\" with description.\n//\n//   [ [\"v\", \"version\"] ]\n//   Boolean flag \"v\" with alternate name \"version\" without description.\n//\n//   [ \"o\", \"Output file\", \"<path>\" ]\n//   Value flag with description. Value type defaults to string.\n//   Can be invoked as -o=path, --o=path, -o path, and --o path.\n//\n//   [ \"o\", \"\", \"<path>\" ]\n//   Value flag without description.\n//\n//   [ \"limit\", \"Show no more than <limit> items\", \"<limit:number>\" ]\n//   Value flag with type constraint. Passing a value that is not a JS number\n//   causes an error message.\n//\n//   [ \"with-openssl\", \"\", \"enable:bool\" ]\n//   Boolean flag\n//\nexport function parseopt(argv :string[], doc :Doc) :[Options, string[]] {\n  let [flagmap, opts] = parseFlags(doc.flags.filter(f => f) as Flag[])\n  let options :Options = {}\n  let help = false\n  let args :string[] = []\n  let i = 0\n\n  const eatArg = () => {\n    args.push(argv.splice(i, 1)[0])\n    i--\n  }\n\n  for (; i < argv.length; i++) {\n    // read argument\n    let arg = argv[i]\n    if (arg == '--') {\n      i++\n      break\n    }\n    if (arg[0] != '-' || arg == '-') {\n      eatArg()\n      continue\n    }\n    arg = arg.replace(/^\\-+/, '')\n    let eqp = arg.indexOf('=')\n    let argval :string|undefined = undefined\n    if (eqp != -1) {\n      // e.g. -name=value\n      argval = arg.substr(eqp + 1)\n      arg = arg.substr(0, eqp)\n    }\n\n    // lookup flag\n    let opt = flagmap.get(arg)\n    if (!opt) {\n      if (arg == \"h\" || arg == \"help\") {\n        help = true\n        if (!doc.help) {\n          console.log(fmtUsage(opts, doc.usage, doc.trailer))\n          process.exit(0)\n        }\n      } else if (doc.unknownFlagAsArg) {\n        eatArg()\n        continue\n      } else {\n        printUnknownOptionsAndExit([argv[i]])\n      }\n      break\n    }\n\n    // save option\n    let value :any = true\n    if (opt.valueName) {\n      if (argval === undefined) {\n        // -k v\n        argval = argv[i + 1]\n        if (argval !== undefined && argval[0] != \"-\") {\n          i++\n        // } else if (opt.valueType == \"boolean\") {\n        //   argval = \"true\"\n        } else {\n          console.error(`missing value for option -${arg} (see ${prog} -help)`)\n          process.exit(1)\n          break\n        }\n      } // else -k=v\n      try {\n        value = opt.valueParser ? opt.valueParser(argval) : argval\n      } catch (err) {\n        console.error(`invalid value for option -${arg} (${err.message})`)\n      }\n    } else if (argval !== undefined) {\n      console.error(`unexpected value provided for flag -${arg}`)\n      process.exit(1)\n    } // else: e.g. -k\n\n    options[arg] = value\n\n    // alias spread\n    for (let alias of opt.names) {\n      if (alias == arg) {\n        continue\n      }\n      options[alias] = value\n    }\n\n  } // for (; i < argv.length; i++)\n\n  if (i < argv.length) {\n    args = args.concat(argv.slice(i))\n  }\n\n  if (help && doc.help) {\n    doc.help(opts, options, args)\n  }\n\n  return [options, args]\n}\n\n\nexport function printUnknownOptionsAndExit(args :string[]) {\n  console.error(\n    `unknown option${args.length > 1 ? \"s\" : \"\"} ${args.join(\", \")} (see ${prog} -help)`)\n  process.exit(1)\n}\n\n\n// parseFlags parses falgs and returns normalized structured options.\n// Returns:\n//   [0] Mapping of argument name (e.g. \"help\") to options.\n//   [1] Unique set of options (e.g. {flags:[\"h\",\"help\"],...}).\n//\nexport function parseFlags(flags :Flag[]) :[ Map<string,FlagInfo>, FlagInfo[] ] {\n  let fimap = new Map<string,FlagInfo>()\n  let fiv :FlagInfo[] = []\n  for (let f of flags) {\n    let fi = parseFlag(f)\n    fiv.push(fi)\n    for (let k of fi.names) {\n      if (fimap.has(k)) {\n        throw new Error(`duplicate CLI flag ${json(k)} in definition ${json(f)}`)\n      }\n      fimap.set(k, fi)\n    }\n  }\n  return [fimap, fiv]\n}\n\n\nfunction parseFlag(f :Flag) :FlagInfo {\n  const cleanFlag = (s :string) => s.replace(/(?:^|[\\s,])\\-+/g, '')\n  const splitComma = (s :string) => s.split(/\\s*,\\s*/)\n\n  if (typeof f == \"string\") {\n    return { names: splitComma(cleanFlag(f)) }\n  }\n\n  let o :FlagInfo = {\n    names: (\n      typeof f[0] == \"string\" ? splitComma(cleanFlag(f[0])) :\n      f[0].map(cleanFlag)\n    ),\n    description: f[1] || undefined\n  }\n\n  if (f[2]) {\n    let [name, type] = f[2].replace(/^[<>]+|[<>]+$/g, '').split(/:/, 2)\n    if (type) {\n      switch (type.toLowerCase()) {\n\n        case 'string':\n        case 'str':\n          type = 'string'\n          break\n\n        case 'bool':\n        case 'boolean':\n          type = 'boolean'\n          o.valueParser = s => {\n            s = s.toLowerCase()\n            return s != \"false\" && s != \"0\" && s != \"no\" && s != \"off\"\n          }\n          break\n\n        case 'number':\n        case 'num':\n        case 'float':\n        case 'int':\n          type = 'number'\n          o.valueParser = s => {\n            let n = Number(s)\n            if (isNaN(n)) {\n              throw new Error(`${json(s)} is not a number`)\n            }\n            return n\n          }\n          break\n\n        default:\n          throw new Error(`invalid argument type \"${type}\"`)\n      }\n    } else {\n      type = \"string\"\n    }\n    o.valueName = name || type\n    o.valueType = type\n  }\n  return o\n}\n\n\nexport function fmtUsage(opts :FlagInfo[], usage? :Usage|null, trailer? :string) :string {\n  // s/$name/value/\n  let vars :{[k:string]:any} = {\n    prog: prog,\n    \"0\": prog,\n  }\n  const subvars = (s :string) :string => s.replace(/\\$(\\w+)/g, (_, v) => {\n    let sub = vars[v]\n    if (!sub) {\n      throw new Error(`unknown variable $${v} (to print a dollar sign, use '\\\\$')`)\n    }\n    return sub\n  })\n\n  // start with usage\n  let s = subvars(\n    usage ?\n      typeof usage == 'function' ? usage() :\n                                   String(usage) :\n    opts.length > 0 ?\n      `Usage: $prog [options]` :\n      `Usage: $prog`\n  )\n\n  if (opts.length > 0) {\n    s += '\\noptions:\\n'\n    let longestFlagName = 0\n    let flagNames :string[] = []\n\n    for (let f of opts) {\n      let flagName = \"  -\" + (\n        // -f=,-file=<file>\n        f.valueName ?\n          f.names.join(\"=,-\") + \"=\" + (\n            f.valueType == \"boolean\" ? 'on|off' :\n                                       '<' + f.valueName + '>'\n          ) :\n        // -f, -file\n        f.names.join(\", -\")\n      )\n      longestFlagName = Math.max(longestFlagName, flagName.length)\n      flagNames.push(flagName)\n    }\n\n    for (let i = 0; i < opts.length; i++) {\n      let f = opts[i]\n      let names = flagNames[i]\n      let descr = f.description\n      if (!f.description) {\n        // default to \"Set flagname\" (\"Enable flagname\" for bool flags)\n        descr = f.valueType ? \"Set \" : \"Enable \" + f.names.reduce(\n          (a,s) => (s.length > a.length ? s : a), // pick longest name\n          \"\"\n        )\n      }\n      s += `${names.padEnd(longestFlagName, \" \")}  ${descr}`\n      if (i + 1 < opts.length) {\n        s += \"\\n\"\n      }\n    }\n  }\n\n  // end with trailer\n  if (trailer) {\n    s += \"\\n\" + subvars(trailer.replace(/[\\n\\s]+$/, \"\"))\n  }\n\n  return s\n}\n\n", "import * as fs from \"fs\"\nimport { PathLike } from \"fs\"\nimport * as Path from \"path\"\nimport * as crypto from \"crypto\"\nimport { chmodp, Modifier as ChModModifier, editFileMode } from \"./chmod\"\nimport { clock, tildePath } from \"./util\"\nimport { stdoutStyle } from \"./termstyle\"\nimport log from \"./log\"\nimport { UserError } from \"./error\"\n\nimport { WatchOptions, file as filedecl, FileWriteOptions } from \"../estrella.d\"\n\n\nconst fsp = fs.promises\n\n// fileModificationLog contains a list of [filename,Date.now()] of files that where\n// modified through the API. This data is used by watch.\nexport const fileModificationLog :{[filename:string]:number} = {}\n\nexport function fileModificationLogAppend(filename :PathLike) {\n  // TODO figure out a way to make it not grow unbounded with variable file names\n  fileModificationLog[Path.resolve(String(filename))] = clock()\n}\n\nexport function fileWasModifiedRecentlyByUser(filename :string) {\n  const ageThreshold = 30000\n  const time = fileModificationLog[Path.resolve(filename)]\n  return time !== undefined && clock() - time <= ageThreshold\n}\n\n// trick to make TypeScript type check our definitions here against those in estrella.d.ts\nexport const _ts_check_file :typeof filedecl = file\n\n\n// file() reads all contents of a file (same as file.read)\nexport function file(filename :PathLike, options :{encoding:string,flag?:string}|string) :Promise<string>\nexport function file(filename :PathLike, options :{encoding?:null,flag?:string}) :Promise<Buffer>\nexport function file(filename :PathLike) :Promise<Buffer>\nexport function file(\n  filename: PathLike,\n  options? :{encoding?:string|null,flag?:string}|string,\n) :Promise<string|Buffer> {\n  return fsp.readFile(filename, options as any)\n}\n\nfile.editMode = editFileMode\n\n\nfile.chmod = (filename :PathLike, modifier :ChModModifier) => {\n  fileModificationLogAppend(filename)\n  return chmodp(filename, modifier)\n}\n\n\ntype ReadOptions = fs.BaseEncodingOptions & { flag?: string | number; }\n                 | BufferEncoding\n                 | null\n\nfunction read(\n  filename :PathLike,\n  options :{encoding:BufferEncoding, flag?:fs.OpenMode} | BufferEncoding\n) :Promise<string>\nfunction read(filename :PathLike,\n  options :{encoding?:null, flag?:fs.OpenMode} | null\n) :Promise<Buffer>\nfunction read(filename :PathLike) :Promise<Buffer>\nfunction read(filename :PathLike, options? :ReadOptions) :Promise<string|Buffer> {\n  return fsp.readFile(filename, options)\n}\nfile.read = read\n\n\nfunction readSync(\n  filename :PathLike,\n  options :{encoding:BufferEncoding,flag?:fs.OpenMode} | BufferEncoding\n) :string\nfunction readSync(filename :PathLike, options :{encoding?:null,flag?:fs.OpenMode} | null) :Buffer\nfunction readSync(filename :PathLike) :Buffer\nfunction readSync(filename :PathLike, options? :ReadOptions) :string|Buffer {\n  // Note: typecast of options since fs type defs for node12 are incorrect: type of flags\n  // do not list number, even though the official nodejs documentation does.\n  // https://nodejs.org/docs/latest-v12.x/api/fs.html#fs_file_system_flags\n  return fs.readFileSync(filename, options as ReadOptions&{flag?: string})\n}\nfile.readSync = readSync\n\n\nfile.stat = fsp.stat\n\n\nfunction mtime(filename :PathLike) :Promise<number|null>\nfunction mtime(...filenames :PathLike[]) :Promise<(number|null)[]>\nfunction mtime(...filenames :PathLike[]) :Promise<number|null|(number|null)[]> {\n  return Promise.all(filenames.map(filename =>\n    fsp.stat(filename).then(st => st.mtimeMs).catch(_ => null)\n  )).then(r => r.length == 1 ? r[0] : r)\n}\nfile.mtime = mtime\n\nfile.readall = (...filenames :PathLike[]) =>\n  Promise.all(filenames.map(fn => fsp.readFile(fn)))\n\nfile.readallText = (encoding :string|null|undefined, ...filenames :PathLike[]) =>\n  Promise.all(filenames.map(fn => fsp.readFile(fn, {\n    encoding: (encoding||\"utf8\") as BufferEncoding\n  })))\n\nfile.write = async (filename :PathLike, data :string|Uint8Array, options? :FileWriteOptions) => {\n  fileModificationLogAppend(filename)\n  const opt = options && typeof options == \"object\" ? options : {}\n  try {\n    await fsp.writeFile(filename, data, options)\n  } catch (err) {\n    if (!opt.mkdirOff && err.code == \"ENOENT\") {\n      await file.mkdirs(Path.dirname(String(filename)), opt.mkdirMode)\n      await fsp.writeFile(filename, data, options)\n    } else {\n      throw err\n    }\n  }\n  if (opt.log) {\n    let relpath = Path.relative(process.cwd(), String(filename))\n    if (relpath.startsWith(\"..\" + Path.sep)) {\n      relpath = tildePath(filename)\n    }\n    log.info(stdoutStyle.green(`Wrote ${relpath}`))\n  }\n}\n\nfile.writeSync = (filename :PathLike, data :string|Uint8Array, options? :FileWriteOptions) => {\n  // See note in readSync regarding the typecast\n  fileModificationLogAppend(filename)\n  fs.writeFileSync(filename, data, options as fs.WriteFileOptions)\n}\n\nfunction sha1(filename :PathLike) :Promise<Buffer>\nfunction sha1(filename :PathLike, outputEncoding :crypto.BinaryToTextEncoding) :Promise<string>\n\nfunction sha1(\n  filename :PathLike,\n  outputEncoding? :crypto.BinaryToTextEncoding,\n) :Promise<Buffer|string> {\n  return new Promise<Buffer|string>((resolve, reject) => {\n    const reader = fs.createReadStream(filename)\n    const h = crypto.createHash('sha1')\n    reader.on('error', reject)\n    reader.on('end', () => {\n      h.end()\n      resolve(outputEncoding ? h.digest(outputEncoding) : h.digest())\n    })\n    reader.pipe(h)\n  })\n}\n\nfile.sha1 = sha1\n\nfile.copy = (srcfile :PathLike, dstfile :PathLike, failIfExist? :boolean) => {\n  let mode = fs.constants.COPYFILE_FICLONE  // copy-on-write (only used if OS supports it)\n  if (failIfExist) {\n    mode |= fs.constants.COPYFILE_EXCL\n  }\n  fileModificationLogAppend(dstfile)\n  return fsp.copyFile(srcfile, dstfile, mode)\n}\n\nfile.move = (oldfile :PathLike, newfile :PathLike) => {\n  fileModificationLogAppend(newfile)\n  return fsp.rename(oldfile, newfile)\n}\n\nfile.mkdirs = (dir :PathLike, mode? :fs.Mode) :Promise<boolean> => {\n  return fsp.mkdir(dir, {recursive:true, mode}).then(s => !!s && s.length > 0)\n}\n\n\ntype LegacyWatchOptions = {\n  recursive? :boolean\n}\n\n\nexport async function scandir(\n  dir      :string|string[],\n  filter?  :RegExp|null,\n  options? :(WatchOptions & LegacyWatchOptions)|null,\n) :Promise<string[]> {\n  if (!options) { options = {} }\n  if (!fs.promises || !fs.promises.opendir) {\n    // opendir was added in node 12.12.0\n    throw new Error(`scandir not implemented for nodejs <12.12.0`) // TODO\n  }\n  const files :string[] = []\n  const visited = new Set<String>()\n\n  const maxdepth = (\n    options.recursive !== undefined ? // legacy option from estrella <=1.1\n      options.recursive ? Infinity : 0 :\n    options.depth !== undefined ? options.depth :\n    Infinity\n  )\n\n  async function visit(dir :string, reldir :string, depth :number) {\n    if (visited.has(dir)) {\n      // cycle\n      return\n    }\n    visited.add(dir)\n    const d = await fs.promises.opendir(dir)\n    // Note: d.close() is called implicitly by the iterator/generator\n    for await (const ent of d) {\n      let name = ent.name\n      if (ent.isDirectory()) {\n        if (maxdepth < depth) {\n          await visit(Path.join(dir, name), Path.join(reldir, name), depth + 1)\n        }\n      } else if (ent.isFile() || ent.isSymbolicLink()) {\n        if (filter && filter.test(name)) {\n          files.push(Path.join(reldir, name))\n        }\n      }\n    }\n  }\n\n  const dirs = Array.isArray(dir) ? dir : [dir]\n\n  return Promise.all(dirs.map(dir =>\n    visit(Path.resolve(dir), \".\", 0)\n  )).then(() => files.sort())\n}\n", "import * as fs from \"fs\"\nimport { json } from \"./util\"\n\nconst chr = String.fromCharCode\nconst ord = (s :string, offs :number) => s.charCodeAt(offs || 0)\n\n\nexport type Modifier = number\n                     | string\n                     | string[]\n\n// chmod edits mode of a file (synchronous)\n// If m is a number, the mode is simply set to m.\n// If m is a string or list of strings, the mode is updated using editFileMode.\n// Returns the new mode set on file.\nexport function chmod(file :fs.PathLike, modifier :Modifier) :number {\n  if (typeof modifier == \"number\") {\n    fs.chmodSync(file, modifier)\n    return modifier\n  }\n  let mode = fs.statSync(file).mode\n  let newMode = editFileMode(mode, modifier)\n  if (mode != newMode) {\n    fs.chmodSync(file, newMode)\n  }\n  return newMode\n}\n\n// async version of chmod\nexport function chmodp(file :fs.PathLike, modifier :Modifier) :Promise<number> {\n  return new Promise<number>((resolve, reject) => {\n    if (typeof modifier == \"number\") {\n      return fs.chmod(file, modifier, err => {\n        err ? reject(err) : resolve(modifier)\n      })\n    }\n    fs.stat(file, (err, st) => {\n      if (err) return reject(err)\n      let newMode = editFileMode(st.mode, modifier)\n      if (st.mode == newMode) {\n        return resolve(newMode)\n      }\n      fs.chmod(file, newMode, err => {\n        err ? reject(err) : resolve(newMode)\n      })\n    })\n  })\n}\n\n\n// editFileMode takes a file mode (e.g. 0o764), applies modifiers and returns the resulting mode.\n// It accepts the same format as the Posix chmod program.\n// If multiple modifiers are provided, they are applied to mode in order.\n//\n// Grammar of modifier format:\n//\n//   mode   := clause [, clause ...]\n//   clause := [who ...] [action ...] action\n//   action := op [perm ...]\n//   who    := a | u | g | o\n//   op     := + | - | =\n//   perm   := r | w | x\n//\n// Examples:\n//\n//   // Set execute bit for user and group\n//   newMode = editFileMode(0o444, \"ug+x\") // => 0o554\n//\n//   // Set execute bit for user, write bit for group and remove all access for others\n//   newMode = editFileMode(0o444, \"+x,g+w,o-\") // => 0o560\n//\nexport function editFileMode(mode :number, modifier :string|string[]) :number {\n  const expectedFormat = `Expected format: [ugoa]*[+-=][rwx]+`\n\n  const err = (msg :string, m :any) =>\n    new Error(`${msg} in modifier ${json(m)}. ${expectedFormat}`)\n\n  let mods :string[] = []\n  for (let m of Array.isArray(modifier) ? modifier : [ modifier ]) {\n    mods = mods.concat(m.trim().split(/\\s*,+\\s*/))\n  }\n\n  for (let m of mods) {\n    let who :number[] = []\n    let all = false\n    let op = 0\n    let perm = 0\n\n    for (let i = 0; i < m.length; i++) {\n      let c = ord(m, i)\n      if (op == 0) {\n        switch (c) {\n          case 0x75: // u\n          case 0x67: // g\n          case 0x6F: // o\n            if (!all) {\n              who.push(c)\n            }\n            break\n          case 0x61: // a\n            who = [ 0x75, 0x67, 0x6F ]\n            all = true\n            break\n          case 0x2B: // +\n          case 0x2D: // -\n          case 0x3D: // =\n            op = c\n            break\n          default:\n            if (op == 0) {\n              throw err(`Invalid target or operation ${json(chr(c))}`, m)\n            }\n            break\n        }\n      } else {\n        switch (c) {\n          case 0x72: perm |= 0o4 ; break // r\n          case 0x77: perm |= 0o2 ; break // w\n          case 0x78: perm |= 0o1 ; break // x\n          default: throw err(`Invalid permission ${json(chr(c))}`, m)\n        }\n      }\n    }\n    if (op == 0) {\n      throw err(`Missing operation`, m)\n    }\n    if (who.length == 0) {\n      who = [ 0x75 ] // u\n    }\n    if (perm == 0) {\n      perm = 0o4 | 0o2 | 0o1\n    }\n\n    let mode2 = 0\n    for (let w of who) {\n      switch (w) {\n        case 0x75: mode2 |= (perm << 6) ; break  // u\n        case 0x67: mode2 |= (perm << 3) ; break  // g\n        case 0x6F: mode2 |= perm        ; break  // o\n      }\n    }\n    switch (op) {\n      case 0x2B: mode |= mode2 ; break  // +\n      case 0x2D: mode &= ~mode2 ; break // -\n      case 0x3D: mode = mode2 ; break   // =\n    }\n    // For debugging:\n    // console.log({\n    //   who: who.map(n => '0o' + n.toString(8)),\n    //   op: String.fromCharCode(op),\n    //   perm: '0o' + perm.toString(8),\n    // })\n  } // for each m in modifier\n  return mode\n}\n\n\ndeclare const DEBUG :boolean\n\n// lil' unit test for editFileMode\nif (DEBUG) {\n  const asserteq = require(\"assert\").strictEqual\n  const oct = (v :number) => \"0o\" + v.toString(8).padStart(3, '0')\n  //  input, modifiers, expected\n  const samples :\n    [ number, string[], number ][] = [\n    [ 0o444, [\"u+r\"],   0o444 ],\n    [ 0o444, [\"u+x\"],   0o544 ],\n    [ 0o444, [\"u+w\"],   0o644 ],\n    [ 0o444, [\"u+wx\"],  0o744 ],\n    [ 0o444, [\"u+rwx\"], 0o744 ],\n    [ 0o444, [\"u+r,u+w,u+x\"],    0o744 ],\n    [ 0o444, [\"u+r\", \"u+w,u+x\"], 0o744 ],\n    [ 0o444, [\"u+\"],    0o744 ], // no perm spec = all\n\n    [ 0o777, [\"u-r\"],   0o377 ],\n    [ 0o777, [\"u-wx\"],  0o477 ],\n    [ 0o777, [\"u-w\"],   0o577 ],\n    [ 0o777, [\"u-x\"],   0o677 ],\n    [ 0o777, [\"u-\"],    0o077 ],\n    [ 0o777, [\"u-rwx\"], 0o077 ],\n\n    [ 0o444, [\"g+r\"],   0o444 ],\n    [ 0o444, [\"g+x\"],   0o454 ],\n    [ 0o444, [\"g+w\"],   0o464 ],\n    [ 0o444, [\"g+wx\"],  0o474 ],\n    [ 0o444, [\"g+rwx\"], 0o474 ],\n    [ 0o444, [\"g+\"],    0o474 ],\n\n    [ 0o777, [\"g-r\"],   0o737 ],\n    [ 0o777, [\"g-wx\"],  0o747 ],\n    [ 0o777, [\"g-w\"],   0o757 ],\n    [ 0o777, [\"g-x\"],   0o767 ],\n    [ 0o777, [\"g-\"],    0o707 ],\n    [ 0o777, [\"g-rwx\"], 0o707 ],\n\n    [ 0o444, [\"o+r\"],   0o444 ],\n    [ 0o444, [\"o+x\"],   0o445 ],\n    [ 0o444, [\"o+w\"],   0o446 ],\n    [ 0o444, [\"o+wx\"],  0o447 ],\n    [ 0o444, [\"o+rwx\"], 0o447 ],\n    [ 0o444, [\"o+\"],    0o447 ],\n\n    [ 0o777, [\"o-r\"],   0o773 ],\n    [ 0o777, [\"o-wx\"],  0o774 ],\n    [ 0o777, [\"o-w\"],   0o775 ],\n    [ 0o777, [\"o-x\"],   0o776 ],\n    [ 0o777, [\"o-\"],    0o770 ],\n    [ 0o777, [\"o-rwx\"], 0o770 ],\n\n\n    [ 0o444, [\"ug+r\"],   0o444 ],\n    [ 0o444, [\"ug+x\"],   0o554 ],\n    [ 0o444, [\"ug+w\"],   0o664 ],\n    [ 0o444, [\"ug+wx\"],  0o774 ],\n    [ 0o444, [\"ug+rwx\"], 0o774 ],\n    [ 0o444, [\"ug+\"],    0o774 ],\n\n    [ 0o444, [\"ugo+r\"],   0o444 ],  [ 0o444, [\"a+r\"],   0o444 ],\n    [ 0o444, [\"ugo+x\"],   0o555 ],  [ 0o444, [\"a+x\"],   0o555 ],\n    [ 0o444, [\"ugo+w\"],   0o666 ],  [ 0o444, [\"a+w\"],   0o666 ],\n    [ 0o444, [\"ugo+wx\"],  0o777 ],  [ 0o444, [\"a+wx\"],  0o777 ],\n    [ 0o444, [\"ugo+rwx\"], 0o777 ],  [ 0o444, [\"a+rwx\"], 0o777 ],\n    [ 0o444, [\"ugo+\"],    0o777 ],  [ 0o444, [\"a+\"],    0o777 ],\n\n    [ 0o777, [\"ug-r\"],   0o337 ],\n    [ 0o777, [\"ug-wx\"],  0o447 ],\n    [ 0o777, [\"ug-w\"],   0o557 ],\n    [ 0o777, [\"ug-x\"],   0o667 ],\n    [ 0o777, [\"ug-\"],    0o007 ],\n    [ 0o777, [\"ug-rwx\"], 0o007 ],\n\n    [ 0o777, [\"ugo-r\"],   0o333 ],  [ 0o777, [\"a-r\"],   0o333 ],\n    [ 0o777, [\"ugo-wx\"],  0o444 ],  [ 0o777, [\"a-wx\"],  0o444 ],\n    [ 0o777, [\"ugo-w\"],   0o555 ],  [ 0o777, [\"a-w\"],   0o555 ],\n    [ 0o777, [\"ugo-x\"],   0o666 ],  [ 0o777, [\"a-x\"],   0o666 ],\n    [ 0o777, [\"ugo-\"],    0o000 ],  [ 0o777, [\"a-\"],    0o000 ],\n    [ 0o777, [\"ugo-rwx\"], 0o000 ],  [ 0o777, [\"a-rwx\"], 0o000 ],\n  ] // samples\n\n  samples.map(([input, mods, expect]) => {\n    let actual = editFileMode(input, mods)\n    asserteq(actual, expect,\n      `editFileMode(${oct(input)}, ${json(mods)}) => ` +\n      `${oct(actual)} != expected ${oct(expect)}`\n    )\n  })\n} // end of editFileMode tests\n", "// defined by esbuild, configured in build.js\ndeclare const DEBUG :boolean\ndeclare const VERSION :string\ndeclare function _runtimeRequire(id :string) :any\n\n// Mutable yields a derivative of T with readonly attributes erased\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n}\n\n// assert checks the condition for truth, and if false, prints an optional\n// message, stack trace and exits the process. assert is no-op in release builds.\nfunction assert(cond :any, msg? :string, cons? :Function) :void {\n  if (DEBUG) {\n    if (cond) {\n      return\n    }\n    const message = 'assertion failure: ' + (msg || cond)\n    const e = new Error(message)\n    e.name = \"AssertionError\"\n    const obj :any = {}\n    Error.captureStackTrace(obj, cons || assert)\n    if (obj.stack) {\n      e.stack = message + \"\\n\" + obj.stack.split(\"\\n\").slice(1).join(\"\\n\")\n    }\n    if (assert.throws) {\n      throw e\n    }\n    require(\"error\").printErrorAndExit(e, \"assert\")\n  }\n}\n\n// throws can be set to true to cause assertions to be thrown as exceptions instead\n// of printing the error and exiting the process.\nassert.throws = false\n\n;(global as any)[\"assert\"] = assert\n", "import { json } from \"./util\"\n\nconst memoizeMap = new Map()\n\nexport const isMemoized = Symbol(\"isMemoized\")\n\nexport function memoize(fn) {\n  return function memoizedCall(...args) {\n    let k = args.map(json).join(\"\\0\")\n    if (!memoizeMap.has(k)) {\n      const result = fn(...args)\n      memoizeMap.set(k, result)\n      return result\n    }\n    let v = memoizeMap.get(k)\n    if (v && typeof v == \"object\") {\n      v[isMemoized] = true\n    }\n    return v\n  }\n}\n", "const stdoutIsTTY = !!process.stdout.isTTY\n    , stderrIsTTY = !!process.stderr.isTTY\n\nexport const screen = {\n  width: 60,\n  height: 20,\n  clear() {},\n  banner(ch) {\n    if (!ch) { ch = \"-\" }\n    return ch.repeat(Math.floor((screen.width - 1) / ch.length))\n  },\n}\n\nif (stdoutIsTTY || stderrIsTTY) {\n  const ws = (stdoutIsTTY && process.stdout) || process.stderr\n  const updateScreenSize = () => {\n    screen.width = ws.columns\n    screen.height = ws.rows\n  }\n  ws.on(\"resize\", updateScreenSize)\n  updateScreenSize()\n  screen.clear = () => {\n    // Note: \\ec is reported to not work on the KDE console Konsole.\n    // TODO: detect KDE Konsole and use \\e[2J instead\n    // Clear display: \"\\x1bc\"\n    // Clear Screen: \\x1b[{n}J clears the screen\n    //   n=0 clears from cursor until end of screen\n    //   n=1 clears from cursor to beginning of screen\n    //   n=2 clears entire screen\n    ws.write(\"\\x1bc\")\n  }\n  // Note: we can clear past rows relatively using these two functions:\n  // ws.moveCursor(0, -4)\n  // ws.clearScreenDown()\n}\n", "import * as Path from \"path\"\nimport * as fs from \"fs\"\nimport { spawn } from \"child_process\"\n\nimport { json, jsonparseFile, findInPATH } from \"./util\"\nimport { stdoutStyle, stderrStyle } from \"./termstyle\"\nimport { screen } from \"./screen\"\nimport { findTSC, findTSConfigFile } from \"./tsutil\"\nimport { UserError } from \"./error\"\nimport log from \"./log\"\n\nconst { dirname, basename } = Path\n\n\n// defaultTSRules maps TS diagnostics codes to severity levels.\n// The special value IGNORE can be used to completely silence a diagnostic.\n// For diagnostic codes not listed, the default DiagnosticCategory for a\n// certain diagnostic is used.\nexport const defaultTSRules = {\n  6031: \"IGNORE\",  // starting compilation\n  6194: \"IGNORE\",  // Found N errors. Watching for file changes.\n  6133: \"WARNING\", // unused variable, parameter or import\n  2531: \"WARNING\", // Object is possibly 'null'\n  7006: \"WARNING\", // Parameter 'x' implicitly has an 'any' type.\n  7015: \"WARNING\", // Element implicitly has an 'any' type because index expression is not ...\n  7053: \"WARNING\", // Element implicitly has an 'any' type because expression of type can't be ...\n}\n\n\nconst IGNORE  = 0\n    , INFO    = 1\n    , WARNING = 2\n    , ERROR   = 3\n\n\nconst severities = {IGNORE,INFO,WARNING,ERROR}\n\n\nfunction addTSRules(dst, src) {\n  for (let k of Object.keys(src)) {\n    let v = severities[String(src[k]).toUpperCase()]\n    if (v === undefined) {\n      throw new UserError(\n        `Invalid value for TS rule ${k}: ${json(v)} -- expected value to be one of: `+\n        Object.keys(severities).map(json).join(\", \")\n      )\n    }\n    dst[k] = v\n  }\n}\n\n\n// returns a promise which resolves to a boolean \"no errors\", when the TSC process ends.\n// Note that in watch mode, the promise only resolves after explicitly calling cancel.\n// The returned promise is cancellable. I.e. p.cancel()\n//\nexport function tslint(options /*:TSLintOptions*/) {\n  if (!options) { options = {} }\n  let cancellation = {\n    cancelled: false,\n    cancel(){},\n  }\n  let p = new Promise((resolve, reject) => {\n\n  if (options.mode == \"off\") {\n    return resolve(true)\n  }\n\n  const cwd = options.cwd || process.cwd()\n\n  // find tsconfig.json file\n  let tsconfigFile = options.tsconfigFile\n  if (tsconfigFile === undefined) {\n    // Note: options.tsconfigFile=null|\"\" means \"explicitly no ts config file\"\n    tsconfigFile = findTSConfigFile(options.srcdir ? Path.resolve(cwd, options.srcdir) : cwd)\n  }\n  if (options.mode != \"on\" && !tsconfigFile) {\n    // no tsconfig file found -- in auto mode, we consider this \"not a TypeScript project\".\n    return resolve(true)\n  }\n\n  const options_format = options.format ? options.format.toLowerCase() : \"\"\n  const logShortInfo    = options_format.startsWith(\"short\")\n  const logShortWarning = options_format.startsWith(\"short\")\n  const logShortError   = options_format == \"short-all\"\n\n  // find tsc program\n  let tscprog = findTSC(options.cwd /* ok if undefined */)\n  if (tscprog == \"tsc\" && options.mode != \"on\") {\n    // look up tsc in PATH\n    if (!(tscprog = findInPATH(tscprog))) {\n      // we found a tsconfig.json file but not tsc\n      log.warn(\n        `tsc not found in node_modules or PATH. However a tsconfig.json file was found in ` +\n        Path.relative(process.cwd(), dirname(tsconfigFile)) + `.` +\n        ` Set tslint options.tslint=\"off\" or pass -no-diag on the command line to disable tsc.`\n      )\n      return resolve(true)\n    }\n  }\n\n  // rules\n  const tsrules = {}\n  addTSRules(tsrules, defaultTSRules)\n  if (options.rules) {\n    addTSRules(tsrules, options.rules)\n  }\n\n  // CLI arguments\n  let args = [\n    \"--noEmit\",\n    options.colors && \"--pretty\",\n    options.watch && \"--watch\",\n    tsconfigFile && \"--project\", tsconfigFile,\n  ].concat(options.args || []).filter(a => a)\n\n  log.debug(() => `spawning process ${tscprog} ${json(args,2)}`)\n\n  // spawn tsc process\n  const p = spawn(tscprog, args, {\n    stdio: ['inherit', 'pipe', 'inherit'],\n    cwd,\n  })\n\n  // kill process on exit to avoid EPIPE errors\n  const onProcessExitHandler = () => {\n    try { p.kill() } catch (_) {}\n  }\n  process.on('exit', onProcessExitHandler)\n\n  // cancellation handler\n  cancellation.cancel = () => {\n    // called just once (guarded by user cancel function)\n    p.kill()\n  }\n\n  const infoStyle  = s => s\n      , warnStyle  = stdoutStyle.orange\n      , errorStyle = stdoutStyle.red\n      , okStyle    = stdoutStyle.green\n\n  const _TS_buf = Buffer.from(\" TS\")\n  const Found__buf = Buffer.from(\"Found \")\n  const ANSI_clear_buf = Buffer.from(\"\\x1bc\")\n  const Starting_compilation_buf = Buffer.from(\"tarting compilation\")\n  const Starting_incremental_compilation_buf = Buffer.from(\"tarting incremental compilation\")\n\n  const tsmsgbuf = []\n  let tscode = 0\n  let lastRunHadErrors = false\n  let stats = {\n    errors: 0,\n    warnings: 0,\n    other: 0,\n    reset() {\n      this.errors = 0\n      this.warnings = 0\n      this.other = 0\n    },\n  }\n\n  let isIdle = false\n\n\n  function onSessionEnd() {\n    if (!options.quiet || stats.errors >= 0) {\n      options.watch && console.log(screen.banner(\"\u2014\"))\n      let summary = []\n      if (stats.errors > 0) {\n        summary.push(errorStyle(\"TS: \" + plural(`$ error`, `$ errors`, stats.errors)))\n      } else {\n        summary.push(okStyle(\"TS: OK\"))\n      }\n      if (stats.warnings > 0) {\n        summary.push(warnStyle(plural(`$ warning`, `$ warnings`, stats.warnings)))\n      }\n      if (stats.other > 0) {\n        summary.push(plural(`$ message`, `$ messages`, stats.other))\n      }\n      console.log(summary.join(\"   \"))\n      options.watch && console.log(screen.banner(\"\u2014\"))\n    }\n    lastRunHadErrors = stats.errors > 0\n    options.onEnd && options.onEnd(stats)\n    stats.reset()\n    isIdle = true\n  }\n\n\n  // called when tsmsgbuf contains one or more lines of one TypeScript message.\n  function flushTSMessage(compilationPassCompleted) {\n    // console.log(`------------------- TS${tscode} ------------------`)\n    // console.log({ tsmsgbuf: tsmsgbuf.map(b => b.toString(\"utf8\")) })\n\n    // reset buffer\n    let lines = tsmsgbuf.slice()\n    tsmsgbuf.length = 0\n\n    if (tscode == 0) {\n\n      // pick the first non-empty line\n      let i = 0\n      let line0 = lines[i++]\n      while (line0.length == 0 || line0[0] == 0x0A && i < lines.length) {\n        line0 = lines[i++]\n      }\n\n      // check if the line is the \"starting\" message\n      if (line0.includes(Starting_compilation_buf) ||\n          line0.includes(Starting_incremental_compilation_buf)\n      ) {\n        stats.reset()\n        // ignore \"Starting compilation [in watch mode...]\" message\n        // alt spelling in more recent typescript versions:\n        //   \"Starting incremental compilation...\"\n        return compilationPassCompleted && onSessionEnd()\n      }\n\n      if (lines.every(line => line.length <= 1)) {\n        // ignore empty message\n        return compilationPassCompleted && onSessionEnd()\n      }\n    } else {\n      const errorRe = /(?:\\x1b\\[\\d+m|)error(?:\\x1b\\[\\d+m|)/g\n      let line0 = lines.shift().toString(\"utf8\")\n      // console.log(\"TSLINT\", {line0, tscode, sev: tsrules[tscode]})\n\n      switch (tsrules[tscode]) {\n        case IGNORE: return compilationPassCompleted && onSessionEnd()\n\n        case INFO:\n          // rewrite potentially ANSI-colored first line \"error\"\n          line0 = line0.replace(errorRe, infoStyle(\"info\"))\n          if (logShortInfo) {\n            lines = []\n          } else {\n            restyleSrcLineWaves(lines, infoStyle)\n          }\n          stats.other++\n          break\n\n        case WARNING:\n          // rewrite potentially ANSI-colored first line \"error\"\n          line0 = line0.replace(errorRe, warnStyle(\"warning\"))\n          if (logShortWarning) {\n            lines = []\n          } else {\n            restyleSrcLineWaves(lines, warnStyle)\n          }\n          stats.warnings++\n          break\n\n        default: // ERROR or other\n          if (logShortError) {\n            lines = []\n          }\n          if (errorRe.test(line0)) {\n            stats.errors++\n          } else {\n            stats.other++\n          }\n          break\n      }\n      process.stdout.write(line0)\n    }\n\n    // write lines to stdout\n    lines.forEach(v => process.stdout.write(v))\n\n    compilationPassCompleted && onSessionEnd()\n  }\n\n\n  function restyleSrcLineWaves(lines, stylefn) {\n    for (let i = 1; i < lines.length; i++) {\n      let line = lines[i]\n      if (line.includes(0x7e)) { // ~\n        let s = line.toString(\"utf8\") // \"\\x1b[91m\"\n        s = s.replace(/\\x1b\\[\\d+m(\\s*~+)/g, stylefn(\"$1\"))\n        lines[i] = s  // ok to set string instead of Buffer\n      }\n    }\n  }\n\n\n  function plural(singular, plural, n) {\n    return (n == 1 ? singular : plural).replace(/\\$/g, n)\n  }\n\n  lineReader(p.stdout, (line, flush) => {\n    if (!options.clearScreen) {\n      line = stripANSIClearCode(line)\n    }\n    if (flush) {\n      if (line.length > 0) {\n        tsmsgbuf.push(line)\n      }\n      if (tsmsgbuf.length > 0) {\n        flushTSMessage()\n      }\n      return\n    }\n\n    if (isIdle && line.length > 1) {\n      // first non-empty line after isIdle state has been entered marks the start of\n      // a new session.\n      isIdle = false\n      options.onRestart && options.onRestart()\n    }\n\n    if (line.includes(Found__buf)) {\n      let s = stripANSICodesStr(line.toString(\"utf8\"))\n      if (/^(?:\\[[^\\]]+\\] |[\\d\\:PAM \\-]+|)Found \\d+ error/.test(s)) {\n        // TypeScript has completed a compilation pass\n        flushTSMessage(true)\n        tscode = 0\n        return // don't add this line to line buffer\n      } else {\n        flushTSMessage(false)\n      }\n      tscode = 0\n    } else {\n      // console.log(\"--> \" + line.subarray(0, line.length-1).toString(\"utf8\"))\n      if (line.includes(_TS_buf)) {\n        const s = line.toString(\"utf8\")\n        const m = /(?:\\x1b\\[\\d+m|)error(?:\\x1b\\[\\d+m\\x1b\\[\\d+m|) TS(\\d+)\\:/.exec(s)\n        // const m = /(?:\\x1b\\[\\d+m|)error(?:\\x1b\\[\\d+m|) TS(\\d+)\\:/.exec(s)\n        let tscode2 = m ? parseInt(m[1]) : 0\n        if (tscode2 > 0 && !isNaN(tscode2)) {\n          if (tsmsgbuf.length > 0) {\n            flushTSMessage()\n          }\n          tscode = tscode2\n        }\n      }\n    }\n    tsmsgbuf.push(line)\n  })\n\n  // lineReader(p.stderr, line => {\n  //   process.stderr.write(line)\n  // })\n\n  p.on('close', code => {\n    // console.log(`tsc exited with code ${code}`)\n    process.removeListener('exit', onProcessExitHandler)\n    resolve(!lastRunHadErrors)\n  })\n\n  function stripANSICodesStr(s) {\n    return s.replace(/\\x1b\\[\\d+m/g, \"\")\n  }\n\n  function stripANSIClearCode(buf) {\n    // strip \"clear\" ANSI code is present in buf\n    let i = buf.indexOf(ANSI_clear_buf)\n    return (\n      i == -1 ? buf :\n      i == 0 ? buf.subarray(3) :\n      Buffer.concat([buf.subarray(0,i), buf.subarray(i+3)], buf.length - 3)\n    )\n  }\n  }) // Promise\n  p.cancel = () => {\n    if (!cancellation.cancelled) {\n      cancellation.cancelled = true\n      cancellation.cancel()\n    }\n    return p\n  }\n  return p\n} // end function tslint\n\nconst emptyBuffer = Buffer.allocUnsafe(0)\n\n// TODO replace this with io.readlines\nfunction lineReader(r, onLine) {\n  let bufs = [], bufz = 0\n  const readbuf = data => {\n    let offs = 0\n    while (true) {\n      let i = data.indexOf(0x0A, offs)\n      if (i == -1) {\n        if (offs < data.length - 1) {\n          const chunk = data.subarray(offs)\n          bufs.push(chunk)\n          bufz += chunk.length\n        }\n        break\n      }\n      i++\n      let buf = data.subarray(offs, i)\n      if (bufz > 0) {\n        buf = Buffer.concat(bufs.concat(buf), bufz + buf.length)\n        bufs.length = 0\n        bufz = 0\n      }\n      onLine(buf, false)\n      offs = i\n    }\n  }\n  const flush = () => {\n    if (bufs.length > 0) {\n      onLine(Buffer.concat(bufs, bufz), true)\n    } else {\n      onLine(emptyBuffer, true)\n    }\n  }\n\n  // TEST\n  // readbuf(Buffer.from(\"hello\"))\n  // readbuf(Buffer.from(\" world\\n\"))\n  // readbuf(Buffer.from(\"How\"))\n  // readbuf(Buffer.from(\"'s \"))\n  // readbuf(Buffer.from(\"it go\"))\n  // readbuf(Buffer.from(\"ing?\\n\"))\n  // readbuf(Buffer.from(\"quite well\\nI hope!\\nBye\\n\"))\n  // readbuf(Buffer.from(\"bye.\"))\n  // flush()\n  // lineReader(0, line => {\n  //   console.log({line:line.toString(\"utf8\")})\n  // })\n\n  r.on(\"data\", readbuf)\n  r.on(\"close\", flush)\n  r.on(\"end\", flush)\n}\n", "import * as Path from \"path\"\nimport * as fs from \"fs\"\nimport { CompilerOptions } from \"typescript\"\n\nimport { jsonparseFile, isWindows } from \"./util\"\nimport { BuildConfig as BuildConfigPub } from \"../estrella.d\"\nimport log from \"./log\"\n\nconst TS_CONFIG_FILE = Symbol(\"TS_CONFIG_FILE\")\nconst TS_CONFIG = Symbol(\"TS_CONFIG\")\n\ntype BuildConfig = BuildConfigPub & {\n  [TS_CONFIG]?      :CompilerOptions|null\n  [TS_CONFIG_FILE]? :string|null\n}\n\nconst { dirname, basename } = Path\n\n\nexport function findTSC(cwd :string) :string {\n  let npmPath = \"\"\n  let tmpcwd = process.cwd()\n  const exe = isWindows ? \"tsc.cmd\" : \"tsc\"\n  if (cwd) {\n    process.chdir(cwd)\n  }\n  try {\n    npmPath = require.resolve(\"typescript\")\n  } catch (_) {}\n  if (cwd) {\n    process.chdir(tmpcwd)\n  }\n  if (npmPath) {\n    const find = Path.sep + \"node_modules\" + Path.sep\n    let i = npmPath.indexOf(find)\n    if (i != -1) {\n      return Path.join(npmPath.substr(0, i + find.length - Path.sep.length), \".bin\", exe)\n    }\n  }\n  // not found in node_modules\n  return exe\n}\n\n\nexport function findTSConfigFile(dir :string, maxParentDir? :string) :string|null {\n  for (let path of searchTSConfigFile(dir, maxParentDir)) {\n    try {\n      const st = fs.statSync(path)\n      if (st.isFile()) {\n        return path\n      }\n    } catch(_) {}\n  }\n  return null\n}\n\n\nexport function* searchTSConfigFile(dir :string, maxParentDir? :string) :Generator<string> {\n  // start at dir and search for dir + tsconfig.json,\n  // moving to the parent dir until found or until parent dir is the root dir.\n  // If maxParentDir is set, then stop when reaching directory maxParentDir.\n  dir = Path.resolve(dir)\n  const root = Path.parse(dir).root\n  maxParentDir = maxParentDir ? Path.resolve(maxParentDir) : root\n  while (true) {\n    yield Path.join(dir, \"tsconfig.json\")\n    if (dir == maxParentDir) {\n      // stop. this was the last dir we were asked to search\n      break\n    }\n    dir = dirname(dir)\n    if (dir == root) {\n      // don't search \"/\"\n      break\n    }\n  }\n}\n\n\nexport function tsConfigFileSearchDirForConfig(config :BuildConfig) :string {\n  let dir = config.cwd || process.cwd()\n  if (config.entryPoints && Object.keys(config.entryPoints).length > 0) {\n    // TODO: pick the most specific common denominator dir path of all entryPoints\n    let firstEntryPoint = \"\"\n    if (Array.isArray(config.entryPoints)) {\n      firstEntryPoint = config.entryPoints[0]\n    } else { // entryPoints is an object {outfile:infile}\n      for (let outfile of Object.keys(config.entryPoints)) {\n        firstEntryPoint = config.entryPoints[outfile]\n        break\n      }\n    }\n    dir = Path.resolve(dir, Path.dirname(firstEntryPoint))\n  }\n  return dir\n}\n\n\nexport function getTSConfigFileForConfig(config :BuildConfig) :string|null {\n  let file = config[TS_CONFIG_FILE]\n  if (file === undefined) {\n    if (\n      config.tslint === \"off\" || config.tslint === false ||\n      config.tsc === \"off\" || config.tsc === false\n    ) {\n      file = null\n    } else {\n      let dir = tsConfigFileSearchDirForConfig(config)\n      file = findTSConfigFile(dir, config.cwd)\n    }\n    Object.defineProperty(config, TS_CONFIG_FILE, { value: file })\n  }\n  return file\n}\n\n\nexport function getTSConfigForConfig(config :BuildConfig) :CompilerOptions|null {\n  let tsconfig = config[TS_CONFIG]\n  if (tsconfig === undefined) {\n    const file = getTSConfigFileForConfig(config)\n    if (file) try {\n      tsconfig = jsonparseFile(file)\n    } catch(err) {\n      log.warn(()=> `failed to parse ${file}: ${err.stack||err}`)\n    }\n    if (!tsconfig) {\n      tsconfig = null\n    }\n    Object.defineProperty(config, TS_CONFIG, { value: tsconfig })\n  }\n  return tsconfig\n}\n\n", "import * as filepath from \"path\"\nimport * as fs from \"fs\"\n\nimport { BuildResult } from \"../estrella\"\nimport { BuildConfig } from \"./config\"\nimport log from \"./log\"\nimport { repr } from \"./util\"\nimport { Cmd, startCmd } from \"./exec\"\nimport { stdoutStyle } from \"./termstyle\"\nimport * as io from \"./io\"\nimport * as signal from \"./signal\"\nimport { UserError } from \"./error\"\n\n\nlet _initialized = false\nlet _deinitialized = false\nlet _runContexts = new Set<RunContext>()\n\n\nfunction init() {\n  if (_initialized) { return }\n  _initialized = true\n  process.on(\"beforeExit\", exitCode      => atexit(DEBUG && `process.on beforeExit ${exitCode}`))\n  process.on(\"exit\",       exitCode      => atexit(DEBUG && `process.on exit ${exitCode}`))\n  const onsignal = (sig: NodeJS.Signals) => atexit(DEBUG && `process.on signal ${sig}`)\n  signal.addListener(\"SIGINT\", onsignal)\n  signal.addListener(\"SIGHUP\", onsignal)\n  signal.addListener(\"SIGTERM\", onsignal)\n  signal.addListener(\"SIGPIPE\", onsignal)\n}\n\n\nfunction atexit(cause :string|false) {\n  if (_deinitialized) { return }\n  _deinitialized = true\n\n  // any log messages must be sync since process is about to terminate\n  const logerr = (msg :string) => fs.writeSync((process.stderr as any).fd, msg + \"\\n\")\n\n  try {\n    // log in debug mode\n    if (DEBUG) {\n      let runningCount = 0\n      for (let ctx of _runContexts) {\n        if (ctx.cmd.running) {\n          runningCount++\n        }\n      }\n      if (runningCount > 0) {\n        logerr(`[DEBUG run.atexit] run.atexit (${cause})`)\n      }\n    }\n\n    // Send SIGTERM to any running processes.\n    // It's better to send SIGTERM than SIGKILL in this case since in almost all scenarios\n    // processes are well-behaved and won't ignore SIGTERM (forever.) On the flipside, sending\n    // SIGKILL may cause some processes to miss out on important atexit code\n    for (let ctx of _runContexts) {\n      if (ctx.cmd.running) {\n        DEBUG && logerr(`[DEBUG run.atexit] sending SIGTERM to ${ctx.cmd}`)\n        try {\n          ctx.cmd.signal(\"SIGTERM\")\n        } catch(_) {}\n      }\n    }\n\n    _runContexts.clear()\n  } catch (err) {\n    logerr(`ignoring error in run.atexit: ${err.stack||err}`)\n  }\n}\n\n\n// run.configure is called by build1 with a mutable copy of config.\n// If config.run is not falsy, this function sets up onStart and onEnd handlers on config\n// to manage execution of the build product.\nexport function configure(config :BuildConfig) {\n  if (!config.run) {\n    return\n  }\n\n  log.debug(()=> `run.configure run=${repr(config.run)}`)\n\n  const ctx = new RunContext(config)\n  _runContexts.add(ctx)\n\n  // const onStartNext = config.onStart\n  // config.onStart = async (config, changedFiles, bctx) => {\n  //   if (typeof onStartNext == \"function\") {\n  //     await onStartNext(config, changedFiles, bctx)\n  //   }\n  //   return ctx.onStartBuild(changedFiles)\n  // }\n\n  const onEndNext = config.onEnd\n  config.onEnd = async (config, buildResult, bctx) => {\n    // make sure we run user's onEnd function before we spawn a process\n    let returnValue = undefined\n    if (typeof onEndNext == \"function\") {\n      returnValue = onEndNext(config, buildResult, bctx)\n      if (returnValue instanceof Promise) {\n        returnValue = await returnValue\n      }\n    }\n    await ctx.onEndBuild(buildResult)\n    return returnValue\n  }\n\n  init()\n}\n\n\n// waitAll waits for all running commands to exit.\n// Returns the largest exit code (i.e. 0 if all processes exited cleanly.)\nexport function waitAll() :Promise<number> {\n  return Promise.all(\n    Array.from(_runContexts).map(ctx => ctx.cmd.promise)\n  ).then(exitCodes => exitCodes.reduce((a,c) => Math.max(a,c), 0))\n}\n\n\nclass RunContext {\n  readonly config  :Readonly<BuildConfig>\n  readonly cmd     :Cmd\n  readonly cmdname :string  // shown in logs\n\n  _logOnExit = true // state used by onEndBuild to decide if exit is logged or not\n\n  constructor(config :Readonly<BuildConfig>) {\n    this.config = config\n\n    // Create a command object with stdout and stderr forwarding (/dev/null for stdin)\n    this.cmd = new Cmd(\"\")\n    this.cmd.stdout = \"inherit\"\n    this.cmd.stderr = \"inherit\"\n    this.cmd.env[\"ESTRELLA_PATH\"] = __filename\n    this.cmd.env[\"ESTRELLA_VERSION\"] = VERSION\n\n    if (typeof config.run == \"string\") {\n      this.cmd.command = config.run\n      this.cmd.shell = true\n      this.cmdname = config.run\n\n    } else if (typeof config.run == \"boolean\") {\n      if (!config.outfile) {\n        throw new UserError(`please set config.outfile=<file> or config.run=<file>`)\n      }\n      this.cmd.command = process.execPath // node\n      this.cmd.args = [ config.outfileAbs ]\n      this.cmdname = config.outfile\n\n    } else {\n      if (!config.run || config.run.length == 0) {\n        throw new UserError(\"config.run is an empty list\")\n      }\n      this.cmd.command = config.run[0]\n      this.cmd.args = config.run.slice(1)\n      this.cmdname = config.run.join(\" \")\n      if (this.cmdname.length > 60) {\n        this.cmdname = this.cmdname.substr(0,57) + \"...\"\n      }\n    }\n  }\n\n  async onEndBuild(buildResult :BuildResult) {\n    if (buildResult.errors.length > 0) {\n      // don't start or restart a process if the build failed\n      return\n    }\n\n    // okay, let's start or restart this.cmd\n    const cmd = this.cmd\n    const style = stdoutStyle.pink\n\n    // if the program is still running, stop it first\n    const restart = cmd.running\n    if (cmd.running) {\n      this._logOnExit = false\n      log.debug(() => `Stopping ${this.cmdname} [${cmd.pid}] ...`)\n      await cmd.kill()\n    }\n\n    // start new process\n    log.debug(() => `Starting command ${repr([cmd.command, ...cmd.args])}`)\n    cmd.start()\n\n    // log info about the process starting and existing in watch mode\n    if (this.config.watch) {\n      log.info(() => style(`${restart ? \"Restarted\" : \"Running\"} ${this.cmdname} [${cmd.pid}]`))\n      this._logOnExit = true\n      cmd.promise.then(exitCode => {\n        this._logOnExit && log.info(() => style(`${this.cmdname} exited (${exitCode})`))\n      })\n    }\n  }\n}\n\n", "/*\nThis module is an adoptation of Go's simple and elegant os/exec.Cmd package.\nIt provides a reliable and simple way to run sub-processes.\n\nThe API and semantics prioritize clarity & simplicity over ease.\nThere are two important members:\n\nclass Cmd(command :string, ...args :string[]) implements CmdOptions\n  Create a new command structure for running a sub-process\n\nfunction startCmd(command :string, args? :string[], options? :CmdOptions)\n  Create & start a command. Thin wrapper around new Cmd... with strong TypeScript typings.\n\n----------------------------------------------------------------------------------------------\nstartCmd examples\n\nExample: Pipe one command's output into another's input:\n  const [,{stdout:dateout}] = startCmd(\"date\", [], {stdout:\"pipe\"})\n  const [cmd, stdio] = startCmd(\"cat\", [], { stdin: dateout, stdout: \"inherit\" })\n  await cmd.wait()\n\n----------------------------------------------------------------------------------------------\nCmd examples\n\nExample: Print output of top to stdout\n  const cmd = new Cmd(\"top\")\n  cmd.stdout = process.stdout\n  await cmd.run()\n\nExample: Get output of uname -a\n  console.log(await (new Cmd(\"uname\", \"-a\")).output(\"utf8\"))\n\nExample: Provide a buffer for stdin and capture stdout as text\n  const cmd = new Cmd(\"tr\", \"[:lower:]\", \"[:upper:]\")\n  cmd.stdin = Buffer.from(\"Hello world\\n\")\n  console.log(await cmd.output(\"utf8\"))\n\nExample: Provide a file for stdin and catpure stdout as text\n  const cmd = new Cmd(\"tr\", \"[:upper:]\", \"[:lower:]\")\n  cmd.stdin = io.createFileReader(\"jokes.txt\")\n  console.log(await cmd.output(\"utf8\"))\n\nExample: Execute a command in a shell, listing the contents of a directory\n  const cmd = new Cmd(\"if [ -d . ]; then ls; fi\")\n  cmd.shell = true\n  cmd.dir = \"~\"\n  console.log(await cmd.output(\"utf8\"))\n\nExample: Pipe one command's output into another's input\n  const date = new Cmd(\"date\")\n  date.stdout = \"pipe\"\n  const { stdout: dateout } = date.start()\n  const cmd = new Cmd(\"cat\")\n  cmd.stdin = dateout\n  cmd.stdout = process.stdout\n  await cmd.run()\n\n*/\nimport * as fs from \"fs\"\nimport * as os from \"os\"\nimport * as subproc from \"child_process\"\nimport { Writable, Readable, PassThrough as PassThroughStream } from \"stream\"\n\nimport * as io from \"./io\"\nimport { createTimeout } from \"./timeout\"\nimport { repr, expandTildePath, isWindows } from \"./util\"\nimport log from \"./log\"\n\nexport interface Pipes<In=io.Writer|null, Out=io.Reader|null, Err=io.Reader|null> {\n  readonly stdin      :In   // valid if Cmd.stdin==\"pipe\"\n  readonly stdout     :Out  // valid if Cmd.stdout==\"pipe\"\n  readonly stderr     :Err  // valid if Cmd.stderr==\"pipe\"\n  readonly extraFiles :(io.Reader|io.Writer|null)[]  // where extraFiles[N]==\"pipe\"\n}\n\ninterface CmdOptions {\n  dir?         :string  // working directory. If empty, uses current working directory\n  env?         :{[name:string]:string|undefined}  // process environment\n  shell?       :boolean | string  // run command in the system-default shell\n  stdin?       :Readable | \"inherit\" | \"pipe\" | Buffer | io.Reader | null // fd 0\n  stdout?      :Writable | \"inherit\" | \"pipe\" | null // fd 1\n  stderr?      :Writable | \"inherit\" | \"pipe\" | null // fd 2\n  extraFiles?  :(Readable | \"pipe\" | null)[]  // fd 3...\n  windowsHide? :boolean\n}\n\n// startCmd launches an external command process.\n// It's a convenience function around c=new Cmd();c.start() with strengthened TypeScript types.\n//\n// Form 1/2a: When no stdio options are provided, no pipes are returned\nexport function startCmd(command :string, args? :string[]) :[Cmd]\nexport function startCmd(command :string, args :string[], options :CmdOptions & {\n  stdin?: never,\n  stdout?: never,\n  stderr?: never,\n  extraFiles? :never,\n}) :[Cmd]\n//\n// Form 1/2b: no args\nexport function startCmd(command :string, options :CmdOptions & {\n  stdin?: never,\n  stdout?: never,\n  stderr?: never,\n  extraFiles? :never,\n}) :[Cmd]\n//\n// Form 2/2a: When stdio options are provided, the pipe ends and cmd are returned as a tuple:\nexport function startCmd<\n  // at least one stdio input is defined\n  Options extends CmdOptions & (\n    { stdin:  CmdOptions[\"stdin\"] } |\n    { stdout: CmdOptions[\"stdout\"] } |\n    { stderr: CmdOptions[\"stderr\"] } |\n    { extraFiles: CmdOptions[\"extraFiles\"] }\n  ),\n  I = Options extends {stdin: \"pipe\"} ? io.Writer : null,\n  O = Options extends {stdout:\"pipe\"} ? io.Reader : null,\n  E = Options extends {stderr:\"pipe\"} ? io.Reader : null,\n>(\n  command :string,\n  args    :string[],\n  options :Options,\n) :[Cmd, Pipes<I,O,E>]\n//\n// Form 2/2b: no args\nexport function startCmd<\n  // at least one stdio input is defined\n  Options extends CmdOptions & (\n    { stdin:  CmdOptions[\"stdin\"] } |\n    { stdout: CmdOptions[\"stdout\"] } |\n    { stderr: CmdOptions[\"stderr\"] } |\n    { extraFiles: CmdOptions[\"extraFiles\"] }\n  ),\n  I = Options extends {stdin: \"pipe\"} ? io.Writer : null,\n  O = Options extends {stdout:\"pipe\"} ? io.Reader : null,\n  E = Options extends {stderr:\"pipe\"} ? io.Reader : null,\n>(\n  command :string,\n  options :Options,\n) :[Cmd, Pipes<I,O,E>]\n//\n// Implementation:\nexport function startCmd(command :string, args? :string[]|CmdOptions, options? :CmdOptions) {\n  if (!args || !Array.isArray(args)) {\n    if (args && typeof args == \"object\") {\n      options = args as CmdOptions\n    }\n    args = []\n  }\n  if (!options) {\n    options = {}\n  }\n  const cmd = new Cmd(command, ...args)\n  for (let k in options) {\n    ;(cmd as any)[k] = (options as any)[k]\n  }\n  const cmdio = cmd.start()\n  if (options && (\n    \"stdin\" in options ||\n    \"stdout\" in options ||\n    \"stderr\" in options ||\n    \"extraFiles\" in options\n  )) {\n    return [ cmd, cmdio ]\n  }\n  return cmd\n}\n\n\nconst notStartedError = \"process not started\"\n\nexport type SignalMode = \"standard\" | \"group\"\n\n\n// Cmd represents an external command being prepared or run\nexport class Cmd implements Required<CmdOptions> {\n  command     :string\n  args        :string[]\n  dir         :string = \"\"  // working directory. If empty, uses current working directory\n  env         :{[name:string]:string|undefined} = {...process.env}  // process environment\n  shell       :boolean | string = false  // run command in the system-default shell\n  stdin       :Readable | \"inherit\" | \"pipe\" | Buffer | io.Reader | null = null // fd 0\n  stdout      :Writable | \"inherit\" | \"pipe\" | null = null // fd 1\n  stderr      :Writable | \"inherit\" | \"pipe\" | null = null // fd 2\n  extraFiles  :(Readable | \"pipe\" | null)[] = []  // fd 3...\n  windowsHide :boolean = true\n\n  readonly process  :subproc.ChildProcess | null = null  // underlying process\n  readonly promise  :Promise<number>  // resolves with status code when process exits\n  readonly running  :boolean = false  // true while the underlying process is running\n  readonly pid      :number = 0       // pid, valid after start() has been called\n  readonly exitCode :number = -1\n    // exit code of the exited process, or -1 if the process hasn't exited or was\n    // terminated by a signal.\n\n  constructor(command :string, ...args :string[]) {\n    this.command = command\n    this.args = args\n    this.promise = Promise.reject(new Error(notStartedError))\n    this.promise.catch(_=>{}) // avoid uncaught promise\n  }\n\n  // start launches the command process.\n  // If the process fails to launch, this function throws an error.\n  // Returns caller's end of I/O pipes. Returns null if no stdio pipes were configured.\n  // See startCmd() function as an alternative with stronger TypeScript typings.\n  start() :Pipes|null { return null } // separate impl\n\n  // run starts the specified command and waits for it to complete.\n  // Returns process exit status code.\n  run(timeout? :number) :Promise<number> {\n    this.start()\n    return this.wait(timeout)\n  }\n\n  // output runs the specified command and returns its standard output.\n  // If the program does not exit with status 0, an error is thrown.\n  output(encoding :null|undefined, timeout? :number|null) :Promise<Buffer>\n  output(encoding :BufferEncoding, timeout? :number|null) :Promise<string>\n  output(encoding? :BufferEncoding|null, timeout? :number|null) :Promise<Buffer|string> {\n    this.stdout = \"pipe\"\n    if (!this.stderr) {\n      this.stderr = \"pipe\"\n    }\n\n    const { stdout, stderr } = this.start()!\n    const stdoutBuf = io.createWriteBuffer()\n    const stderrBuf = io.createWriteBuffer()\n\n    stdout!.stream.on(\"data\", chunk => {\n      stdoutBuf.push(chunk)\n    })\n\n    if (stderr) {\n      stderr.stream.on(\"data\", chunk => {\n        stderrBuf.push(chunk)\n      })\n    }\n\n    return this.wait(timeout as number || 0).then(exitCode => {\n      if (exitCode != 0) {\n        let errstr = \"\"\n        const errbuf = stderrBuf.buffer()\n        try {\n          errstr = errbuf.toString(\"utf8\")\n        } catch (_) {\n          errstr = errbuf.toString(\"ascii\")\n        }\n        if (errstr.length > 0) {\n          errstr = \". stderr output:\\n\" + errstr\n        }\n        throw new Error(`command exited with status ${exitCode}${errstr}`)\n      }\n      const buf = stdoutBuf.buffer()\n      return encoding ? buf.toString(encoding) : buf\n    })\n  }\n\n  // wait for process to exit, with an optional timeout expressed in milliseconds.\n  // Returns the exit status. Throws TIMEOUT on timeout.\n  wait(timeout? :number, timeoutSignal? :Signal) :Promise<number> {\n    if (timeout === undefined || timeout <= 0) {\n      return this.promise\n    }\n    return this._waitTimeout(timeout, (err, _resolve, reject) => {\n      log.debug(()=>`${this} wait timeout reached; killing process`)\n      err.message = \"Cmd.wait timeout\"\n      return this.kill(timeoutSignal).then(() => reject(err))\n    })\n  }\n\n  // signal sends sig to the underlying process and returns true if sending the signal worked.\n  // mode defaults to \"standard\"\n  //\n  // If the signal is successfully sent (not neccessarily delivered) true is returned.\n  // If the process is not running, false is returned (no effect.)\n  // If the process has not been started, an exception is thrown.\n  // If the signal is not supported by the platform, an exception is thrown.\n  // If another error occur, like signalling permissions, false is returned.\n  //\n  signal(sig :Signal, mode? :SignalMode) :boolean {\n    const p = this._checkproc()\n    if (mode == \"group\") {\n      // Signalling process groups via negative pid is supported on most POSIX systems.\n      // This causes subprocesses that the command process may have started to also receive\n      // the signal.\n      try {\n        process.kill(-p.pid, sig)\n        return true\n      } catch (_) {\n        // will fail if the process is not in its own group or if its is already dead.\n        // fall through to \"proc\" mode:\n      }\n    }\n    return p.kill(sig)\n  }\n\n  // kill terminates the command by sending signal sig to the process and waiting for it to exit.\n  // mode defaults to \"group\".\n  //\n  // If the process has not exited within timeout milliseconds, SIGKILL is sent.\n  // The timeout should be reasonably large to allow well-behaved processed to run atexit code but\n  // small enough so that an ill-behaved process is killed within a reasonable timeframe.\n  // If timeout <= 0 then the returned promise will only resolve if and when the process exits,\n  // which could be never if the process ignores sig.\n  //\n  async kill(sig :Signal=\"SIGTERM\", timeout :number=500, mode? :SignalMode) :Promise<number> {\n    const p = this._checkproc()\n    if (!this.signal(sig, mode || \"group\")) {\n      return p.exitCode || 0\n    }\n    if (timeout <= 0) {\n      return this.promise\n    }\n    return this._waitTimeout(timeout, (_, resolve) => {\n      log.debug(()=>`${this} kill timeout reached; sending SIGKILL`)\n      p.kill(\"SIGKILL\")\n      return this.promise.then(resolve)\n    })\n  }\n\n  toString() :string {\n    return this.process ? `Cmd[${this.pid}]` : \"Cmd\"\n  }\n\n  // -------- internal --------\n\n  _resolve :(exitStatus:number)=>void = ()=>{}\n  _reject  :(reason?:any)=>void = ()=>{}\n\n  _checkproc() :subproc.ChildProcess {\n    if (!this.process) {\n      throw new Error(notStartedError)\n    }\n    return this.process\n  }\n\n  _rejectAndKill(reason? :any) {\n    this._reject(reason)\n  }\n\n  _onerror = (err :Error) => {\n    log.debug(()=>`${this} error:\\n${err.stack||err}`)\n    this._reject(err)\n  }\n\n  _onexit = (code: number, signal: NodeJS.Signals) => {\n    // run after process exits\n    const cmd = this as Mutable<Cmd>\n    log.debug(()=>`${cmd} exited status=${code} signal=${signal}`)\n    cmd.running = false\n    if (code === null || signal !== null) {\n      assert(typeof signal == \"string\")\n      cmd.exitCode = -(os.constants.signals[signal] || 1)\n    } else {\n      cmd.exitCode = code || 0\n    }\n    cmd._resolve(cmd.exitCode)\n  }\n\n  // _waitTimeout starts a timer which is cancelled when the process exits.\n  // If the timer expires before the process exits, onTimeout is called with a mutable\n  // TimeoutError that you can pass to reject and a set of promise resolution functions,\n  // which control the promise returned by this function.\n  _waitTimeout(\n    timeout :number,\n    onTimeout :(\n      timeoutErr :Error,\n      resolve: (code?:number)=>void,\n      reject:  (reason?:any)=>void,\n    )=>Promise<any>,\n  ) {\n    return new Promise<number>((resolve, reject) => {\n      let timeoutOccured = false\n      this.promise.then(exitCode => {\n        if (!timeoutOccured) {\n          resolve(exitCode)\n        }\n      })\n      return createTimeout(this.promise, timeout, timeoutErr => {\n        timeoutOccured = true\n        // now, even if the process exits and calls cmd._resolve, the timeout-enabled\n        // promise returned will not resolve. Instead, we call the onTimeout handler\n        // which can take its sweet time and eventually, when it's done, call either\n        // resolve or reject.\n        onTimeout(timeoutErr, resolve as (code?:number)=>void, reject)\n      })\n    })\n  }\n}\n\n\nCmd.prototype.start = function start(this :Cmd) :Pipes|null {\n  const cmd = this as Mutable<Cmd>\n\n  if (cmd.running) {\n    throw new Error(\"start() called while command is running\")\n  }\n\n  // reset exit code\n  cmd.exitCode = -1\n\n  // create a new promise\n  cmd.promise = new Promise<number>((res,rej) => {\n    cmd._resolve = res\n    cmd._reject = rej\n  })\n\n  // configure stdin which may be a buffer\n  let stdin :Readable | \"inherit\" | \"pipe\" | null = null\n  let stdinStreamNeedsPiping :Readable | null = null\n  if (cmd.stdin instanceof Buffer) {\n    stdin = \"pipe\"\n  } else if (io.isReader(cmd.stdin)) {\n    if (typeof (cmd.stdin.stream as any).fd == \"string\") {\n      // Nodejs' child_process module can handle \"Socket\" type of streams directly.\n      // \"Socket\" really is just the name for a stream around a file descriptor.\n      stdin = cmd.stdin.stream\n    } else {\n      stdin = \"pipe\"\n      stdinStreamNeedsPiping = cmd.stdin.stream\n    }\n  } else {\n    stdin = cmd.stdin\n  }\n\n  // spawn a process\n  const spawnOptions :subproc.SpawnOptions = {\n    stdio: [\n      stdin || 'ignore',\n      (\n        cmd.stdout === process.stdout ? 1 :\n        cmd.stdout || 'ignore'\n      ),\n      (\n        cmd.stderr === process.stderr ? 2 :\n        cmd.stderr ? cmd.stderr : 'ignore'\n      ),\n      ...cmd.extraFiles\n    ],\n    cwd: cmd.dir ? expandTildePath(cmd.dir) : undefined,\n    env: cmd.env,\n    shell: cmd.shell,\n    windowsHide: cmd.windowsHide,\n\n    // On non-windows platforms, set detached so that p gets its own process group, allowing us to\n    // signal its process tree.\n    // Note that this option has a different meaning on Windows and screws with stdio inheritance.\n    detached: !isWindows,\n  }\n  // log.debug(()=> `exec spawn ${repr(cmd.command)}, ${repr(cmd.args)} ${repr(spawnOptions)}`)\n  const p = subproc.spawn(cmd.command, cmd.args, spawnOptions)\n\n  // This is a bit of a hack, working around an awkward design choice in nodejs' child_process\n  // module where spawn errors are deliberately delayed until the next runloop iteration.\n  // The effect of this choice means that we don't know if creating a new process, which is a\n  // synchronous operation, succeeded until the next runloop frame.\n  // We have one thing going for us here: p.pid is undefined when spawn failed, so we can\n  // look at p.pid to know if there will be an error event in the next runoop frame or not, but\n  // we don't know anything about the error yet; not until the next runloop frame.\n  // See https://github.com/nodejs/node/blob/v14.12.0/lib/internal/child_process.js#L379-L390\n  if (p.pid === undefined) {\n    cmd.process = null\n    cmd.pid = 0\n    // guesstimate the actual error by checking status of command file\n    const err = guessSpawnError(cmd)\n    cmd._reject(err)\n    throw err\n  }\n\n  // set process & running state\n  cmd.running = true\n  cmd.process = p\n  cmd.pid = p.pid\n\n  // attach event listeners\n  p.on(\"exit\", cmd._onexit)\n  p.on('error', cmd._reject)\n\n  log.debug(()=>`${cmd} started (${repr(cmd.command)})`)\n\n  // stdin buffer?\n  if (p.stdin) {\n    if (cmd.stdin instanceof Buffer) {\n      const r = new PassThroughStream()\n      r.end(cmd.stdin)\n      r.pipe(p.stdin)\n      p.stdin = null\n    } else if (stdinStreamNeedsPiping) {\n      stdinStreamNeedsPiping.pipe(p.stdin)\n      p.stdin = null\n    }\n  }\n\n  // if there are no pipes, return no pipes\n  if (!p.stdin && !p.stdout && !p.stderr && p.stdio.length < 4) {\n    return null\n  }\n\n  // TODO figure out how to make this properly TypeScript typed.\n  // Ideally the return type of start() should depend on the values of Cmd.std{in,out,err}\n  // but I can't figure out how to do that with TypeScript, so here we are, casting null to\n  // a non-null type, asking for trouble. All for the sake of not having to do \"!\" for every\n  // call to stdio objects returned from start()...\n  const cmdio :Pipes = {\n    stdin:      p.stdin  ? io.createWriter(p.stdin)  : null,\n    stdout:     p.stdout ? io.createReader(p.stdout) : null,\n    stderr:     p.stderr ? io.createReader(p.stderr) : null,\n    extraFiles: p.stdio.slice(3).map(stream =>\n      io.isReadableStream(stream) ? io.createReader(stream) :\n      io.isWritableStream(stream) ? io.createWriter(stream) :\n      null\n    ),\n  }\n\n  return cmdio\n}\n\n\nfunction guessSpawnError(cmd :Cmd) :Error {\n  // guesstimate the actual error by checking status of command file\n  let code = \"\"\n  let msg = \"unspecified error\"\n  if (cmd.shell == false) {\n    try {\n      fs.accessSync(cmd.dir, fs.constants.R_OK | fs.constants.X_OK)\n      const st = fs.statSync(cmd.command)\n      if ((st.mode & fs.constants.S_IFREG) == 0) {\n        // not a regular file\n        code = \"EACCES\"\n      } else {\n        // very likely some sort of I/O error\n        code = \"EIO\"\n      }\n    } catch (err) {\n      code = err.code || \"ENOENT\"\n    }\n    msg = io.errorCodeMsg(code) || msg\n  }\n  if (!code) {\n    // check dir\n    try {\n      fs.accessSync(cmd.dir, fs.constants.R_OK | fs.constants.X_OK)\n      code = \"EIO\"\n    } catch (err) {\n      code = err.code || \"ENOENT\"\n    }\n    msg = io.errorCodeMsg(code) || msg\n    if (code) {\n      msg = msg + \"; cmd.dir=\" + repr(cmd.dir)\n    }\n  }\n  if (!code) {\n    code = \"UNKNOWN\"\n  }\n  const e = new Error(`failed to spawn process ${repr(cmd.command)} (${code} ${msg})`)\n  ;(e as any).code = code\n  return e\n}\n\n\nexport type Signal = NodeJS.Signals | number\n\n\n// this function is never used but here to test the complex typescript types of spawn()\nfunction _TEST_typescript_startCmd() {\n  {\n    const _empty1 :[Cmd] =\n      startCmd(\"a\", [])\n    const _empty2 :[Cmd] =\n      startCmd(\"a\", [], { dir: \"\" })\n\n    const ____  :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", [], { stdin:null, stdout:null, stderr:\"inherit\" })\n    const ____2 :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", [], { stdin:null, stdout:null, stderr:null })\n    const ____3 :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", [], { stdin:null })\n    const ____4 :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", [], { stdout:null })\n    const ____5 :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", [], { stderr:null })\n\n    const _extraFiles :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", [], { extraFiles:[] })\n\n    const _p__  :[Cmd,Pipes<io.Writer,null,null>] =\n      startCmd(\"a\", [], { stdin:\"pipe\", stdout:null, stderr:null })\n    const _p__2 :[Cmd,Pipes<io.Writer,null,null>] =\n      startCmd(\"a\", [], { stdin:\"pipe\" })\n\n    const _pp_  :[Cmd,Pipes<io.Writer,io.Reader,null>] =\n      startCmd(\"a\", [], { stdin:\"pipe\", stdout:\"pipe\", stderr:null })\n    const _pp_2 :[Cmd,Pipes<io.Writer,io.Reader,null>] =\n      startCmd(\"a\", [], { stdin:\"pipe\", stdout:\"pipe\" })\n\n    const _ppp  :[Cmd,Pipes<io.Writer,io.Reader,io.Reader>] =\n      startCmd(\"a\", [], { stdin:\"pipe\", stdout:\"pipe\", stderr:\"pipe\" })\n\n    const __pp  :[Cmd,Pipes<null,io.Reader,io.Reader>] =\n      startCmd(\"a\", [], { stdin:null, stdout:\"pipe\", stderr:\"pipe\" })\n    const __pp2 :[Cmd,Pipes<null,io.Reader,io.Reader>] =\n      startCmd(\"a\", [], { stdout:\"pipe\", stderr:\"pipe\" })\n\n    const _p_p  :[Cmd,Pipes<io.Writer,null,io.Reader>] =\n      startCmd(\"a\", [], { stdin:\"pipe\", stdout:null, stderr:\"pipe\" })\n    const _p_p2 :[Cmd,Pipes<io.Writer,null,io.Reader>] =\n      startCmd(\"a\", [], { stdin:\"pipe\",              stderr:\"pipe\" })\n\n    const ___p  :[Cmd,Pipes<null,null,io.Reader>] =\n      startCmd(\"a\", [], { stdin:null, stdout:null, stderr:\"pipe\" })\n    const ___p2 :[Cmd,Pipes<null,null,io.Reader>] =\n      startCmd(\"a\", [], { stderr:\"pipe\" })\n  }\n\n  // ---- copy of above, but args omitted ----\n  {\n    const _empty1 :[Cmd] =\n      startCmd(\"a\")\n    const _empty2 :[Cmd] =\n      startCmd(\"a\", { dir: \"\" })\n\n    const ____  :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", { stdin:null, stdout:null, stderr:\"inherit\" })\n    const ____2 :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", { stdin:null, stdout:null, stderr:null })\n    const ____3 :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", { stdin:null })\n    const ____4 :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", { stdout:null })\n    const ____5 :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", { stderr:null })\n\n    const _extraFiles :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", { extraFiles:[] })\n\n    const _p__  :[Cmd,Pipes<io.Writer,null,null>] =\n      startCmd(\"a\", { stdin:\"pipe\", stdout:null, stderr:null })\n    const _p__2 :[Cmd,Pipes<io.Writer,null,null>] =\n      startCmd(\"a\", { stdin:\"pipe\" })\n\n    const _pp_  :[Cmd,Pipes<io.Writer,io.Reader,null>] =\n      startCmd(\"a\", { stdin:\"pipe\", stdout:\"pipe\", stderr:null })\n    const _pp_2 :[Cmd,Pipes<io.Writer,io.Reader,null>] =\n      startCmd(\"a\", { stdin:\"pipe\", stdout:\"pipe\" })\n\n    const _ppp  :[Cmd,Pipes<io.Writer,io.Reader,io.Reader>] =\n      startCmd(\"a\", { stdin:\"pipe\", stdout:\"pipe\", stderr:\"pipe\" })\n\n    const __pp  :[Cmd,Pipes<null,io.Reader,io.Reader>] =\n      startCmd(\"a\", { stdin:null, stdout:\"pipe\", stderr:\"pipe\" })\n    const __pp2 :[Cmd,Pipes<null,io.Reader,io.Reader>] =\n      startCmd(\"a\", { stdout:\"pipe\", stderr:\"pipe\" })\n\n    const _p_p  :[Cmd,Pipes<io.Writer,null,io.Reader>] =\n      startCmd(\"a\", { stdin:\"pipe\", stdout:null, stderr:\"pipe\" })\n    const _p_p2 :[Cmd,Pipes<io.Writer,null,io.Reader>] =\n      startCmd(\"a\", { stdin:\"pipe\",              stderr:\"pipe\" })\n\n    const ___p  :[Cmd,Pipes<null,null,io.Reader>] =\n      startCmd(\"a\", { stdin:null, stdout:null, stderr:\"pipe\" })\n    const ___p2 :[Cmd,Pipes<null,null,io.Reader>] =\n      startCmd(\"a\", { stderr:\"pipe\" })\n  }\n\n}\n", "import { Writable, Readable } from \"stream\"\nimport * as fs from \"fs\"\n\nimport { TYPE } from \"./util\"\nimport * as extra from \"./extra\"\n\n\nexport function isReadableStream(s :Readable|Writable|null|undefined) :s is Readable {\n  return s && (s as any).read\n}\n\nexport function isWritableStream(s :Readable|Writable|null|undefined) :s is Writable {\n  return s && (s as any).write\n}\n\n\nexport interface Reader extends AsyncIterable<Buffer> {\n  // read data with optional size limit.\n  //\n  // size -- max number of bytes to read.\n  //   If size is not given or negative, read everything.\n  //   If size is given and the returned buffer's length is smaller than size, then\n  //   the stream has ended (EOF.)\n  //\n  // encoding -- how to decode the data into a string.\n  //   If provided, decode the read bytes as `encoding`.\n  //   Note that the size parameter always denotes bytes to read, not characters.\n  //\n  read(size? :number) :Promise<Buffer>\n  read(size :number|undefined|null, encoding :BufferEncoding) :Promise<string>\n  read(encoding :BufferEncoding) :Promise<string>\n\n  // read chunks as they arrive into the underlying buffer.\n  //\n  // Example:\n  //   for await (const chunk of r) {\n  //     console.log(chunk)  // Buffer<48 65 6c 6c 6f>\n  //   }\n  //\n  [Symbol.asyncIterator](): AsyncIterableIterator<Buffer>\n\n  // underlying nodejs stream object\n  readonly stream :Readable\n\n  readonly [TYPE] :\"Reader\"\n}\n\nexport interface Writer {\n  readonly stream :Writable\n  readonly [TYPE] :\"Writer\"\n}\n\nexport const emptyBuffer = Buffer.allocUnsafe(0)\n\n\nexport function isReader(value :any) :value is Reader {\n  return value && typeof value == \"object\" && value[TYPE] == \"Reader\"\n}\n\nexport function isWriter(value :any) :value is Writer {\n  return value && typeof value == \"object\" && value[TYPE] == \"Writer\"\n}\n\nexport function createReader(stream? :Readable|null) :Reader {\n  return stream ? new StreamReader(stream) : InvalidReader\n}\n\nexport function createWriter(stream? :Writable|null) :Writer {\n  // TODO\n  return stream ? {\n    [TYPE]: \"Writer\",\n    stream,\n  } : InvalidWriter\n}\n\nexport function createFileReader(filename :string) :Reader {\n  return new FileReader(filename)\n}\n\n\nexport const InvalidReader = new class implements Reader {\n  readonly [TYPE] = \"Reader\"\n  _E() { return new Error(\"stream not readable\") }\n  get stream() :Readable { throw this._E() }\n  [Symbol.asyncIterator]() :AsyncIterableIterator<Buffer> { throw this._E() }\n  read() { return Promise.reject(this._E()) }\n}\n\nexport const InvalidWriter = new class implements Writer {\n  readonly [TYPE] = \"Writer\"\n  _E() { return new Error(\"stream not writable\") }\n  get stream() :Writable { throw this._E() }\n}\n\n// ------------------------------------------------------------------------------------\n// Reader\n\nexport class StreamReader implements Reader {\n  readonly [TYPE] = \"Reader\"\n  readonly stream :Readable\n\n  _ended = false\n\n  constructor(stream :Readable) {\n    this.stream = stream\n    stream.pause()  // makes it possible to use read()\n    stream.once(\"end\", () => {\n      this._ended = true\n    })\n  }\n\n  [Symbol.asyncIterator]() :AsyncIterableIterator<Buffer> {\n    return this.stream[Symbol.asyncIterator]()\n  }\n\n  async read(size? :number) :Promise<Buffer>\n  async read(size :number|undefined|null, encoding :BufferEncoding) :Promise<string>\n  async read(encoding :BufferEncoding) :Promise<string>\n  async read(size? :number|null|BufferEncoding, encoding? :BufferEncoding) :Promise<Buffer|string> {\n    const stream = this.stream\n\n    // stream must be paused in order to call stream.read()\n    stream.pause()\n\n    // stream.read(size) semantics:\n    //   if size is undefined:\n    //     return any data in the internal buffer\n    //     returns null if the internal buffer is empty\n    //   else\n    //     if size bytes are available\n    //       return buffer of that length\n    //     else if EOF\n    //       return whatever is in the internal buffer\n    //     else\n    //       return null\n    //\n\n    if (typeof size == \"string\") {\n      encoding = size\n      size = Number.MAX_SAFE_INTEGER\n    } else if (size === undefined || size === null || size < 0) {\n      size = Number.MAX_SAFE_INTEGER\n    } else if (size == 0) {\n      return encoding ? \"\" : emptyBuffer\n    }\n\n    if (stream.readable) {\n      // if we are lucky, the requested amount of data is already in the stream's buffer.\n      // in the case the stream ended, pass undefined for size which causes this call to return\n      // whatever remains in the buffer.\n      let buf = stream.read(this._ended ? undefined : size)\n      if (buf) {\n        return encoding ? buf.toString(encoding) : buf\n      }\n    }\n\n    // stream ended and there is nothing else to read.\n    // Return an empty buffer\n    if (this._ended) {\n      return encoding ? \"\" : emptyBuffer\n    }\n\n    // data not yet available\n    const buffers :Buffer[] = []\n    let buffersLen = 0  // accumulative length of `buffers`\n\n    if (stream.readable) {\n      const buf = stream.read() // read what is in the buffer\n      if (buf) {\n        buffers.push(buf)\n        buffersLen += buf.length\n      }\n    }\n\n    // console.log(\n    //   `READ 2 awaiting more data`+\n    //   ` (has ${buffersLen}, want ${size == Number.MAX_SAFE_INTEGER ? \"ALL\" : size} bytes)`)\n\n    while (buffersLen < size && !this._ended) {\n      await new Promise((resolve, reject) => {\n        stream.once('error', reject)\n        stream.once('end', resolve)\n        stream.once('readable', resolve)\n      })\n\n      // read no more than what we need\n      let buf = stream.read(size - buffersLen)\n      if (!buf) {\n        // if that fails it means that the stream's buffer is smaller.\n        // retrieve whatever is in the buffer\n        buf = stream.read()\n      }\n      if (buf) {\n        buffers.push(buf)\n        buffersLen += buf.length\n      }\n    }\n\n    const buf = joinbufs(buffers)\n\n    return encoding ? buf.toString(encoding) : buf\n  }\n}\n\n\nexport class FileReader extends StreamReader {\n  constructor(filename :string) {\n    super(fs.createReadStream(filename))\n  }\n}\n\n\nexport function joinbufs(bufs :Buffer[], totalLength? :number) :Buffer {\n  return (\n    bufs.length == 0 ? emptyBuffer :\n    bufs.length == 1 ? bufs[0] :\n    Buffer.concat(bufs, totalLength)\n  )\n}\n\n\nexport type WBuf = Buffer[] & _WBuf\ninterface _WBuf {\n  buffer() :Buffer // returns everything added so far as one contiguous byte array\n}\n\nexport function createWriteBuffer() :WBuf {\n  const w = [] as any as WBuf\n  let totalLength = 0\n  const push = w.push\n  w.push = (b :Buffer) => {\n    totalLength += b.length\n    return push.call(w, b)\n  }\n  w.buffer = () => {\n    return joinbufs(w, totalLength)\n  }\n  return w\n}\n\n// readlines yields line by line while reading from source\nexport function readlines(source :AsyncIterable<Buffer>) :AsyncGenerator<Buffer,void>\n//\nexport function readlines(\n  source :AsyncIterable<Buffer>,\n  encoding :BufferEncoding,\n) :AsyncGenerator<string,void>\n//\nexport async function* readlines(\n  source :AsyncIterable<Buffer>,\n  encoding? :BufferEncoding,\n) :AsyncGenerator<Buffer|string,void> {\n  let bufs :Buffer[] = []\n  let bufz = 0\n\n  for await (const data of source) {\n    let offs = 0\n    while (true) {\n      let i = data.indexOf(0x0A, offs)\n      if (i == -1) {\n        if (offs < data.length - 1) {\n          const chunk = data.subarray(offs)\n          bufs.push(chunk)\n          bufz += chunk.length\n        }\n        break\n      }\n      i++\n      let buf = data.subarray(offs, i)\n      if (bufz > 0) {\n        buf = Buffer.concat(bufs.concat(buf), bufz + buf.length)\n        bufs.length = 0\n        bufz = 0\n      }\n      yield encoding ? buf.toString(encoding) : buf\n      offs = i\n    }\n  }\n\n  if (bufs.length > 0) {\n    // last line does not end with a line break\n    const buf = Buffer.concat(bufs, bufz)\n    yield encoding ? buf.toString(encoding) : buf\n  }\n}\n\n\n\n// -------------------------------------------------------------------------------\n\ntype LibUVErrors = extra.DebugModule[\"libuv_errors\"]\n\nexport function errorCodeMsg(errorCode :string) :string {\n  const libuv_errors = extra.debug().libuv_errors\n  return libuv_errors[errorCode as keyof LibUVErrors] || \"\"\n}\n", "export function createTimeout<T>(\n  promise         :Promise<T>,\n  timeout         :number,\n  rejectOnTimeout :(e:Error)=>void,\n) :Promise<T> {\n  const timeoutTimer = setTimeout(() => {\n    const e = new Error(\"timeout\")\n    e.name = \"Timeout\"\n    rejectOnTimeout(e)\n  }, timeout)\n  return promise.then(r => {\n    clearTimeout(timeoutTimer)\n    return r\n  }, e => {\n    clearTimeout(timeoutTimer)\n    throw e\n  })\n}\n", "import * as fs from \"fs\"\nimport * as os from \"os\"\n\nexport type Signal = NodeJS.Signals\nexport type SignalsListener = NodeJS.SignalsListener\n\n\ninterface ListenerEntry {\n  listeners :Set<SignalsListener>\n  rootListener :(sig :Signal)=>void\n}\n\nconst _listenermap = new Map<Signal,ListenerEntry>()\n\n// addListener registers f to be called upon receiving signal sig.\n//\n// The semantics of this function is different than process.on(sig, f): The process is always\n// terminated after all handlers have been invoked.\n//\nexport function addListener(sig :Signal, f :SignalsListener) {\n  // any log messages must be sync since process is about to terminate\n  const logerr = (msg :string) => fs.writeSync((process.stderr as any).fd, msg + \"\\n\")\n\n  let ent = _listenermap.get(sig)\n  if (ent) {\n    ent.listeners.add(f)\n  } else {\n    const listeners = new Set<SignalsListener>([f])\n    const rootListener = (sig :Signal) => {\n      // output linebreak after sigint as it is most likely from user pressing ^C in terminal\n      if (sig == \"SIGINT\") {\n        fs.writeSync(/*STDOUT*/1, \"\\n\")\n      }\n\n      // invoke all listeners\n      DEBUG && logerr(`[signal.ts] calling ${listeners.size} registered listeners`)\n      try {\n        for (let f of listeners) {\n          f(sig)\n        }\n      } catch (err) {\n        logerr(`error in signal listener: ${err.stack||err}`)\n      }\n\n      // exit process\n      process.exit(-(os.constants.signals[sig] || 1))\n\n      // // remove all listeners from process\n      // for (let [sig, ent] of _listenermap.entries()) {\n      //   process.removeListener(sig, ent.rootListener)\n      // }\n      // // Signal process again, which will cause a proper \"signal\" termination.\n      // // This may be important for a parent program running estrella.\n      // process.kill(process.pid, sig)\n    }\n    process.on(sig, rootListener)\n    _listenermap.set(sig, { rootListener, listeners })\n  }\n}\n\nexport function removeListener(sig :Signal, f :SignalsListener) {\n  const ent = _listenermap.get(sig)\n  if (ent) {\n    ent.listeners.delete(f)\n    if (ent.listeners.size == 0) {\n      _listenermap.delete(sig)\n      process.removeListener(sig, ent.rootListener)\n    }\n  }\n}\n", "import { json, tildePath } from \"./util\"\nimport log from \"./log\"\nimport { TypeScriptAPI, TSInterface, TSTypeProp } from \"../estrella\"\n\n// hack to make tsc work vanilla with our weird srcdir-based tsconfig (needed for examples to work)\nimport * as TS from \"../node_modules/typescript/lib/typescript.d\"\n\n// type Program = TS.Program\ntype CompilerOptions = TS.CompilerOptions\ntype InterfaceDeclaration = TS.InterfaceDeclaration\ntype SourceFile = TS.SourceFile\n\nexport function createTSAPI(tsapi? :typeof TS) :TypeScriptAPI | null {\n  let ts = tsapi as typeof TS\n  if (!ts) {\n    // load typescript module if available, or return null\n    log.debug(\"typescript API requested; attempting to load typescript module\")\n    try {\n      const X = require  // work around an issue in esbuild with require.X()\n      ts = X(\"typescript\") as typeof TS\n      if (parseFloat(ts.versionMajorMinor) < 3.5) {\n        // typescript too old\n        log.warn(\n          `typescript ${ts.version} is too old; disabling \"ts\" API.\\n` +\n          `  You are seeing this message because you are importing the ts API.\\n` +\n          `  Either install a more recent version of typescript or remove the ts import.`\n        )\n        return null\n      }\n      log.debug(() =>\n        `loaded typescript ${ts.version} from ${tildePath(X.resolve(\"typescript\"))}`)\n    } catch (_) {\n      // API unavailable\n      log.debug(() => `failed to load typescript; module unavailable`)\n      return null\n    }\n  }\n\n  const compilerHostCache = new Map<string,[TS.CompilerHost,CompilerOptions]>()\n\n  function getCompilerHost(options: CompilerOptions) :[TS.CompilerHost,CompilerOptions] {\n    const cacheKey = json(Object.keys(options).sort().map(k => [k,options[k]]))\n    const cacheEntry = compilerHostCache.get(cacheKey)\n    if (cacheEntry) {\n      log.debug(\"ts.getCompilerHost cache hit\")\n      return cacheEntry\n    }\n    options = {\n      newLine: ts.NewLineKind.LineFeed, // TS 4.0.3 crashes if not set\n      ...options\n    }\n    const host = ts.createCompilerHost(options, /*setParentNodes*/true)\n    const result :[TS.CompilerHost,CompilerOptions] = [host, options]\n    compilerHostCache.set(cacheKey, result)\n    log.debug(\"ts.getCompilerHost cache miss\")\n    return result\n  }\n\n\n  async function parse(source :string, options?: CompilerOptions) :Promise<SourceFile>\n\n  async function parse(\n    source :{[filename:string]:string},\n    options?: CompilerOptions,\n  ) :Promise<{[filename:string]:SourceFile}>\n\n  async function parse(\n    source :string | {[filename:string]:string},\n    options?: CompilerOptions,\n  ) :Promise<SourceFile|{[filename:string]:SourceFile}> {\n    const sources = typeof source == \"string\" ? {\"/<source>/a.ts\":source} : source\n    const filenames = Object.keys(sources)\n\n    const [host, compilerOptions] = getCompilerHost(options||{})\n\n    const readFile = host.readFile\n    host.readFile = (filename: string) => {\n      // console.log(\"readFile\", filename)\n      if (filename in sources) {\n        return sources[filename]\n      }\n      return readFile(filename)\n    }\n\n    // This is SLOW. Usually around 500ms for even a single empty file\n    const prog = ts.createProgram(filenames, compilerOptions, host)\n\n    if (typeof source == \"string\") {\n      return prog.getSourceFile(filenames[0])!\n    }\n    const nodes :{[filename:string]:SourceFile} = {}\n    for (let fn of filenames) {\n      nodes[fn] = prog.getSourceFile(fn)!\n    }\n    return nodes\n  }\n\n\n  async function parseFile(srcfile :string, options?: CompilerOptions) :Promise<SourceFile> {\n    // TODO worker\n    return _parsefile(srcfile, options)\n  }\n\n\n  function _parsefile(srcfile :string, options?: CompilerOptions) :SourceFile {\n    const [host, compilerOptions] = getCompilerHost(options || {})\n    const prog = ts.createProgram([srcfile], compilerOptions, host)\n    const file = prog.getSourceFile(srcfile)\n    if (!file) {\n      throw new Error(`${srcfile}: file not found`)\n    }\n    return file\n  }\n\n\n  function interfaceInfo(\n    srcfile :string,\n    interfaceName :string,\n    options?: CompilerOptions,\n  ) :Promise<TSInterface|null> {\n    return interfacesInfo(srcfile, [interfaceName], options).then(v => v[0])\n  }\n\n  async function interfacesInfo(\n    srcfile :string,\n    interfaceNames :string[] | null,\n    options?: CompilerOptions,\n  ) :Promise<(TSInterface|null)[]> {\n    // TODO move ts to subprocess/worker\n    const file = _parsefile(srcfile, options)\n    return interfacesInfoAST(file, interfaceNames)\n  }\n\n\n  function interfacesInfoAST(\n    file :SourceFile,\n    interfaceNames :string[] | null,\n  ) :(TSInterface|null)[] {\n    const ifdecls = topLevelInterfaceDeclarations(file)\n\n    const shortCircuit = new Map<InterfaceDeclaration,TSInterface>()\n    const infov :(TSInterface|null)[] = []\n\n    for (let name of (interfaceNames || ifdecls.keys())) {\n      const node = ifdecls.get(name)\n      if (!node) {\n        infov.push(null)\n        continue\n      }\n      infov.push(createTSInterface(file, node, ifdecls, shortCircuit))\n    }\n\n    return infov\n  }\n\n\n  function createTSInterface(\n    file         :SourceFile,\n    ifnode       :InterfaceDeclaration,\n    ifdecls      :Map<string,InterfaceDeclaration>,\n    shortCircuit :Map<InterfaceDeclaration,TSInterface>,\n  ) :TSInterface {\n    const info1 = shortCircuit.get(ifnode)\n    if (info1) {\n      return info1\n    }\n\n    const info :TSInterface = {\n      heritage: [],\n      name:     ifnode.name.escapedText as string,\n      props    :{},\n      computedProps() {\n        const props :{[name:string]:TSTypeProp} = {}\n        for (let h of info.heritage) {\n          Object.assign(props, h.props)\n        }\n        Object.assign(props, info.props)\n        return props\n      },\n      lookupProp(name :string) :TSTypeProp|null {\n        let p :TSTypeProp|null = info.props[name]\n        if (!p) {\n          for (let h of info.heritage) {\n            if (p = h.lookupProp(name)) {\n              break\n            }\n          }\n        }\n        return p\n      },\n    }\n\n    shortCircuit.set(ifnode, info)\n\n    // heritage types (i.e. from \"Bar\" in \"interface Foo extends Bar\")\n    if (ifnode.heritageClauses) for (let hc of ifnode.heritageClauses) { // hc :HeritageClause\n      for (let t of hc.types) { // t :ExpressionWithTypeArguments\n        const expr = t.expression\n        if (ts.isIdentifier(expr)) {\n          const heritageNode = ifdecls.get(expr.escapedText as string)\n          if (heritageNode) {\n            info.heritage.push(createTSInterface(file, heritageNode, ifdecls, shortCircuit))\n          } // else just ignore it\n        }\n      }\n    }\n\n    // build info.props\n    ifnode.forEachChild(n => {\n      if (ts.isPropertySignature(n)) {\n        const prop = createTSTypeProp(n, file, info)\n        info.props[prop.name] = prop\n      }\n    })\n\n    return info\n  }\n\n\n  function createTSTypeProp(\n    n :TS.PropertySignature,\n    file :SourceFile,\n    parent :TSInterface,\n  ) :TSTypeProp {\n    // console.log(\"PropertySignature\", n.name.escapedText, n)\n    const pos = ts.getLineAndCharacterOfPosition(file, n.pos)\n\n    let _typestr :string|null = null\n    const _type = n.type\n    const name = propName(n.name)\n\n    const typeprop = {\n      name,\n      type: _type,\n      get typestr() :string {\n        if (_typestr === null) {\n          _typestr = _type ? fmt(_type, file) : \"any\"\n        }\n        Object.defineProperty(typeprop, \"typestr\", {enumerable:true, value:_typestr})\n        return _typestr\n      },\n      srcfile: file.fileName,\n      srcline: pos.line,\n      srccol:  pos.character,\n      parent,\n    }\n    return typeprop\n  }\n\n\n  function propName(n :TS.PropertyName) :string {\n    switch (n.kind) {\n\n    case ts.SyntaxKind.Identifier:\n    case ts.SyntaxKind.PrivateIdentifier:\n      return n.escapedText as string\n\n    case ts.SyntaxKind.StringLiteral:\n    case ts.SyntaxKind.NumericLiteral:\n      return n.text\n\n    case ts.SyntaxKind.ComputedPropertyName:\n      // TODO printer\n      return \"[computed]\"\n\n    default:\n      return \"?\"\n    }\n  }\n\n\n  // returns all top-level interface declarations in file\n  function topLevelInterfaceDeclarations(file :SourceFile) :Map<string,InterfaceDeclaration> {\n    const m = new Map<string,InterfaceDeclaration>()\n    ts.forEachChild(file, n => {\n      if (n.kind == ts.SyntaxKind.InterfaceDeclaration) {\n        m.set(\n          (n as InterfaceDeclaration).name.escapedText as string,\n          n as InterfaceDeclaration,\n        )\n      } else {\n        // console.log(\"unhandled n in switch:\", ts.SyntaxKind[n.kind])\n      }\n    })\n    return m\n  }\n\n\n  const basicPrinter = ts.createPrinter({\n    removeComments: true,\n    newLine: ts.NewLineKind.LineFeed,\n    omitTrailingSemicolon: true,\n    noEmitHelpers: true,\n  })\n\n\n  /*EXPORT*/ function fmt(node :TS.Node, file? :SourceFile) :string {\n    if (!file) {\n      // find source file by walking up the AST\n      let n = node\n      while (n.kind != ts.SyntaxKind.SourceFile) {\n        n = n.parent\n        if (!n) {\n          throw new Error(\"node without SourceFile parent (provide file to ts.fmt)\")\n        }\n      }\n      file = n as TS.SourceFile\n    }\n    return basicPrinter.printNode(ts.EmitHint.Unspecified, node, file)\n  }\n\n  return {\n    ts,\n    getCompilerHost,\n    parse,\n    parseFile,\n    interfaceInfo,\n    interfacesInfo,\n    interfacesInfoAST,\n    fmt,\n  }\n\n}\n\n// const programCache = new Map<string,Program>() // {srcfile:{options:program}}\n// function getProgram(srcfiles :string[], options: CompilerOptions) {\n//   const cacheKey = srcfiles.map(f => Path.resolve(f)).join(\":\") + \"\\n\" + (\n//     Object.keys(options).sort().map(k => `${options[k]}\\n`)\n//   )\n//   let prog = programCache.get(cacheKey)\n//   if (!prog) {\n//     prog = ts.createProgram(srcfiles, options)\n//     programCache.set(cacheKey, prog)\n//   }\n//   return prog\n// }\n", "// Do not edit. Generated by build.js\n\nexport const esbuild = {\n  version:      \"0.11.20\",\n  BuildOptions: new Set([\n    \"sourcemap\"         , // boolean | 'inline' | 'external' | 'both'\n    \"legalComments\"     , // 'none' | 'inline' | 'eof' | 'linked' | 'external'\n    \"sourceRoot\"        , // string\n    \"sourcesContent\"    , // boolean\n    \"format\"            , // Format\n    \"globalName\"        , // string\n    \"target\"            , // string | string[]\n    \"minify\"            , // boolean\n    \"minifyWhitespace\"  , // boolean\n    \"minifyIdentifiers\" , // boolean\n    \"minifySyntax\"      , // boolean\n    \"charset\"           , // Charset\n    \"treeShaking\"       , // TreeShaking\n    \"jsxFactory\"        , // string\n    \"jsxFragment\"       , // string\n    \"define\"            , // { [key: string]: string; }\n    \"pure\"              , // string[]\n    \"avoidTDZ\"          , // boolean\n    \"keepNames\"         , // boolean\n    \"banner\"            , // string\n    \"footer\"            , // string\n    \"color\"             , // boolean\n    \"logLevel\"          , // LogLevel\n    \"errorLimit\"        , // number\n    \"bundle\"            , // boolean\n    \"splitting\"         , // boolean\n    \"outfile\"           , // string\n    \"metafile\"          , // string\n    \"outdir\"            , // string\n    \"outbase\"           , // string\n    \"platform\"          , // Platform\n    \"external\"          , // string[]\n    \"loader\"            , // { [ext: string]: Loader; }\n    \"resolveExtensions\" , // string[]\n    \"mainFields\"        , // string[]\n    \"write\"             , // boolean\n    \"allowOverwrite\"    , // boolean\n    \"tsconfig\"          , // string\n    \"outExtension\"      , // { [ext: string]: string; }\n    \"publicPath\"        , // string\n    \"entryNames\"        , // string\n    \"chunkNames\"        , // string\n    \"assetNames\"        , // string\n    \"inject\"            , // string[]\n    \"incremental\"       , // boolean\n    \"entryPoints\"       , // string[] | Record<string, string>\n    \"stdin\"             , // StdinOptions\n    \"plugins\"           , // Plugin[]\n  ]), // BuildOptions\n}\n\nexport const estrella = {\n  BuildConfig: new Set([\n    \"entry\"       , // string | string[] | Record<string, string>\n    \"debug\"       , // boolean\n    \"watch\"       , // boolean | WatchOptions\n    \"cwd\"         , // string\n    \"quiet\"       , // boolean\n    \"silent\"      , // boolean\n    \"clear\"       , // boolean\n    \"tslint\"      , // boolean | \"auto\" | \"on\" | \"off\" | TSLintBasicOptions\n    \"onStart\"     , // (config: Readonly<BuildConfig>, changedFiles: string[], ctx: BuildContext, esbuildOptions: any) => Promise<void> | any\n    \"onEnd\"       , // (config: Readonly<BuildConfig>, buildResult: BuildResult, ctx: BuildContext) => Promise<void> | any\n    \"outfileMode\" , // number | string | string[]\n    \"run\"         , // boolean | string | string[]\n    \"tsc\"         , // boolean | \"auto\" | \"on\" | \"off\"\n    \"tsrules\"     , // TSRules\n    \"title\"       , // string\n  ]), // BuildConfig\n}\n", "import * as filepath from \"path\"\nimport { sha1 } from \"./hash\"\nimport { isCLI } from \"./util\"\nimport {\n  BuildConfig as UserBuildConfig,\n  BuildContext as UserBuildContext,\n} from \"../estrella.d\"\n\n\nexport interface BuildContext extends UserBuildContext {\n  addCancelCallback(f :()=>void) :void\n}\n\n\nexport interface BuildConfig extends UserBuildConfig {\n  cwd :string // never undefined\n\n  // unique but stable ID of the build, used for temp files and caching\n  readonly projectID :string\n\n  // absolute path to outfile (empty if outfile is empty)\n  readonly outfileAbs :string\n\n  setOutfile(outfile :string) :void\n\n  // Computes projectID based on current configuration and updates value of this.projectID.\n  // Depends on the following config properties:\n  // - cwd\n  // - outfile\n  // - entryPoints\n  //\n  updateProjectID() :string\n\n  // true if the build is cancelled (BuildProcess.cancel() was called)\n  buildIsCancelled :boolean\n\n  // true if outfile is a temporary file\n  outfileIsTemporary :boolean\n\n  // if true, copy outfile to stdout when it has changes\n  outfileCopyToStdout :boolean\n\n  // true if metafile is a temporary file\n  metafileIsTemporary :boolean\n}\n\n// entryPointsMapToList {\"out1.js\":\"in1.js\",\"b.js\":\"b.js\"} => [\"out1.js:in1.js\",\"b.js:b.js\"]\nfunction entryPointsMapToList(entryPointsMap :Record<string,string>) :string[] {\n  return Object.keys(entryPointsMap).map(k => k + \":\" + entryPointsMap[k])\n}\n\nexport function createBuildConfig(userConfig :UserBuildConfig, defaultCwd :string) :BuildConfig {\n  let buildIsCancelled = false\n  let outfileIsTemporary = false\n  let outfileCopyToStdout = false\n  let metafileIsTemporary = false\n  let outfileAbs = \"\"\n\n  function computeProjectID(config :UserBuildConfig) :string {\n    const projectKey = [config.cwd, config.outfile||\"\", ...(\n      Array.isArray(config.entryPoints)     ? config.entryPoints :\n      typeof config.entryPoints == \"object\" ? entryPointsMapToList(config.entryPoints) :\n      config.entryPoints                    ? [config.entryPoints] :\n                                              []\n    )].join(filepath.delimiter)\n    return base36EncodeBuf(sha1(Buffer.from(projectKey, \"utf8\")))\n  }\n\n  let projectID = \"\"\n\n  const config :BuildConfig = Object.create({\n    get outfileAbs() :string { return outfileAbs },\n\n    setOutfile(outfile :string) :void {\n      config.outfile = outfile\n      outfileAbs = (\n        outfile && outfile != \"-\" ? filepath.resolve(config.cwd, outfile) :\n        \"\"\n      )\n    },\n\n    get projectID() :string { return projectID },\n\n    updateProjectID() :string {\n      projectID = computeProjectID(config)\n      return projectID\n    },\n\n    get buildIsCancelled() :boolean { return buildIsCancelled },\n    set buildIsCancelled(y :boolean) { buildIsCancelled = y },\n\n    get outfileIsTemporary() :boolean { return outfileIsTemporary },\n    set outfileIsTemporary(y :boolean) { outfileIsTemporary = y },\n\n    get outfileCopyToStdout() :boolean { return outfileCopyToStdout },\n    set outfileCopyToStdout(y :boolean) { outfileCopyToStdout = y },\n\n    get metafileIsTemporary() :boolean { return metafileIsTemporary },\n    set metafileIsTemporary(y :boolean) { metafileIsTemporary = y },\n  })\n\n  Object.assign(config, userConfig)\n\n  config.cwd = (\n    userConfig.cwd ? filepath.resolve(userConfig.cwd) :\n    (!isCLI && process.mainModule) ? process.mainModule.path :\n    defaultCwd\n  )\n  config.setOutfile(userConfig.outfile || \"\")\n  config.updateProjectID()\n\n  return config\n}\n\n\nfunction base36EncodeBuf(buf :Buffer) {\n  let s = \"\"\n  for (let i = 0; i < buf.length; i += 4) {\n    s += buf.readUInt32LE(i).toString(36)\n  }\n  return s\n}\n", "import * as crypto from \"crypto\"\n\nexport type StringEncoding = crypto.BinaryToTextEncoding\nexport type InputData      = string | NodeJS.ArrayBufferView\n\nexport function sha1(input :InputData) :Buffer\nexport function sha1(input :InputData, outputEncoding :StringEncoding) :string\n\nexport function sha1(input :InputData, outputEncoding? :StringEncoding) :Buffer|string {\n  const h = crypto.createHash('sha1').update(input)\n  return outputEncoding ? h.digest(outputEncoding) : h.digest()\n}\n"],
  "mappings": "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",
  "names": []
}
