{"version":3,"sources":["../node_modules/miniglob/src/miniglob.js","../node_modules/miniglob/src/miniglob.js","../src/util.js","../src/estrella.js","../src/global.ts","../src/extra.ts","../src/termstyle.ts","../src/log.ts","../src/cli.ts","../src/file.ts","../src/chmod.ts","../src/error.ts","../src/memoize.js","../src/screen.js","../src/tslint.js","../src/tsutil.ts","../src/run.ts","../src/exec.ts","../src/io.ts","../src/timeout.ts","../src/signal.ts","../src/tsapi.ts","../src/typeinfo.ts","../src/config.ts","../src/hash.ts"],"sourcesContent":["//\n// miniglob is a port of golang path/filepath\n//\n// Original Go source code Copyright (c) 2009 The Go Authors.\n// All rights reserved. See LICENSE-go for complete license.\n//\n// This code licensed under MIT, Copyright (c) 2018 Rasmus Andersson.\n// See LICENSE for complete license.\n//\nconst { readdirSync, statSync } = require('fs')\nconst DIRSEP = (() => {try {return require('path').sep}catch(_){return '/'}})()\nconst DIRSEP_BYTE = DIRSEP.charCodeAt(0)\nconst DIRSEP_RE_PG = DIRSEP == ':' ? /\\:+/g : DIRSEP == '\\\\' ? /\\\\+/g : /\\/+/g\nconst WIN32 = process.platform == 'win32'\n\n\nexport class PatternError extends Error {\n  constructor() { super('bad pattern') }\n}\n\n\nexport function glob(pattern) {\n  if (pattern.indexOf(\"**\") < 0) {\n    return glob0(pattern)\n  }\n  let matches = []\n  let filesVisited = new Set()\n  deepglob('', pattern.split(/\\*{2,}/), 0, matches, filesVisited)\n  return matches\n}\n\n\nfunction log() {\n  // console.log.apply(console, arguments)\n}\n\n\n// volumeNameLen returns length of the leading volume name on Windows.\n// It returns 0 elsewhere.\nconst volumeNameLen = WIN32 ? path => {\n  if (path.length < 2) {\n    return 0\n  }\n  // with drive letter\n  let c = path[0]\n  if (path[1] == ':' && ('a' <= c && c <= 'z' || 'A' <= c && c <= 'Z')) {\n    return 2\n  }\n  // TODO: check for UNC\n  return 0\n} : path => 0\n\n\n// cleanGlobPath prepares path for glob matching.\n// cleanGlobPath(path :string) : [prefixLen int, cleaned string]\n//\nconst cleanGlobPath = (\n  WIN32 ? (path, volumeNameLen) => { // (prefixLen int, cleaned string)\n    let vollen = volumeNameLen(path)\n    if (path == \"\") {\n      return [0, \".\"]\n    }\n    if (vollen+1 == path.length && isPathSep(path, path.length-1)) {\n      // /, \\, C:\\ and C:/ -- do nothing to the path\n      return [vollen + 1, path]\n    }\n    if (vollen == path.length && path.length == 2) { // C:\n      return [vollen, path + \".\"] // convert C: into C:.\n    }\n    if (vollen >= path.length) {\n      vollen = path.length - 1\n    }\n    return [vollen, path.substr(0, path.length-1)] // chop off trailing separator\n  } : (path, volumeNameLen) => {\n    if (path == \"\") {\n      return [volumeNameLen, \".\"]\n    }\n    if (path == DIRSEP) {\n      // do nothing to the path\n      return [volumeNameLen, path]\n    }\n    return [volumeNameLen, path.substr(0, path.length-1)] // chop off trailing separator\n  }\n)\n\n\nfunction isPathSep(s, i) {\n  return s.charCodeAt(i) === DIRSEP_BYTE\n}\n\n\n// (\"/foo///\") => \"/foo\"\nfunction stripDirSepRight(s) {\n  let e = s.length - 1, p = e\n  while (s.charCodeAt(p) === DIRSEP_BYTE) {\n    p--\n  }\n  return p != e ? s.substr(0, p + 1) : s\n}\n\n// (\"///foo/\") => \"foo/\"\nfunction stripDirSepLeft(s) {\n  let e = 0, p = e\n  while (s.charCodeAt(p) === DIRSEP_BYTE) {\n    p++\n  }\n  return p != e ? s.substr(p) : s\n}\n\n\n// deepglob(parts :string[]) string[] | null\n//\nfunction deepglob(dir, parts, partIndex, matches, filesVisited) {\n  if (partIndex >= parts.length) {\n    partIndex = parts.length - 1\n  }\n\n  let part = parts[partIndex]\n  let pattern = part\n\n  if (partIndex === 0) {\n    // first part\n    if (part.charCodeAt(part.length - 1) != DIRSEP_BYTE) {\n      // e.g. input=\"part**\"; part=\"part\"; pattern=\"part*\"\n      pattern += '*'\n    } // else e.g. input=\"part/**\"\n  } else if (partIndex === parts.length-1) {\n    // last part\n    if (part.charCodeAt(0) != DIRSEP_BYTE) {\n      // e.g. input=\"**part\"; part=\"part\"; pattern=\"*part\"\n      pattern = '*' + pattern\n    } // else e.g. input=\"**/part\"\n  } else {\n    // mid part\n    if (part.charCodeAt(0) != DIRSEP_BYTE) {\n      // e.g. input=\"**part**\"; part=\"part\"; pattern=\"*part\"\n      pattern = '*' + pattern\n    } // else e.g. input=\"**/part**\"\n    if (part.charCodeAt(part.length - 1) != DIRSEP_BYTE) {\n      // e.g. input=\"**part**\"; part=\"part\"; pattern=\"part*\"\n      pattern += '*'\n    } // else e.g. input=\"**part/**\"\n  }\n\n\n  function markVisit(path) {\n    if (filesVisited.has(path)) {\n      return false\n    }\n    filesVisited.add(path)\n    return true\n  }\n\n\n  function maybeAddFile(path) {\n    let filename = path\n    let p = filename.lastIndexOf(DIRSEP)\n    if (p != -1) {\n      filename = filename.substr(p + 1)\n    }\n\n    let nextPartIndex = Math.min(partIndex + 1, parts.length - 1)\n    let pat = parts.slice(nextPartIndex).join('*')\n\n    if (pat.charCodeAt(0) == DIRSEP_BYTE) {\n      pat = stripDirSepLeft(pat)\n    } else if (pat[0] != '*') {\n      pat = '*' + pat\n    }\n\n    if (match(pat, filename)) {\n      matches.push(path)\n    }\n  }\n\n  if (dir) {\n    if (pattern[0] != DIRSEP) {\n      pattern = dir + DIRSEP + pattern\n    } else {\n      pattern = dir + pattern\n    }\n  }\n\n  let isDirPattern = false\n  if (pattern.charCodeAt(pattern.length-1) === DIRSEP_BYTE) {\n    isDirPattern = true\n    pattern = stripDirSepRight(pattern)\n  }\n\n  let paths = glob0(pattern)\n\n  for (let path of paths) {\n    let st = statSync(path)\n\n    if (st.isDirectory()) {\n      if (markVisit(path)) {\n        walkdir(path, (path, st) => {\n          if (markVisit(path)) {\n            if (st.isDirectory()) {\n              deepglob(path, parts, partIndex + 1, matches, filesVisited)\n            } else {\n              maybeAddFile(path)\n            }\n          }\n        })\n      }\n    } else if (!isDirPattern && markVisit(path)) {\n      maybeAddFile(path)\n    }\n  }\n\n  return matches\n}\n\n\nfunction walkdir(dir, callback) {\n  dir = pclean(dir)\n  let st = statSync(dir)\n  if (st.isDirectory()) {\n    _walkdir(dir, callback, new Set([st.ino]))\n  }\n}\n\n\nfunction _walkdir(dir, callback, visitedInodes) {\n  for (let name of readdirSync(dir)) {\n    let path = pjoin(dir, name)\n    let st = stat(path)\n    let result = callback(path, st)\n    if (\n      (result || result === undefined) &&\n      st && st.isDirectory() && !visitedInodes.has(st.ino)\n    ) {\n      visitedInodes.add(st.ino)\n      _walkdir(path, callback, visitedInodes)\n    }\n  }\n}\n\n\n// Glob returns the names of all files matching pattern or null\n// if there is no matching file. The syntax of patterns is the same\n// as in Match. The pattern may describe hierarchical names such as\n// /usr/*/bin/ed (assuming the Separator is '/').\n//\n// Glob ignores file system errors such as I/O errors reading directories.\n// The only possible error is 'bad pattern', when pattern is malformed.\n//\n// glob(pattern :string) : string[] | null (matches)\nfunction glob0(pattern) {\n  let matches = []\n\n  if (!hasMeta(pattern)) {\n    if (stat(pattern)) {\n      return [pattern]\n    }\n    return matches\n  }\n\n  // dirname, basename\n  let volumeLen = volumeNameLen(pattern)\n  let i = pattern.length - 1\n  while (i >= volumeLen && !isPathSep(pattern, i)) {\n    i--\n  }\n  let dir = pattern.substr(0,i+1)\n  let file = pattern.substr(i+1)\n\n  ;[volumeLen, dir] = cleanGlobPath(dir, volumeLen)\n\n  if (!hasMeta(dir.substr(volumeLen))) {\n    _glob(dir, file, matches)\n  } else {\n    // Prevent infinite recursion. See golang issue 15879.\n    if (dir == pattern) {\n      throw new PatternError()\n    }\n    const m = glob0(dir) // :string[]\n    for (let d of m) {\n      _glob(d, file, matches)\n    }\n  }\n\n  return matches\n}\n\n\n// glob searches for files matching pattern in the directory dir\n// and appends them to matches. If the directory cannot be\n// opened, it returns the existing matches. New matches are\n// added in lexicographical order.\n//\n// _glob(dir :string, pattern :string, matches :string[])\n//\nfunction _glob(dir, pattern, matches) {\n  const fi = stat(dir)\n  if (fi === null) {\n    return\n  }\n  if (!fi.isDirectory()) {\n    return\n  }\n\n  let names\n  try {\n    names = readdirSync(dir)\n  } catch (_) {\n    return\n  }\n  names.sort()\n\n  for (let n of names) {\n    if (match(pattern, n)) {\n      matches.push(pjoin(dir, n))\n    }\n  }\n}\n\n\n// hasMeta reports whether path contains any of the magic characters\n// recognized by match.\nfunction hasMeta(path /*string*/) /*bool*/ {\n  for (let i = 0; i < path.length; ++i) {\n    switch (path.charCodeAt(i)) {\n      case 0x2A: // *\n      case 0x3F: // ?\n      case 0x5B: // [\n      case 0x7B: // {\n        return true\n    }\n  }\n  return false\n}\n\n\n// strContainsCh(s :string, c :int) : bool\nfunction strContainsCh(s, c) {\n  for (let i = 0; i < s.length; ++i) {\n    if (s.charCodeAt(i) === c) {\n      return true\n    }\n  }\n  return false\n}\n\n\n// Match reports whether name matches the shell file name pattern.\n// The pattern syntax is:\n//\n//  pattern:\n//    { term }\n//  term:\n//    '*'         matches any sequence of non-Separator characters\n//    '?'         matches any single non-Separator character\n//    '[' [ '^' ] { character-range } ']'\n//                character class (must be non-empty)\n//    c           matches character c (c != '*', '?', '\\\\', '[')\n//    '\\\\' c      matches character c\n//\n//  character-range:\n//    c           matches character c (c != '\\\\', '-', ']')\n//    '\\\\' c      matches character c\n//    lo '-' hi   matches character c for lo <= c <= hi\n//\n// Match requires pattern to match all of name, not just a substring.\n// The only possible returned error is ErrBadPattern, when pattern\n// is malformed.\n//\n// On Windows, escaping is disabled. Instead, '\\\\' is treated as\n// path separator.\n//\n// match(pattern :string, name :string) : bool (matched)\n//\nexport function match(pattern, name) {\n  Pattern:\n  while (pattern.length > 0) {\n    let star = false // :bool\n    let chunk = \"\" // :string\n\n    let patternin = pattern\n    ;[star, chunk, pattern] = scanChunk(pattern)\n    log(`scanChunk(%o) => %o`, patternin, [star, chunk, pattern])\n\n    if (star && chunk == \"\") {\n      log('ret')\n      // Trailing * matches rest of string unless it has a /.\n      return !strContainsCh(name, DIRSEP_BYTE)\n    }\n\n    // Look for match at current position.\n    let [t, ok] = matchChunk(chunk, name)\n    log(`matchChunk(%o, %o) => %o`, chunk, name, [t, ok])\n\n    // if we're the last chunk, make sure we've exhausted the name\n    // otherwise we'll give a false result even if we could still match\n    // using the star\n    if (ok && (t.length == 0 || pattern.length > 0)) {\n      name = t\n      continue\n    }\n\n    if (star) {\n      // Look for match skipping i+1 bytes.\n      // Cannot skip /.\n      for (let i = 0; i < name.length && name.charCodeAt(i) != DIRSEP_BYTE; i++) {\n        ;[t, ok] = matchChunk(chunk, name.substr(i+1))\n        if (ok) {\n          // if we're the last chunk, make sure we exhausted the name\n          if (pattern.length == 0 && t.length > 0) {\n            continue\n          }\n          name = t\n          continue Pattern\n        }\n      }\n    }\n\n    return false\n  }\n\n  return name.length == 0\n}\n\n\n// scanChunk gets the next segment of pattern, which is a non-star string\n// possibly preceded by a star.\n//\n// scanChunk(pattern :string) : [star bool, chunk string, rest string]\nfunction scanChunk(pattern) {\n  let star = false\n  while (pattern.length > 0 && pattern.charCodeAt(0) == 0x2A) {  // *\n    pattern = pattern.substr(1)\n    star = true\n  }\n  let inrange = false\n  let i = 0 >> 0 // int\n\n  Scan:\n  for (; i < pattern.length; i++) {\n    switch (pattern.charCodeAt(i)) {\n    case 0x5C: // \\\n      if (!WIN32) {\n        // error check handled in matchChunk: bad pattern.\n        if (i + 1 < pattern.length) {\n          i++\n        }\n      }\n      break\n    case 0x5B: // [\n      inrange = true\n      break\n    case 0x5D: // ]\n      inrange = false\n      break\n    case 0x2A: // *\n      if (!inrange) {\n        break Scan\n      }\n      break\n    }\n  }\n  return [ star, pattern.substr(0,i), pattern.substr(i) ]\n}\n\n\n// matchChunk checks whether chunk matches the beginning of s.\n// If so, it returns the remainder of s (after the match).\n// Chunk is all single-character operators: literals, char classes, and ?.\n//\n// matchChunk(chunk :string, s :string) [rest string, ok bool]\n//\nfunction matchChunk(chunk, s) {\n  log('enter matchChunk(%o, %o)', chunk, s)\n\n  while (chunk.length > 0) {\n    if (s.length == 0) {\n      return [\"\", false]\n    }\n\n    switch (chunk.charCodeAt(0)) {\n\n    case 0x5B: { // [\n      // character class\n      // let [r, n] = utf8.DecodeRuneInString(s)\n      let r = s.codePointAt(0)\n      let n = r <= 0xFFFF ? 1 : 2\n      s = s.substr(n)\n      chunk = chunk.substr(1)\n      log('\"[\" s reduced to %o, chunk reduced to %o, r = 0x%s', s, chunk, r.toString(16))\n\n      // We can't end right after '[', we're expecting at least\n      // a closing bracket and possibly a caret.\n      if (chunk.length == 0) {\n        throw new PatternError()\n      }\n      // possibly negated\n      let negated = chunk.charCodeAt(0) == 0x5E // ^\n      if (negated) {\n        log('\"[\" negation from \"^\"')\n        chunk = chunk.substr(1)\n      }\n      // parse all ranges\n      let match = false\n      let nrange = 0\n      while (true) {\n        if (chunk.length > 0 && chunk.charCodeAt(0) == 0x5D /*]*/ && nrange > 0) {\n          log('\"[\" loop break at A')\n          chunk = chunk.substr(1)\n          break\n        }\n\n        let ok, lo // bool, unichar\n        let debug_chunk = chunk\n        ;[ lo, chunk, ok ] = getEsc(chunk) // [ok bool, r rune, nchunk string]\n        log('\"[\" loop getEsc(%o) => %o', debug_chunk, [ lo, chunk, ok ])\n        if (!ok) {\n          log('\"[\" loop return at B from failed getEsc')\n          return [\"\", false]\n        }\n\n        let hi = lo\n        if (chunk.charCodeAt(0) == 0x2D /*-*/) {\n          ;[ hi, chunk, ok ] = getEsc(chunk.substr(1))\n          if (!ok) {\n            return [\"\", false]\n          }\n        }\n\n        if (lo <= r && r <= hi) {\n          match = true\n        }\n\n        nrange++\n      }\n      if (match == negated) {\n        return [\"\", false]\n      }\n      break\n    }\n\n    case 0x3F: // ?\n      if (s.charCodeAt(0) == DIRSEP_BYTE) {\n        return [\"\", false]\n      }\n      // _, n := utf8.DecodeRuneInString(s)\n      let r = s.codePointAt(0)\n      let n = r <= 0xFFFF ? 1 : 2\n      s = s.substr(n)\n      chunk = chunk.substr(1)\n      break\n\n    case 0x5C: // \\\n      if (!WIN32) {\n        log('\"\\\\\" consume')\n        chunk = chunk.substr(1)\n        if (chunk.length == 0) {\n          throw new PatternError()\n        }\n      }\n      // fallthrough\n\n    default:\n      if (chunk.charCodeAt(0) != s.charCodeAt(0)) {\n        log('[def] chunk[0] != s[0] (%o != %o) (0x%s != 0x%s) -- return',\n          chunk[0], s[0], chunk.charCodeAt(0).toString(16), s.charCodeAt(0).toString(16))\n        return [\"\", false]\n      }\n      s = s.substr(1)\n      chunk = chunk.substr(1)\n      log('[def] s reduced to %o, chunk reduced to %o', s, chunk)\n      break\n\n    }\n  }\n\n  return [ s, true ]\n}\n\n\n// getEsc gets a possibly-escaped character from chunk, for a character class.\n//\n// getEsc(chunk :string) : [ r rune, nchunk string, ok bool ]\n//\nfunction getEsc(chunk) {\n  let r = 0\n  let nchunk = ''\n  let c = chunk.charCodeAt(0)\n  if (chunk.length == 0 || c == 0x2D /*-*/ || c == 0x5D /*]*/) {\n    throw new PatternError()\n  }\n  if (c == 0x5C /*\\*/ && !WIN32) {\n    chunk = chunk.substr(1)\n    if (chunk.length == 0) {\n      throw new PatternError()\n    }\n  }\n  r = chunk.codePointAt(0)\n  let n = r <= 0xFFFF ? 1 : 2\n  if (r == 0xFFFF && n == 1) {\n    throw new PatternError()\n  }\n  nchunk = chunk.substr(n)\n  if (nchunk.length == 0) {\n    throw new PatternError()\n  }\n  return [ r, nchunk, true ]\n}\n\n\nfunction stat(path) {\n  try { return statSync(path) } catch (_) {}\n  return null\n}\n\n\nfunction pjoin(path1, path2) {\n  return (path1 == '.' || path1 == '') ? path2 : path1 + DIRSEP + path2\n}\n\n\n// pclean(\"foo//bar//\") => \"foo/bar\"\nfunction pclean(path) {\n  let endi = path.length - 1, i = endi\n  while (i && path.charCodeAt(i) === DIRSEP_BYTE) { --i }\n  if (i != endi) {\n    path = path.substr(0, i + 1)\n  }\n  return path.split(DIRSEP_RE_PG).join(DIRSEP)\n}\n","//\n// miniglob is a port of golang path/filepath\n//\n// Original Go source code Copyright (c) 2009 The Go Authors.\n// All rights reserved. See LICENSE-go for complete license.\n//\n// This code licensed under MIT, Copyright (c) 2018 Rasmus Andersson.\n// See LICENSE for complete license.\n//\nconst { readdirSync, statSync } = require('fs')\nconst DIRSEP = (() => {try {return require('path').sep}catch(_){return '/'}})()\nconst DIRSEP_BYTE = DIRSEP.charCodeAt(0)\nconst DIRSEP_RE_PG = DIRSEP == ':' ? /\\:+/g : DIRSEP == '\\\\' ? /\\\\+/g : /\\/+/g\nconst WIN32 = process.platform == 'win32'\n\n\nexport class PatternError extends Error {\n  constructor() { super('bad pattern') }\n}\n\n\nexport function glob(pattern) {\n  if (pattern.indexOf(\"**\") < 0) {\n    return glob0(pattern)\n  }\n  let matches = []\n  let filesVisited = new Set()\n  deepglob('', pattern.split(/\\*{2,}/), 0, matches, filesVisited)\n  return matches\n}\n\n\nfunction log() {\n  // console.log.apply(console, arguments)\n}\n\n\n// volumeNameLen returns length of the leading volume name on Windows.\n// It returns 0 elsewhere.\nconst volumeNameLen = WIN32 ? path => {\n  if (path.length < 2) {\n    return 0\n  }\n  // with drive letter\n  let c = path[0]\n  if (path[1] == ':' && ('a' <= c && c <= 'z' || 'A' <= c && c <= 'Z')) {\n    return 2\n  }\n  // TODO: check for UNC\n  return 0\n} : path => 0\n\n\n// cleanGlobPath prepares path for glob matching.\n// cleanGlobPath(path :string) : [prefixLen int, cleaned string]\n//\nconst cleanGlobPath = (\n  WIN32 ? (path, volumeNameLen) => { // (prefixLen int, cleaned string)\n    let vollen = volumeNameLen(path)\n    if (path == \"\") {\n      return [0, \".\"]\n    }\n    if (vollen+1 == path.length && isPathSep(path, path.length-1)) {\n      // /, \\, C:\\ and C:/ -- do nothing to the path\n      return [vollen + 1, path]\n    }\n    if (vollen == path.length && path.length == 2) { // C:\n      return [vollen, path + \".\"] // convert C: into C:.\n    }\n    if (vollen >= path.length) {\n      vollen = path.length - 1\n    }\n    return [vollen, path.substr(0, path.length-1)] // chop off trailing separator\n  } : (path, volumeNameLen) => {\n    if (path == \"\") {\n      return [volumeNameLen, \".\"]\n    }\n    if (path == DIRSEP) {\n      // do nothing to the path\n      return [volumeNameLen, path]\n    }\n    return [volumeNameLen, path.substr(0, path.length-1)] // chop off trailing separator\n  }\n)\n\n\nfunction isPathSep(s, i) {\n  return s.charCodeAt(i) === DIRSEP_BYTE\n}\n\n\n// (\"/foo///\") => \"/foo\"\nfunction stripDirSepRight(s) {\n  let e = s.length - 1, p = e\n  while (s.charCodeAt(p) === DIRSEP_BYTE) {\n    p--\n  }\n  return p != e ? s.substr(0, p + 1) : s\n}\n\n// (\"///foo/\") => \"foo/\"\nfunction stripDirSepLeft(s) {\n  let e = 0, p = e\n  while (s.charCodeAt(p) === DIRSEP_BYTE) {\n    p++\n  }\n  return p != e ? s.substr(p) : s\n}\n\n\n// deepglob(parts :string[]) string[] | null\n//\nfunction deepglob(dir, parts, partIndex, matches, filesVisited) {\n  if (partIndex >= parts.length) {\n    partIndex = parts.length - 1\n  }\n\n  let part = parts[partIndex]\n  let pattern = part\n\n  if (partIndex === 0) {\n    // first part\n    if (part.charCodeAt(part.length - 1) != DIRSEP_BYTE) {\n      // e.g. input=\"part**\"; part=\"part\"; pattern=\"part*\"\n      pattern += '*'\n    } // else e.g. input=\"part/**\"\n  } else if (partIndex === parts.length-1) {\n    // last part\n    if (part.charCodeAt(0) != DIRSEP_BYTE) {\n      // e.g. input=\"**part\"; part=\"part\"; pattern=\"*part\"\n      pattern = '*' + pattern\n    } // else e.g. input=\"**/part\"\n  } else {\n    // mid part\n    if (part.charCodeAt(0) != DIRSEP_BYTE) {\n      // e.g. input=\"**part**\"; part=\"part\"; pattern=\"*part\"\n      pattern = '*' + pattern\n    } // else e.g. input=\"**/part**\"\n    if (part.charCodeAt(part.length - 1) != DIRSEP_BYTE) {\n      // e.g. input=\"**part**\"; part=\"part\"; pattern=\"part*\"\n      pattern += '*'\n    } // else e.g. input=\"**part/**\"\n  }\n\n\n  function markVisit(path) {\n    if (filesVisited.has(path)) {\n      return false\n    }\n    filesVisited.add(path)\n    return true\n  }\n\n\n  function maybeAddFile(path) {\n    let filename = path\n    let p = filename.lastIndexOf(DIRSEP)\n    if (p != -1) {\n      filename = filename.substr(p + 1)\n    }\n\n    let nextPartIndex = Math.min(partIndex + 1, parts.length - 1)\n    let pat = parts.slice(nextPartIndex).join('*')\n\n    if (pat.charCodeAt(0) == DIRSEP_BYTE) {\n      pat = stripDirSepLeft(pat)\n    } else if (pat[0] != '*') {\n      pat = '*' + pat\n    }\n\n    if (match(pat, filename)) {\n      matches.push(path)\n    }\n  }\n\n  if (dir) {\n    if (pattern[0] != DIRSEP) {\n      pattern = dir + DIRSEP + pattern\n    } else {\n      pattern = dir + pattern\n    }\n  }\n\n  let isDirPattern = false\n  if (pattern.charCodeAt(pattern.length-1) === DIRSEP_BYTE) {\n    isDirPattern = true\n    pattern = stripDirSepRight(pattern)\n  }\n\n  let paths = glob0(pattern)\n\n  for (let path of paths) {\n    let st = statSync(path)\n\n    if (st.isDirectory()) {\n      if (markVisit(path)) {\n        walkdir(path, (path, st) => {\n          if (markVisit(path)) {\n            if (st.isDirectory()) {\n              deepglob(path, parts, partIndex + 1, matches, filesVisited)\n            } else {\n              maybeAddFile(path)\n            }\n          }\n        })\n      }\n    } else if (!isDirPattern && markVisit(path)) {\n      maybeAddFile(path)\n    }\n  }\n\n  return matches\n}\n\n\nfunction walkdir(dir, callback) {\n  dir = pclean(dir)\n  let st = statSync(dir)\n  if (st.isDirectory()) {\n    _walkdir(dir, callback, new Set([st.ino]))\n  }\n}\n\n\nfunction _walkdir(dir, callback, visitedInodes) {\n  for (let name of readdirSync(dir)) {\n    let path = pjoin(dir, name)\n    let st = stat(path)\n    let result = callback(path, st)\n    if (\n      (result || result === undefined) &&\n      st && st.isDirectory() && !visitedInodes.has(st.ino)\n    ) {\n      visitedInodes.add(st.ino)\n      _walkdir(path, callback, visitedInodes)\n    }\n  }\n}\n\n\n// Glob returns the names of all files matching pattern or null\n// if there is no matching file. The syntax of patterns is the same\n// as in Match. The pattern may describe hierarchical names such as\n// /usr/*/bin/ed (assuming the Separator is '/').\n//\n// Glob ignores file system errors such as I/O errors reading directories.\n// The only possible error is 'bad pattern', when pattern is malformed.\n//\n// glob(pattern :string) : string[] | null (matches)\nfunction glob0(pattern) {\n  let matches = []\n\n  if (!hasMeta(pattern)) {\n    if (stat(pattern)) {\n      return [pattern]\n    }\n    return matches\n  }\n\n  // dirname, basename\n  let volumeLen = volumeNameLen(pattern)\n  let i = pattern.length - 1\n  while (i >= volumeLen && !isPathSep(pattern, i)) {\n    i--\n  }\n  let dir = pattern.substr(0,i+1)\n  let file = pattern.substr(i+1)\n\n  ;[volumeLen, dir] = cleanGlobPath(dir, volumeLen)\n\n  if (!hasMeta(dir.substr(volumeLen))) {\n    _glob(dir, file, matches)\n  } else {\n    // Prevent infinite recursion. See golang issue 15879.\n    if (dir == pattern) {\n      throw new PatternError()\n    }\n    const m = glob0(dir) // :string[]\n    for (let d of m) {\n      _glob(d, file, matches)\n    }\n  }\n\n  return matches\n}\n\n\n// glob searches for files matching pattern in the directory dir\n// and appends them to matches. If the directory cannot be\n// opened, it returns the existing matches. New matches are\n// added in lexicographical order.\n//\n// _glob(dir :string, pattern :string, matches :string[])\n//\nfunction _glob(dir, pattern, matches) {\n  const fi = stat(dir)\n  if (fi === null) {\n    return\n  }\n  if (!fi.isDirectory()) {\n    return\n  }\n\n  let names\n  try {\n    names = readdirSync(dir)\n  } catch (_) {\n    return\n  }\n  names.sort()\n\n  for (let n of names) {\n    if (match(pattern, n)) {\n      matches.push(pjoin(dir, n))\n    }\n  }\n}\n\n\n// hasMeta reports whether path contains any of the magic characters\n// recognized by match.\nfunction hasMeta(path /*string*/) /*bool*/ {\n  for (let i = 0; i < path.length; ++i) {\n    switch (path.charCodeAt(i)) {\n      case 0x2A: // *\n      case 0x3F: // ?\n      case 0x5B: // [\n      case 0x7B: // {\n        return true\n    }\n  }\n  return false\n}\n\n\n// strContainsCh(s :string, c :int) : bool\nfunction strContainsCh(s, c) {\n  for (let i = 0; i < s.length; ++i) {\n    if (s.charCodeAt(i) === c) {\n      return true\n    }\n  }\n  return false\n}\n\n\n// Match reports whether name matches the shell file name pattern.\n// The pattern syntax is:\n//\n//  pattern:\n//    { term }\n//  term:\n//    '*'         matches any sequence of non-Separator characters\n//    '?'         matches any single non-Separator character\n//    '[' [ '^' ] { character-range } ']'\n//                character class (must be non-empty)\n//    c           matches character c (c != '*', '?', '\\\\', '[')\n//    '\\\\' c      matches character c\n//\n//  character-range:\n//    c           matches character c (c != '\\\\', '-', ']')\n//    '\\\\' c      matches character c\n//    lo '-' hi   matches character c for lo <= c <= hi\n//\n// Match requires pattern to match all of name, not just a substring.\n// The only possible returned error is ErrBadPattern, when pattern\n// is malformed.\n//\n// On Windows, escaping is disabled. Instead, '\\\\' is treated as\n// path separator.\n//\n// match(pattern :string, name :string) : bool (matched)\n//\nexport function match(pattern, name) {\n  Pattern:\n  while (pattern.length > 0) {\n    let star = false // :bool\n    let chunk = \"\" // :string\n\n    let patternin = pattern\n    ;[star, chunk, pattern] = scanChunk(pattern)\n    log(`scanChunk(%o) => %o`, patternin, [star, chunk, pattern])\n\n    if (star && chunk == \"\") {\n      log('ret')\n      // Trailing * matches rest of string unless it has a /.\n      return !strContainsCh(name, DIRSEP_BYTE)\n    }\n\n    // Look for match at current position.\n    let [t, ok] = matchChunk(chunk, name)\n    log(`matchChunk(%o, %o) => %o`, chunk, name, [t, ok])\n\n    // if we're the last chunk, make sure we've exhausted the name\n    // otherwise we'll give a false result even if we could still match\n    // using the star\n    if (ok && (t.length == 0 || pattern.length > 0)) {\n      name = t\n      continue\n    }\n\n    if (star) {\n      // Look for match skipping i+1 bytes.\n      // Cannot skip /.\n      for (let i = 0; i < name.length && name.charCodeAt(i) != DIRSEP_BYTE; i++) {\n        ;[t, ok] = matchChunk(chunk, name.substr(i+1))\n        if (ok) {\n          // if we're the last chunk, make sure we exhausted the name\n          if (pattern.length == 0 && t.length > 0) {\n            continue\n          }\n          name = t\n          continue Pattern\n        }\n      }\n    }\n\n    return false\n  }\n\n  return name.length == 0\n}\n\n\n// scanChunk gets the next segment of pattern, which is a non-star string\n// possibly preceded by a star.\n//\n// scanChunk(pattern :string) : [star bool, chunk string, rest string]\nfunction scanChunk(pattern) {\n  let star = false\n  while (pattern.length > 0 && pattern.charCodeAt(0) == 0x2A) {  // *\n    pattern = pattern.substr(1)\n    star = true\n  }\n  let inrange = false\n  let i = 0 >> 0 // int\n\n  Scan:\n  for (; i < pattern.length; i++) {\n    switch (pattern.charCodeAt(i)) {\n    case 0x5C: // \\\n      if (!WIN32) {\n        // error check handled in matchChunk: bad pattern.\n        if (i + 1 < pattern.length) {\n          i++\n        }\n      }\n      break\n    case 0x5B: // [\n      inrange = true\n      break\n    case 0x5D: // ]\n      inrange = false\n      break\n    case 0x2A: // *\n      if (!inrange) {\n        break Scan\n      }\n      break\n    }\n  }\n  return [ star, pattern.substr(0,i), pattern.substr(i) ]\n}\n\n\n// matchChunk checks whether chunk matches the beginning of s.\n// If so, it returns the remainder of s (after the match).\n// Chunk is all single-character operators: literals, char classes, and ?.\n//\n// matchChunk(chunk :string, s :string) [rest string, ok bool]\n//\nfunction matchChunk(chunk, s) {\n  log('enter matchChunk(%o, %o)', chunk, s)\n\n  while (chunk.length > 0) {\n    if (s.length == 0) {\n      return [\"\", false]\n    }\n\n    switch (chunk.charCodeAt(0)) {\n\n    case 0x5B: { // [\n      // character class\n      // let [r, n] = utf8.DecodeRuneInString(s)\n      let r = s.codePointAt(0)\n      let n = r <= 0xFFFF ? 1 : 2\n      s = s.substr(n)\n      chunk = chunk.substr(1)\n      log('\"[\" s reduced to %o, chunk reduced to %o, r = 0x%s', s, chunk, r.toString(16))\n\n      // We can't end right after '[', we're expecting at least\n      // a closing bracket and possibly a caret.\n      if (chunk.length == 0) {\n        throw new PatternError()\n      }\n      // possibly negated\n      let negated = chunk.charCodeAt(0) == 0x5E // ^\n      if (negated) {\n        log('\"[\" negation from \"^\"')\n        chunk = chunk.substr(1)\n      }\n      // parse all ranges\n      let match = false\n      let nrange = 0\n      while (true) {\n        if (chunk.length > 0 && chunk.charCodeAt(0) == 0x5D /*]*/ && nrange > 0) {\n          log('\"[\" loop break at A')\n          chunk = chunk.substr(1)\n          break\n        }\n\n        let ok, lo // bool, unichar\n        let debug_chunk = chunk\n        ;[ lo, chunk, ok ] = getEsc(chunk) // [ok bool, r rune, nchunk string]\n        log('\"[\" loop getEsc(%o) => %o', debug_chunk, [ lo, chunk, ok ])\n        if (!ok) {\n          log('\"[\" loop return at B from failed getEsc')\n          return [\"\", false]\n        }\n\n        let hi = lo\n        if (chunk.charCodeAt(0) == 0x2D /*-*/) {\n          ;[ hi, chunk, ok ] = getEsc(chunk.substr(1))\n          if (!ok) {\n            return [\"\", false]\n          }\n        }\n\n        if (lo <= r && r <= hi) {\n          match = true\n        }\n\n        nrange++\n      }\n      if (match == negated) {\n        return [\"\", false]\n      }\n      break\n    }\n\n    case 0x3F: // ?\n      if (s.charCodeAt(0) == DIRSEP_BYTE) {\n        return [\"\", false]\n      }\n      // _, n := utf8.DecodeRuneInString(s)\n      let r = s.codePointAt(0)\n      let n = r <= 0xFFFF ? 1 : 2\n      s = s.substr(n)\n      chunk = chunk.substr(1)\n      break\n\n    case 0x5C: // \\\n      if (!WIN32) {\n        log('\"\\\\\" consume')\n        chunk = chunk.substr(1)\n        if (chunk.length == 0) {\n          throw new PatternError()\n        }\n      }\n      // fallthrough\n\n    default:\n      if (chunk.charCodeAt(0) != s.charCodeAt(0)) {\n        log('[def] chunk[0] != s[0] (%o != %o) (0x%s != 0x%s) -- return',\n          chunk[0], s[0], chunk.charCodeAt(0).toString(16), s.charCodeAt(0).toString(16))\n        return [\"\", false]\n      }\n      s = s.substr(1)\n      chunk = chunk.substr(1)\n      log('[def] s reduced to %o, chunk reduced to %o', s, chunk)\n      break\n\n    }\n  }\n\n  return [ s, true ]\n}\n\n\n// getEsc gets a possibly-escaped character from chunk, for a character class.\n//\n// getEsc(chunk :string) : [ r rune, nchunk string, ok bool ]\n//\nfunction getEsc(chunk) {\n  let r = 0\n  let nchunk = ''\n  let c = chunk.charCodeAt(0)\n  if (chunk.length == 0 || c == 0x2D /*-*/ || c == 0x5D /*]*/) {\n    throw new PatternError()\n  }\n  if (c == 0x5C /*\\*/ && !WIN32) {\n    chunk = chunk.substr(1)\n    if (chunk.length == 0) {\n      throw new PatternError()\n    }\n  }\n  r = chunk.codePointAt(0)\n  let n = r <= 0xFFFF ? 1 : 2\n  if (r == 0xFFFF && n == 1) {\n    throw new PatternError()\n  }\n  nchunk = chunk.substr(n)\n  if (nchunk.length == 0) {\n    throw new PatternError()\n  }\n  return [ r, nchunk, true ]\n}\n\n\nfunction stat(path) {\n  try { return statSync(path) } catch (_) {}\n  return null\n}\n\n\nfunction pjoin(path1, path2) {\n  return (path1 == '.' || path1 == '') ? path2 : path1 + DIRSEP + path2\n}\n\n\n// pclean(\"foo//bar//\") => \"foo/bar\"\nfunction pclean(path) {\n  let endi = path.length - 1, i = endi\n  while (i && path.charCodeAt(i) === DIRSEP_BYTE) { --i }\n  if (i != endi) {\n    path = path.substr(0, i + 1)\n  }\n  return path.split(DIRSEP_RE_PG).join(DIRSEP)\n}\n","import * as fs from \"fs\"\nimport * as Path from \"path\"\nimport * as os from \"os\"\nimport { performance } from \"perf_hooks\"\nimport { stdoutStyle } from \"./termstyle\"\nimport { inspect } from \"util\"\n\nexport const json = (val, pretty, showHidden) => JSON.stringify(val, showHidden, pretty)\nexport const clock = () => performance.now()\n\n// running on Windows?\nexport const isWindows = process.platform.startsWith(\"win\")\n\n// generic symbols\nexport const TYPE = Symbol(\"TYPE\")\n\n// runtimeRequire(id :string) :any\nexport function runtimeRequire(id) {\n  // _runtimeRequire is defined at compile time by build.js (== require)\n  try { return _runtimeRequire(id) } catch { return null }\n}\nruntimeRequire.resolve = id => {\n  try { return _runtimeRequire.resolve(id) } catch { return \"\" }\n}\n\n// isCLI is true if estrella is invoked directly and not imported as a module\nexport const isCLI = module.id == \".\" || process.mainModule.filename == __filename\n\n\nexport function repr(val, prettyOrOptions) {\n  let options = {\n    colors: stdoutStyle.ncolors > 0,\n  }\n  if (typeof prettyOrOptions == \"object\") {\n    options = { ...prettyOrOptions }\n  } else if (prettyOrOptions !== undefined) {\n    options.compact = !prettyOrOptions\n  }\n  return inspect(val, options)\n}\n\n\nexport function resolveModulePackageFile(moduleSpec) {\n  const mainfile = runtimeRequire.resolve(moduleSpec)\n  let dir = Path.dirname(Path.resolve(mainfile))\n  let lastdir = Path.sep // lastdir approach to support Windows (not just check for \"/\")\n  while (dir != lastdir) {\n    let pfile = Path.join(dir, \"package.json\")\n    if (fs.existsSync(pfile)) {\n      return pfile\n    }\n    dir = Path.dirname(dir)\n  }\n  throw new Error(`package.json not found for module ${moduleSpec}`)\n}\n\n\nexport function getModulePackageJSON(moduleSpec) {\n  const pfile = resolveModulePackageFile(moduleSpec)\n  return jsonparseFile(pfile)\n}\n\n\nlet _tmpdir = \"\"\n\nexport function tmpdir() {\n  if (!_tmpdir) {\n    // Some systems return paths with symlinks.\n    // esbuild does \"realpath\" on some pathnames and thus reporting with esbuild's metafile\n    // may be incorrect if this is not canonical.\n    _tmpdir = fs.realpathSync.native(os.tmpdir())\n  }\n  return _tmpdir\n}\n\n\nexport function fmtDuration(ms) {\n  return (\n    ms >= 59500 ? (ms/60000).toFixed(0) + \"min\" :\n    ms >= 999.5 ? (ms/1000).toFixed(1) + \"s\" :\n    ms.toFixed(2) + \"ms\"\n  )\n}\n\nexport function fmtByteSize(bytes) {\n  return (\n    bytes >= 1024*1000 ? (bytes/(1024*1000)).toFixed(1) + \"MB\" :\n    bytes >= 1000 ? (bytes/1024).toFixed(1) + \"kB\" :\n    bytes + \"B\"\n  )\n}\n\nexport function findInPATH(executableName) {\n  const exeFileMode = isWindows ? 0xFFFFFFFF : fs.constants.X_OK\n  const PATH = new Set((process.env.PATH || \"\").split(Path.delimiter))\n\n  for (let dir of PATH) {\n    let path = Path.join(Path.resolve(dir), executableName)\n    if (isWindows) {\n      path += \".cmd\"\n    }\n    while (true) {\n      try {\n        let st = fs.statSync(path)\n        if (st.isSymbolicLink()) {\n          path = fs.realpathSync.native(path)\n          continue // try again\n        } else if (st.isFile() && (st.mode & exeFileMode)) {\n          return path\n        }\n      } catch (_) {\n        if (isWindows && path.endsWith(\".cmd\")) {\n          path = Path.join(Path.resolve(dir), executableName) + \".exe\"\n          continue // try with .exe extension\n        }\n      }\n      break\n    }\n  }\n  return null\n}\n\n\n// jsonparse parses \"relaxed\" JSON which can be in JavaScript format\nexport function jsonparse(jsonText, filename /*optional*/) {\n  try {\n    return JSON.parse(json)\n  } catch (err) {\n    return require(\"vm\").runInNewContext(\n      '(' + jsonText + ')',\n      { /* sandbox */ },\n      { filename, displayErrors: true }\n    )\n  }\n}\n\nexport function jsonparseFile(filename) {\n  const json = fs.readFileSync(filename, \"utf8\")\n  try {\n    return jsonparse(json)\n  } catch (err) {\n    throw new Error(`failed to parse ${filename}: ${err.message || err}`)\n  }\n}\n\n\n// ~/hello => /home/user/hello\nexport function expandTildePath(path) {\n  const homedir = os.homedir()\n  if (path == \"~\") {\n    return homedir\n  }\n  if (path.startsWith(\"~\" + Path.sep)) {\n    return homedir + path.substr(1)\n  }\n  return path\n}\n\n// /home/user/hello => ~/hello\nexport function tildePath(path) {\n  const s = Path.resolve(path)\n  const homedir = os.homedir()\n  if (s.startsWith(homedir)) {\n    return \"~\" + s.substr(homedir.length)\n  }\n  return s\n}\n","#!/usr/bin/env node\nimport * as esbuild from \"esbuild\"\nimport * as fs from \"fs\"\nimport * as os from \"os\"\nimport * as Path from \"path\"\nimport * as glob from \"miniglob\"\n\nimport \"./global\"\nimport { bugReportMessage, UserError } from \"./error\"\nimport {\n  clock,\n  findInPATH,\n  fmtByteSize,\n  fmtDuration,\n  json,\n  jsonparse,\n  jsonparseFile,\n  repr,\n  runtimeRequire,\n  tildePath,\n  tmpdir,\n  isCLI,\n} from \"./util\"\nimport { termStyle, stdoutStyle as style, stderrStyle } from \"./termstyle\"\nimport { memoize, isMemoized } from \"./memoize\"\nimport { screen } from \"./screen\"\nimport { tslint, defaultTSRules } from \"./tslint\"\nimport * as tsutil from \"./tsutil\"\nimport { prog, parseopt } from \"./cli\"\nimport log from \"./log\"\nimport * as cli from \"./cli\"\nimport * as run from \"./run\"\nimport * as tsapi from \"./tsapi\"\nimport { file, scandir, fileModificationLogAppend } from \"./file\"\nimport { chmod } from \"./chmod\"\nimport * as typeinfo from \"./typeinfo\"\nimport { createBuildConfig } from \"./config\"\nimport { sha1 } from \"./hash\"\nimport * as extra from \"./extra\"\n\nconst { dirname, basename } = Path\n\nconst CLI_DOC = {\n  usage: \"usage: $0 [options]\",\n  flags: [\n    [\"-w, watch\"         ,\"Watch source files for changes and rebuild.\"],\n    [\"-g, debug\"         ,\"Do not optimize and define DEBUG=true.\"],\n    [\"-r, run\"           ,\"Run the output file after a successful build.\"],\n    [\"-sourcemap\"        ,\"Generate sourcemap.\"],\n    [\"-inline-sourcemap\" ,\"Generate inline sourcemap.\"],\n    [\"-no-color\"         ,\"Disable use of colors.\"],\n    [\"-no-clear\"         ,\"Disable clearing of the screen, regardless of TTY status.\"],\n    [\"-no-diag\"          ,\"Disable TypeScript diagnostics.\"],\n    [\"-color\"            ,\"Color terminal output, regardless of TTY status.\"],\n    [\"-diag\"             ,\"Only run TypeScript diagnostics (no esbuild.)\"],\n    [\"-quiet\"            ,\"Only log warnings and errors but nothing else.\"],\n    [\"-silent\"           ,\"Don't log anything, not even errors.\"],\n    [\"-estrella-version\" ,\"Print version of estrella and exit 0.\"],\n    [\"-estrella-debug\"   ,\"Enable debug logging of estrella itself.\"],\n  ],\n}\n\nconst CLI_DOC_STANDALONE = {\n  usage: \"usage: $0 [options] <srcfile> ...\",\n  flags: CLI_DOC.flags.concat([\n    [\"-o, outfile\" ,\"Write output to <file> instead of stdout.\", \"<file>\"],\n    [\"-bundle\"     ,\"Include all dependencies.\"],\n    [\"-minify\"     ,\"Simplify and compress generated code.\"],\n    [\"-outdir\"     ,\"Write output to <dir> instead of stdout.\", \"<dir>\"],\n    [\"-esbuild\"    ,\"Pass arbitrary JSON to esbuild's build function.\", \"<json>\"],\n  ]),\n  trailer: `\n<srcfile> is a filename, or \"-\" for stdin.\n\nExample of using estrella without a build script:\n  $0 -o out/app.js main.ts\n    This compile main.ts and writes the output to out/app.js\n\nExample of using estrella with a build script:\n  1. Create a file called build.js with the following contents:\n       #!/usr/bin/env node\n       const { build } = require(\"estrella\")\n       build({\n         entry: \"main.ts\",\n         outfile: \"out/main.js\",\n       })\n  2. Make that file executable and run it:\n       chmod +x build.js\n       ./build.js\n  You can now customize your build behavior by changing build.js.\n  Try ./build.js -help\n\nSee https://github.com/rsms/estrella#readme for documentation.\n  `\n}\n\n// cli_ready resolved when CLI arguments have been fully processed.\n//\n// Parsing of CLI arguments happens in two phases when estrella runs from a user script.\n//   1. estrella built-in arguments are parsed, a cliopts.parse function is added.\n//   2. the user script executes, possibly calling cliopts.parse to parse custom arguments.\n//   3. a runloop frame later, cli_ready resolves.\n// This enables user scripts to extend the CLI options.\n//\n// Note that when estrella is run directly, CLI arguments are parsed in a single phase\n// and this does not apply. In that case cli_ready is resolved immediately.\n//\nlet cli_ready = Promise.resolve()\n\n// cliopts and cliargs are special objects exported in the API.\n// They are populated by this script's body when estrella runs from a user script,\n// otherwise these are populated by main()\nlet cliopts = {}, cliargs = []\n\nconst IS_MAIN_CALL = Symbol(\"IS_MAIN_CALL\")\n\nfunction EMPTYFUN(){}\n\n// setErrorExitCode(code:number=1) causes the program to exit with the provied code\n// in case it exits cleanly.\n// This is used to make it possible to exit with an error when there are multiple\n// builds happening.\n//\nlet _setErrorExitCode = false\nfunction setErrorExitCode(code) {\n  if (!_setErrorExitCode) {\n    _setErrorExitCode = true\n    let overrideCode = code || 1\n    process.exitCode = overrideCode\n    process.on(\"exit\", code => { process.exit(code || overrideCode) })\n  }\n}\n\n\nfunction processAPIConfig(config) {\n  // support use of both entry and entryPoints\n  log.debug(()=>`input config ${repr(config)}`)\n  if (!config.entryPoints) {\n    config.entryPoints = []\n  }\n  if (config.entry) {\n    if (Array.isArray(config.entry)) {\n      config.entryPoints = config.entryPoints.concat(config.entry)\n    } else {\n      config.entryPoints.push(config.entry)\n    }\n  }\n  delete config.entry\n  if (config.entryPoints.length == 0 && !config.stdin) {\n    // No entryPoints provided. Try to read from tsconfig include or files\n    log.debug(()=> `missing entryPoints; attempting inference`)\n    config.entryPoints = guessEntryPoints(config)\n    if (config.entryPoints.length == 0) {\n      let msg = tsutil.getTSConfigForConfig(config) ? \" (could not guess from tsconfig.json)\" : \"\"\n      throw new UserError(`config.entryPoints is empty or not set${msg}`)\n    }\n  }\n  // here, config.entryPoints is always of type: string[]\n\n  // normalize sourcemap value to boolean|\"inline\"|\"external\"\n  if (config.sourcemap) {\n    if (config.sourcemap != \"inline\" && config.sourcemap != \"external\") {\n      config.sourcemap = true\n    }\n  } else {\n    config.sourcemap = false\n  }\n\n  // if outfile is empty or missing, use a temporary file (esbuild needs a file to write to.)\n  // Note: outfile=\"-\" is handled by build1, prior to calling processAPIConfig.\n  if (!config.outfile && !config.outdir) {\n    config.setOutfile(\"-\") // set since it's used by updateProjectID\n    const projectID = config.updateProjectID()\n    config.setOutfile(Path.join(tmpdir(), `esbuild.${projectID}.out.js`))\n    config.outfileIsTemporary = true\n    // Note: We let config.outfileCopyToStdout be false (default) since the expected behavior\n    // in the case of outfile=\"\" is for nothing to appear on stdout but only contents returned\n    // through the API, to onEnd.\n  }\n\n  config.updateProjectID()\n  log.debug(()=>`effective config for project#${config.projectID}: ${repr(config)}`)\n}\n\n\nfunction patchSourceMap(mapfile, overrides) {\n  const timeStarted = clock()\n  const map = JSON.parse(fs.readFileSync(mapfile))\n  for (let k in overrides) {\n    let v = overrides[k]\n    if (v === undefined) {\n      delete map[k]\n    } else {\n      if (typeof v == \"function\") {\n        v = v(map[k])\n      }\n      map[k] = v\n    }\n  }\n  fs.writeFileSync(mapfile, JSON.stringify(map))\n  log.debug(() =>\n    `patched source map ${mapfile} with overrides ${repr(overrides)}` +\n    ` (${fmtDuration(clock() - timeStarted)})`)\n}\n\n\n// guessEntryPoints(config :BuildConfig) :string[]\nfunction guessEntryPoints(config) {\n  // guess from tsconfig.json file\n  const tsconfig = tsutil.getTSConfigForConfig(config)\n  if (tsconfig) {\n    log.debug(() => `tsconfig file found at ${tsutil.getTSConfigFileForConfig(config)}`)\n    if (tsconfig.files) {\n      return tsconfig.files\n    }\n    if (tsconfig.include) {\n      let files = []\n      for (let pat of tsconfig.include) {\n        log.debug(`guessing entry points: glob.glob(${pat}) =>`, glob.glob(pat))\n        files = files.concat(glob.glob(pat))\n      }\n      if (tsconfig.exclude) {\n        for (let pat of tsconfig.exclude) {\n          files = files.filter(fn => !glob.match(pat, fn))\n        }\n      }\n      // return the first file remaining (if any)\n      return files.slice(0, 1)\n    }\n  }\n  return []\n}\n\n\nfunction esbuildOptionsFromConfig(config) {\n  let esbuildOptions = {}\n  let unknownOptions = {}\n\n  // esbuildOptionKeyMap maps legacy esbuild BuildOptions keys to current ones\n  const esbuildOptionKeyMap = {\n    \"name\": \"globalName\", // changed in v0.5 or so\n  }\n\n  for (let k of Object.keys(config)) {\n    if (typeinfo.estrella.BuildConfig.has(k)) {\n      // skip estrella-specific option\n      continue\n    }\n    if (!typeinfo.esbuild.BuildOptions.has(k)) {\n      unknownOptions[k] = config[k]\n    }\n    k = esbuildOptionKeyMap[k] || k  // possibly renamed\n    esbuildOptions[k] = config[k]\n  }\n\n  if (Object.keys(unknownOptions).length > 0) {\n    log.info(\n      `Notice: Potentially invalid esbuild.BuildOption(s): ${repr(unknownOptions)}\\n` +\n      bugReportMessage(\"guess\", json(Object.keys(unknownOptions)))\n    )\n  }\n\n  if (!esbuildOptions.outfile) {\n    delete esbuildOptions.outfile\n  }\n\n  return esbuildOptions\n}\n\n\nlet _logInfoOnceRecord = new Set()\n\nfunction logInfoOnce(...v) {\n  if (log.level >= log.INFO) {\n    const k = v.join(\" \")\n    if (!_logInfoOnceRecord.has(k)) {\n      _logInfoOnceRecord.add(k)\n      log.info(...v)\n    }\n  }\n}\n\n\n// build wraps the \"real\" build function build1.\n// build does the following:\n// - makes a mutable copy of config\n// - wraps build1 in a CancellablePromise\n//\nfunction build(config /* estrella.BuildConfig */) {\n  config = createBuildConfig(\n    config || {},\n    ( // default cwd\n      config[IS_MAIN_CALL] ? process.cwd() :\n      process.mainModule && dirname(process.mainModule.filename) || __dirname\n    ),\n  )\n\n  const resolver = { resolve(){}, reject(){} }\n  const cancelCallbacks = []\n\n  // (f :()=>void) :void\n  function addCancelCallback(f) {\n    if (config.isCancelled) {\n      f()\n    } else {\n      cancelCallbacks.push(f)\n    }\n  }\n\n  function cancel(reason) {\n    if (!config.isCancelled) {\n      log.debug(`build cancelled`, {reason})\n      config.isCancelled = true\n      for (let f of cancelCallbacks) {\n        f && f()\n      }\n      cancelCallbacks.length = 0\n      if (reason) {\n        resolver.reject(reason)\n      } else {\n        resolver.resolve(true)\n      }\n    }\n  }\n\n  let ctx = {\n    addCancelCallback,\n    buildCounter: 0,\n    rebuild() {\n      log.warn(\"rebuild() called before initial build completed. Ignoring\")\n      return Promise.resolve(true)\n    },\n  }\n\n  const p = cli_ready.then(() => new Promise((resolve, reject) => {\n    if (config.isCancelled) {\n      log.debug(`build cancelled immediately`)\n      return false\n    }\n    resolver.resolve = resolve\n    resolver.reject = reject\n    build1(config, ctx).then(resolve).catch(reject)\n  }))\n\n  p.rebuild = () => ctx.rebuild()\n  Object.defineProperty(p, \"buildCounter\", { get() { return ctx.buildCounter } })\n  p.cancel = cancel\n\n  return p\n} // build()\n\n\n// build1 is the \"real\" build function -- build() wraps it with cancellation.\nasync function build1(config, ctx) {\n  const isMainCall = IS_MAIN_CALL in config\n  delete config[IS_MAIN_CALL]\n\n  let opts = cliopts, args = cliargs\n\n  if (config.run === undefined) {\n    config.run = opts.run\n  }\n\n  // if outfile is \"-\", use a temporary file (esbuild needs a file to write to)\n  if (\n    config.outfile == \"-\" ||\n    opts.outfile == \"-\" ||\n    (isMainCall && !opts.outfile && !opts.outdir)\n  ) {\n    config.setOutfile(\"-\") // set since it's used by updateProjectID\n    const projectID = config.updateProjectID()\n    opts.outfile = Path.join(tmpdir(), `esbuild.${projectID}.out.js`)\n    config.setOutfile(opts.outfile)\n    config.outfileIsTemporary = true\n    config.outfileCopyToStdout = true\n  }\n\n  if (!isMainCall) {\n    // process config when build is called as a function\n    processAPIConfig(config)\n  } else {\n    // BEGIN special logic for when running this script directly as a program\n\n    if (args.length == 0) {\n      // no <srcfile>'s provided, default to stdin unless its a TTY,\n      // else try to read tsconfig file in current directory.\n      if (!process.stdin.isTTY) {\n        args = [\"-\"]\n      } else {\n        const guess = guessEntryPoints(config)\n        log.debug(() => `no input files provided; best guess: ${repr(guess)}`)\n        if (guess.length == 0) {\n          log.error(`missing <srcfile> argument (see ${prog} -help)`)\n          process.exit(1)\n        }\n\n        args.splice(args.length-1, 0, ...guess)\n\n        // infer outfile or outdir\n        const tsconfig = tsutil.getTSConfigForConfig(config)\n        if (!opts.outfile && !opts.outdir && tsconfig) {\n          opts.outfile = tsconfig.outFile\n          if (!opts.outfile) {\n            opts.outdir = tsconfig.outDir\n          }\n        }\n\n        if (args.length == 0) {\n          log.error(`missing <srcfile> argument (see ${prog} -help)`)\n          process.exit(1)\n        }\n      }\n    }\n\n    // handle stdin args (\"-\")\n    args = args.filter(a => {\n      if (a != \"-\") {\n        return true\n      }\n      if (!config.stdin) { // guard to deduplicate multiple \"-\" args\n        config.stdin = {\n          contents: fs.readFileSync(/*STDIN_FILENO*/0, \"utf8\"),\n          sourcefile: \"stdin\",\n          resolveDir: process.cwd(),\n          loader: 'ts', // TODO make user-configurable on the CLI\n        }\n      }\n      return false\n    })\n\n    config.setOutfile(opts.outfile || undefined)\n    args.length > 0 && (config.entryPoints = args)\n    opts.outdir     && (config.outdir = opts.outdir)\n    opts.bundle     && (config.bundle = opts.bundle)\n    opts.minify     && (config.minify = opts.minify)\n\n    if (opts.esbuild) {\n      const esbuildProps = jsonparse(opts.esbuild, \"-esbuild\")\n      if (!esbuildProps || typeof esbuildProps != \"object\") {\n        log.error(\n          `-esbuild needs a JS object, for example '{key:\"value\"}'. Got ${typeof esbuildProps}.`\n        )\n        return false\n      }\n      log.debug(()=>`applying custom esbuild config ${repr(esbuildProps)}`)\n      for (let k in esbuildProps) {\n        config[k] = esbuildProps[k]\n      }\n    }\n    // END special logic for when running this script directly as a program\n  } // isMainCall\n\n  // smash config options and CLI options together\n  const debug = config.debug = opts.debug = !!(opts.debug || config.debug)\n  const silent = config.silent = opts.silent = !!(opts.silent || config.silent)\n  const quiet = config.quiet = opts.quiet = silent || !!(opts.quiet || config.quiet)\n  opts.watch = !!(opts.watch || config.watch)\n  if (!config.watch || typeof config.watch != \"object\") {\n    config.watch = opts.watch\n  }\n\n  if (config.color !== undefined) {\n    // update ANSI color setting\n    log.colorMode = config.color\n    style.reconfigure(process.stdout, config.color)\n    stderrStyle.reconfigure(process.stderr, config.color)\n  }\n\n  if (quiet && log.level < log.DEBUG) {\n    // when -quiet or -silent is set but -estrella-debug is NOT set, then reduce log verbosity\n    log.level = silent ? log.SILENT : log.WARN\n  }\n\n  config.sourcemap = (\n    opts[\"inline-sourcemap\"] ? \"inline\" :\n    opts.sourcemap ? true :\n    config.sourcemap\n  )\n  if (config.outfileIsTemporary && config.outfileCopyToStdout && config.sourcemap === true) {\n    // when writing to stdout, \"sourcemap:true\" means \"inline\" rather than \"yes, write a map file\".\n    config.sourcemap = \"inline\"\n  }\n\n  config.clear = (\n    opts[\"no-clear\"] ? false :\n    config.clear === undefined ? !!process.stdout.isTTY :\n    config.clear\n  )\n\n  log.debug(()=>`project directory ${repr(config.cwd)} (config.cwd)`)\n\n  if (!config.title) {\n    config.title = config.name || tildePath(config.cwd)\n  }\n\n  // set tslintOptions to the effective tslint option based\n  // - CLI arguments -diag and -no-diag\n  // - config property \"tslint\" and the older depreacted \"tsc\" property\n  // tslintOptions : boolean | \"auto\" | \"on\" | \"off\" | TSLintBasicOptions\n  // Note that opts.diag has already been adjusted for -no-diag so no need to look for that here.\n  let tslintOptions = (\n    opts.diag === true ? \"on\" :\n    opts.diag === false ? \"off\" :\n    \"auto\"\n  )\n  if (tslintOptions !== \"off\" && (!config.entryPoints || config.entryPoints.length == 0)) {\n    log.debug(`disabling tslint (no entryPoints)`)\n    tslintOptions = \"off\"\n  } else if (tslintOptions !== \"off\") {\n    if (config.tsc !== undefined) {\n      log.info(\"the 'tsc' property is deprecated. Please rename to 'tslint'.\")\n      if (config.tslint === undefined) {\n        config.tslint = config.tsc\n      }\n    }\n    if (config.tslint && config.tslint !== \"auto\") {\n      tslintOptions = config.tslint\n    }\n\n    const tslintIsAuto = (\n      tslintOptions === \"auto\" ||\n      (typeof tslintOptions == \"object\" && (config.tslint.mode === \"auto\" || !config.tslint.mode))\n    )\n\n    if (tslintIsAuto) {\n      // \"auto\" mode: only run tslint if a tsconfig file is found.\n      // This matches the behavior of calling the tslint() function directly.\n      if (!tsutil.getTSConfigFileForConfig(config)) {\n        log.debug(() => {\n          const dir = tsutil.tsConfigFileSearchDirForConfig(config)\n          const searchfiles = Array.from(tsutil.searchTSConfigFile(dir, config.cwd))\n          return (\n            `skipping tslint in auto mode since no tsconfig.json file was found in project.\\n` +\n            `Tried the following filenames:${searchfiles.map(f => `\\n  ${tildePath(f)}`)}`\n          )\n        })\n        tslintOptions = \"off\"\n      }\n    } else if (config.tslint !== undefined && config.tslint !== \"auto\") {\n      tslintOptions = config.tslint\n    }\n  }\n\n\n  // Configure \"run\"\n  if (config.run) {\n    run.configure(config)\n  }\n\n\n  let lastClearTime = 0\n  function clear() {\n    screen.clear()\n    lastClearTime = clock()\n  }\n\n\n  let isInsideCallToUserOnEnd = false\n  const userOnEnd = config.onEnd\n\n  // onEnd is called by onBuildSuccess OR onBuildFail\n  let onEnd = (\n    userOnEnd ? async (buildResults, defaultReturn) => {\n      isInsideCallToUserOnEnd = true\n      let returnValue = undefined\n      try {\n        const r = userOnEnd(config, buildResults, ctx)\n        returnValue = r instanceof Promise ? await r : r\n      } catch (err) {\n        log.debug(()=>`error in onEnd handler: ${err.stack||err}`)\n        throw err\n      } finally {\n        isInsideCallToUserOnEnd = false\n      }\n      const ok = returnValue === undefined ? defaultReturn : !!returnValue\n      return ok\n\n    } : (_buildResults, ok) => {\n      return ok\n    }\n  )\n\n  function wrapOnEnd(f) {\n    let onEndInner = onEnd\n    onEnd = async (buildResults, ok) => {\n      const ok2 = await f(buildResults, ok)\n      if (ok2 !== undefined) {\n        ok = ok2\n      }\n      return onEndInner(buildResults, ok)\n    }\n  }\n\n  // Note: wrapOnEnd stacks functions, meaning that a function defined earlier in this source\n  // file will be called later in time.\n\n  // chmod handler\n  if (config.outfileMode && config.outfile) {\n    wrapOnEnd(async (buildResults, ok) => {\n      log.debug(\"onEnd chmod\")\n      if (buildResults.errors.length == 0) {\n        try {\n          chmod(config.outfileAbs, config.outfileMode)\n        } catch (err) {\n          log.error(\"configuration error: outfileMode: \" + err.message)\n          setErrorExitCode(1)\n        }\n      }\n    })\n  }\n\n  // tmp outfile handler\n  if (config.outfileCopyToStdout && !config.run && config.write !== false) {\n    wrapOnEnd(async (buildResults, ok) => {\n      log.debug(\"onEnd copyToStdout\")\n      if (buildResults.errors.length == 0) {\n        return new Promise((resolve, reject) => {\n          const r = fs.createReadStream(config.outfileAbs)\n          r.on(\"end\", () => resolve(ok))\n          r.on(\"error\", reject)\n          r.pipe(process.stdout)\n        })\n      }\n    })\n  }\n\n  // add contents of output to onEnd when writing to a temporary file (not stdout)\n  if (config.outfileIsTemporary && !config.outfileCopyToStdout && config.write !== false) {\n    wrapOnEnd(async (buildResults, ok) => {\n      log.debug(\"onEnd load results\")\n      buildResults.js = fs.readFileSync(config.outfile, {encoding:\"utf8\"})\n      if (config.sourcemap === true) {\n        try {\n          buildResults.map = fs.readFileSync(config.outfile + \".map\", {encoding:\"utf8\"})\n        } catch (err) {\n          log.debug(\n            `failed to load temporary source map at ${config.outfile}.map: ${err.stack||err}`)\n        }\n        // strip \"sourceMappingURL ...\" from js\n        const i = buildResults.js.lastIndexOf(\"\\n//# sourceMappingURL\")\n        if (i != -1) {\n          buildResults.js = buildResults.js.substr(0, i+1) // +1 = keep LF\n        }\n      }\n    })\n  }\n\n  // print \"Watching files for changes...\" the first time a watcher starts\n  if (config.watch) {\n    wrapOnEnd(async (buildResults, ok) => {\n      // Note: Tests rely on this message, so if you change it, update those tests too.\n      logInfoOnce(\"Watching files for changes...\")\n    })\n  }\n\n  // definitions\n  let define = {\n    DEBUG: debug ? \"true\" : \"false\",\n    ...(config.define || {})\n  }\n\n  // options to esbuild\n  const esbuildOptions = {\n    // default values\n    minify: !debug,\n    sourcemap: config.sourcemap,\n    sourcesContent: false, // to match past versions of estrella\n    color: stderrStyle.ncolors > 0,\n    logLevel: (\n      log.level == log.DEBUG ? \"info\" :\n      config.silent ?          \"silent\" :\n      config.quiet ?           \"error\" :\n                               \"warning\" ),\n\n    // user values\n    ...esbuildOptionsFromConfig(config),\n\n    define,\n  }\n\n  // Incremental rebuild is available if the folllowing test passes:\n  //   (esbuildResult && esbuildResult.rebuild)\n  // This must be set to null whenever esbuildConfig changes.\n  let esbuildResult = null // : esbuild.BuildIncremental\n\n  let lastBuildResults = {\n    warnings: [],\n    errors: [],\n    metafile: null, //{inputs:{},outputs:{}}|null\n  }\n\n  // esbuild can produce a metadata file describing imports\n  // We use this to know what source files to observe in watch mode.\n  if (config.watch) {\n    const projectID = config.projectID\n    esbuildOptions.incremental = true\n    esbuildOptions.metafile = true\n    if ((!esbuildOptions.outfile && !esbuildOptions.outdir) || esbuildOptions.write === false) {\n      // esbuild needs an outfile for the metafile option to work\n      esbuildOptions.outfile = Path.join(tmpdir(), `esbuild.${projectID}.out.js`)\n      config.outfileIsTemporary = true\n      // if write==false, unset it so that esbuild actually writes metafile\n      delete esbuildOptions.write\n    }\n    // cancel incremental esbuild when BuildProcess.cancel is called\n    ctx.addCancelCallback(() => {\n      if (esbuildResult && esbuildResult.rebuild) {\n        esbuildResult.rebuild.dispose()\n      }\n    });\n    // setup metafile.inputs for initial run so that watch has some files\n    if (config.entryPoints && config.entryPoints.length > 0) {\n      lastBuildResults.metafile = {inputs:{},outputs:{}}\n      for (let f of config.entryPoints) {\n        lastBuildResults.metafile.inputs[f] = {}\n      }\n    }\n  }\n\n  // rebuild function\n  ctx.rebuild = () => { // Promise<boolean>\n    return _esbuild([]).then(ok => {\n      if (isInsideCallToUserOnEnd) {\n        log.warn(`waiting for rebuild() inside onEnd handler may cause a deadlock`)\n      }\n      return ok\n    })\n  }\n\n  function onBuildSuccess(timeStart, result/*esbuild.BuildResult*/) {\n    log.debug(\"esbuild finished with result\", result)\n    esbuildResult = result\n    logWarnings(result.warnings || [])\n    const time = fmtDuration(clock() - timeStart)\n    if (!config.outfile) {\n      log.info(style.green(\n        config.outdir ? `Wrote to dir ${config.outdir} (${time})` :\n                        `Finished (write=false, ${time})`\n      ))\n    } else {\n      let outname = config.outfile\n      if (config.sourcemap &&\n          config.outfileIsTemporary &&\n          config.sourcemap != \"inline\" &&\n          config.write !== false )\n      {\n        // repair \"sources\" filenames in sourcemap\n        patchSourceMap(config.outfileAbs + \".map\", {\n          sources: v => v && v.map(fn => Path.relative(config.cwd, fn)),\n        })\n      }\n      let size = 0\n      try { size = fs.statSync(config.outfileAbs).size } catch(_) {}\n      if (!config.outfileIsTemporary) {\n        log.info(style.green(`Wrote ${outname}`) + ` (${fmtByteSize(size)}, ${time})`)\n      }\n    }\n    lastBuildResults.warnings = result.warnings\n    lastBuildResults.errors = []\n    lastBuildResults.metafile = result.metafile || null\n    return onEnd(lastBuildResults, true)\n  }\n\n  let isInitialBuild = true  // TODO better name and documentation\n\n  function onBuildFail(timeStart, err) {\n    log.debug(\"esbuild finished with error:\", err ? err.stack || err : null)\n    let warnings = err.warnings || []\n    let errors = err.errors || []\n    if (errors.length == 0) {\n      // in this case the err is an Error object and describes the error\n      log.error(err.message)\n      errors.push({\n        text: String(err),\n        location: null,\n      })\n    }\n    // if (/^error: must provide/i.test(stderr)) {\n    //   // unrecoverable error in configuration\n    //   if (!config) { process.exit(1) }\n    // }\n    logWarnings(warnings)\n    lastBuildResults.warnings = warnings\n    lastBuildResults.errors = errors\n    if (!isInitialBuild) {\n      lastBuildResults.metafile = null\n    } else {\n      isInitialBuild = false\n    }\n    return onEnd(lastBuildResults, false)\n  }\n\n  // build function\n  async function _esbuild(fileEvents /*:FileEvent[]*/) {\n    if (config.watch && config.clear) {\n      clear()\n    }\n\n    // build list of changed filenames and check for entryPoint renames\n    let changedFiles = [] // :string[]\n    for (let f of fileEvents) {\n      if (f.type == \"move\") {\n        // renamed file: check entryPoints\n        const i = config.entryPoints ? config.entryPoints.indexOf(f.name) : -1\n        if (i != -1) {\n          log.debug(\"detected entryPoint file rename\", f.name, \"->\", f.newname)\n          config.entryPoints[i] = f.newname\n          esbuildOptions.entryPoints[i] = f.newname\n          esbuildResult = null // invalidate incremental esbuild (since config changed)\n        }\n        changedFiles.push(f.newname)\n      } else {\n        changedFiles.push(f.name)\n      }\n    }\n\n    if (config.onStart) {\n      try {\n        const r = config.onStart(config, changedFiles, ctx, esbuildOptions)\n        if (r instanceof Promise) {\n          await r\n        }\n      } catch (err) {\n        log.debug(()=>`error in onStart handler: ${err.stack||err}`)\n        // onBuildFail(clock(), `error in onStart handler: ${err.stack||err}`)\n        throw err\n      }\n    }\n\n    if (config.isCancelled) {\n      return\n    }\n\n    const rebuild = !!(esbuildResult && esbuildResult.rebuild)\n\n    log.debug(()=>\n      `invoking ${rebuild ? \"esbuildResult.rebuild\" : \"esbuild.build\"} ` +\n      `in ${process.cwd()} with options: ${repr(esbuildOptions)}`\n    )\n\n    // wrap call to esbuild.build in a temporarily-changed working directory.\n    // TODO: When/if esbuild adds an option to set cwd, use that instead.\n    const tmpcwd = process.cwd()\n    process.chdir(config.cwd)\n    const esbuildPromise = (\n      rebuild ? esbuildResult.rebuild() :\n                esbuild.build(esbuildOptions)\n    )\n    process.chdir(tmpcwd)\n\n    return esbuildPromise.then(\n      onBuildSuccess.bind(null, clock()),\n      onBuildFail.bind(null, clock()),\n    )\n  }\n\n  // start initial build\n  const buildPromise = opts.diag ? null : _esbuild([])\n\n  // TypeScript linter\n  const [tslintProcess, tslintProcessReused] = (\n    tslintOptions !== \"off\" ? startTSLint(tslintOptions, opts, config) :\n    [null,false]\n  )\n  if (tslintProcess && !tslintProcessReused) {\n    // must add error handler now before `await buildPromise`\n    tslintProcess.catch(e => {\n      log.error(e.stack || String(e))\n      return false\n    })\n    ctx.addCancelCallback(() => { tslintProcess.cancel() })\n    // if -diag is set on the command line and screen clearing is enabled, clear the screen now\n    // as our buildPromise is already resolved (no build will occur and thus no clear from that.)\n    if (cliopts.diag && config.watch && config.clear) {\n      screen.clear()\n    }\n  }\n\n  // await build\n  let ok = true\n  if (buildPromise) {\n    log.debug(\"awaiting esbuild\")\n    ok = await buildPromise\n    if (config.isCancelled) {\n      return false\n    }\n  }\n\n  // watch mode?\n  if (config.watch) {\n    function getESBuildMeta() { // :Object|null\n      return lastBuildResults.metafile\n    }\n    await extra.watch().watchFiles(config, getESBuildMeta, ctx, fileEvents => {\n      // This function is invoked whenever source files changed.\n      // Note that the watchFiles() function takes care of updating source file tracking.\n      const n = fileEvents.length\n      const fv = fileEvents.map(f =>\n        f.type == \"move\" ? f.newname :\n                           f.name )\n      log.info(`${n} ${n > 1 ? \"files\" : \"file\"} changed: ${fv.join(\", \")}`)\n      return _esbuild(fileEvents)\n    })\n    log.debug(\"fswatch ended\")\n    return true\n  }\n\n  // otherwise, when not in watch mode, wait for tslint and exit\n  if (tslintProcess) {\n    let tscWaitTimer = null\n    if (!ok) {\n      log.debug(\"cancelling eslint since esbuild reported an error\")\n      tslintProcess.cancel()\n    } else {\n      log.debug(\"awaiting eslint\")\n      if (!tslintProcessReused && !opts.diag) {\n        tscWaitTimer = setTimeout(() => log.info(\"Waiting for TypeScript... (^C to skip)\"), 1000)\n      }\n      ok = await tslintProcess.catch(() => false) // error handled earlier\n    }\n    clearTimeout(tscWaitTimer)\n  }\n\n  if (!config.isCancelled && !ok) {\n    setErrorExitCode()\n  }\n\n  // wait for any running commands\n  if (ok) {\n    const exitCode = await run.waitAll()\n    process.exitCode = exitCode\n  }\n\n  return ok\n} // build1()\n\n\nconst tslintProcessCache = new Map() // configKey => TSLintProcess\n\n\nfunction startTSLint(tslintOptions, cliopts, config) { // : [tslintProcess, tslintProcessReused]\n  // assert(tslintOptions !== \"off\")\n\n  let mode = tslintOptions\n  let tscBasicOptions = {}\n  if (tslintOptions && typeof tslintOptions == \"object\") {\n    mode = undefined\n    tscBasicOptions = tslintOptions\n    if (tscBasicOptions.mode == \"off\") {\n      log.debug(() => `tslint disabled by tslint config {mode:\"off\"}`)\n      return [null, false]\n    }\n  }\n\n  if (config.tsrules && config.tsrules.length) {\n    log.info(\"The 'tsrules' property is deprecated. Please use 'tslint.rules' instead\")\n    tscBasicOptions.rules = { ...config.tsrules, ...tscBasicOptions.rules }\n  }\n\n  // have tslint clear the screen when it restarts ONLY when -diag (no build) is set.\n  const clearScreen = cliopts.diag && config.watch && config.clear\n\n  const tsconfigFile = tsutil.getTSConfigFileForConfig(config) // string|null\n\n  // tslint processes are kept to a minimum since they may screw with screen clearing and\n  // multiple log streams is confusing.\n  const cacheKey = `${tsconfigFile || config.cwd}`\n  const existingTSLintProcess = tslintProcessCache.get(cacheKey)\n  if (existingTSLintProcess) {\n    log.debug(() => `tslint sharing process (no new process created)`)\n    return [existingTSLintProcess, true]\n  }\n\n  const srcdir = (\n    config.entryPoints && config.entryPoints.length > 0 ? dirname(config.entryPoints[0]) :\n                                                          config.cwd )\n\n  const options = {\n    colors: style.ncolors > 0,\n    quiet: config.quiet,\n    mode,\n\n    ...tscBasicOptions,\n\n    watch: config.watch,\n    cwd: config.cwd,\n    clearScreen,\n    srcdir,\n    tsconfigFile,\n    onRestart() {\n      log.debug(\"tsc restarting\")\n      // // called when tsc begin to deliver a new session of diagnostic messages.\n      // if (config.clear && clock() - lastClearTime > 5000) {\n      //   // it has been a long time since we cleared the screen.\n      //   // tsc likely reloaded the tsconfig.\n      //   screen.clear()\n      // }\n      //\n      // if (config.clear && clock() - lastClearTime > 5e3) {\n      //                                     ^\n      // ReferenceError: lastClearTime is not defined\n    },\n  }\n\n  log.debug(() => `starting tslint with options ${repr(options)}`)\n  const tslintProcess = tslint(options)\n  tslintProcessCache.set(cacheKey, tslintProcess)\n\n  return [tslintProcess, false]\n}\n\n\nfunction logWarnings(warnings) {\n  if (warnings.length > 0) {\n    // TODO: include warnings[N].location\n    log.warn(\"[warn] \" + warnings.map(m => m.text).join(\"\\n\"))\n  }\n}\n\n\nfunction logErrors(errors) {\n  if (errors.length > 0) {\n    // TODO: include errors[N].location\n    log.error(errors.map(m => m.text).join(\"\\n\"))\n  }\n}\n\n\nfunction main() {\n  return build({[IS_MAIN_CALL]:1}).catch(e => {\n    console.error(stderrStyle.red(prog + \": \" + (e ? (e.stack || e) : \"error\")))\n    const exitCode = process.exitCode || 0\n    process.exit(\n      exitCode > 0 ? exitCode : 1\n    )\n  }).then(ok => {\n    const exitCode = process.exitCode || 0\n    process.exit(\n      ok ? exitCode :\n      exitCode > 0 ? exitCode : 1\n    )\n  })\n}\n\n\n// ------------------------------------------------------------------------\n// parse CLI and dispatch main\n\nfunction postProcessCLIOpts() {\n  if (cliopts[\"no-color\"]) {\n    cliopts.color = false\n  }\n  if (cliopts[\"no-diag\"]) {\n    cliopts.diag = false\n  }\n\n  // update ANSI color setting\n  log.colorMode = cliopts.color\n  style.reconfigure(process.stdout, cliopts.color)\n  stderrStyle.reconfigure(process.stderr, cliopts.color)\n\n  if (cliopts.color !== undefined) {\n    // user explicitly asked to either turn on or off color\n    // const nocolor  = process.argv.includes(\"-no-color\") || process.argv.includes(\"--no-color\")\n    // const yescolor = process.argv.includes(\"-color\") || process.argv.includes(\"--color\")\n  }\n\n  // just print version and exit?\n  if (cliopts[\"estrella-version\"]) {\n    console.log(`estrella ${VERSION}${DEBUG ? \" (debug)\" : \"\"}`)\n    process.exit(0)\n  }\n\n  // update log.debug function\n  if (cliopts[\"estrella-debug\"]) {\n    log.level = log.DEBUG\n  }\n\n  // -diag disables -run\n  if (cliopts.diag && cliopts.run) {\n    log.info(`Disabling -run since -diag is set`)\n    cliopts.run = undefined\n  }\n\n  log.debug(()=> `Parsed initial CLI arguments: ${repr({options:cliopts, args:cliargs},2)}`)\n}\n\nif (isCLI) {\n  // Note: esbuild replaces the module object, so when running from a esbuild bundle,\n  // module.id is undefined.\n  ;[cliopts, cliargs] = cli.parseopt(process.argv.slice(2), CLI_DOC_STANDALONE)\n  postProcessCLIOpts()\n  main()\n} else {\n\n  // parse CLI arguments\n  // Note: cliopts and cliargs are special objects exported in the API.\n  // Note: This is only invoked when estrella runs from a user script, not when run directly.\n  ;[cliopts, cliargs] = cli.parseopt(process.argv.slice(2),{\n    ...CLI_DOC,\n    unknownFlagAsArg: true,\n    help(flags, _cliopts, _cliargs) {\n      cli_ready = new Promise(resolve => {\n        process.nextTick(() => {\n          console.log(cli.fmtUsage(flags, CLI_DOC.usage, CLI_DOC.trailer))\n          process.exit(0)\n          resolve()\n        })\n      })\n    },\n  })\n\n  postProcessCLIOpts()\n\n\n  // extra unparsed arguments?\n  if (cliargs.length > 0) {\n    cli_ready.then(() => {\n      if (cliargs.length > 0) {\n        // user script did not parse args\n        cli.printUnknownOptionsAndExit(cliargs)\n      }\n    })\n  }\n\n  // parse(...flags :cli.Flags[]) : [cli.Options, string[]]\n  cliopts.parse = (...flags) => {\n    log.debug(() =>\n      `Parsing custom CLI arguments ${json(cliargs.join)} via cliopts.parse(` +\n      repr(flags) + \")\"\n    )\n\n    const optsAndArgs = cli.parseopt(cliargs, {\n      ...CLI_DOC,\n      flags: CLI_DOC.flags.concat(flags),\n    })\n\n    log.debug(()=>\n      `Parsed extra CLI arguments: ` +\n      json({options: optsAndArgs[0], args: optsAndArgs[1]}, 2)\n    )\n\n    // clear cliargs so to not cause an error for missing options\n    cliargs.splice(0, cliargs.length)\n\n    return optsAndArgs\n  }\n} // end if main\n\n\nfunction watch(path, options, cb) {\n  return extra.watch().watch(path, options, cb)\n}\n\n\nfunction legacy_watchdir(path, filter, options, cb) {\n  log.info(() => `estrella.watchdir is deprecated. Please use estrella.watch instead`)\n  if (cb === undefined) {\n    if (options === undefined) {\n      // watchdir(path, cb)\n      cb = filter\n      options = {}\n    } else {\n      // watchdir(path, filter, cb)\n      cb = options\n      options = { ...options, filter }\n      if (options.recursive !== undefined) {\n        if (!options.recursive) {\n          options.depth = 0\n        }\n        delete options.recursive\n      }\n    }\n  }\n  return watch(path, options, cb)\n}\n\n\nlet _tsapiInstance = undefined\n\n\n// API\nmodule.exports = {\n  // data\n  version: VERSION,\n  prog,    // CLI program name\n  cliopts, // parsed command-line options\n  cliargs, // command-line arguments left after parsing options\n\n  // functions\n  dirname,   // from NodeJS's \"path\" module\n  basename,  // from NodeJS's \"path\" module\n  watch,\n  watchdir: legacy_watchdir,\n  scandir,\n  tslint,\n  defaultTSRules,\n  termStyle,\n  stdoutStyle: style,\n  stderrStyle: stderrStyle,\n  chmod: file.chmod,\n  editFileMode: file.editMode,\n  fmtDuration,\n  tildePath,\n  findInPATH,\n  tsconfig: tsutil.getTSConfigForConfig,\n  tsconfigFile: tsutil.getTSConfigFileForConfig,\n  glob: glob.glob,\n  globmatch: glob.match,\n  file,\n  sha1,\n  log,\n\n  // TypeScript API\n  get ts() {\n    if (_tsapiInstance === undefined) {\n      _tsapiInstance = tsapi.createTSAPI()\n    }\n    return _tsapiInstance\n  },\n\n  // ----------------------------------------------------------------------------\n  // main build function\n  // build(config :BuildConfig) :Promise<boolean>\n  build,\n}\n","// defined by esbuild, configured in build.js\ndeclare const DEBUG :boolean\ndeclare const VERSION :string\ndeclare function _runtimeRequire(id :string) :any\n\n// Mutable yields a derivative of T with readonly attributes erased\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n}\n\n// assert checks the condition for truth, and if false, prints an optional\n// message, stack trace and exits the process. assert is no-op in release builds.\nfunction assert(cond :any, msg? :string, cons? :Function) :void {\n  if (DEBUG) {\n    if (cond) {\n      return\n    }\n    const message = 'assertion failure: ' + (msg || cond)\n    const e = new Error(message)\n    e.name = \"AssertionError\"\n    const obj :any = {}\n    Error.captureStackTrace(obj, cons || assert)\n    if (obj.stack) {\n      e.stack = message + \"\\n\" + obj.stack.split(\"\\n\").slice(1).join(\"\\n\")\n    }\n    if (assert.throws) {\n      throw e\n    }\n    require(\"error\").printErrorAndExit(e, \"assert\")\n  }\n}\n\n// throws can be set to true to cause assertions to be thrown as exceptions instead\n// of printing the error and exiting the process.\nassert.throws = false\n\n;(global as any)[\"assert\"] = assert\n","import * as Path from \"path\"\n\nimport { runtimeRequire } from \"./util\"\nimport { log, LogLevel } from \"./log\"\nimport * as file from \"./file\"\nimport * as debugModule from \"./debug/debug\"\nimport * as watchModule from \"./watch/watch\"\n\nexport type DebugModule = typeof debugModule\nexport type WatchModule = typeof watchModule\n\ntype FileModule = typeof file\n\ninterface AuxModule {\n  initModule(logLevel :LogLevel, file :FileModule) :void\n}\n\n// used by tests\nlet estrellaDir = __dirname\nexport function setEstrellaDir(dir :string) {\n  estrellaDir = dir\n}\n\n\nfunction createLazyModuleAccessor<T extends AuxModule>(filename :string) :()=>T {\n  let m : T | null = null\n  return function getLazyModule() :T {\n    if (!m) {\n      log.debug(`loading ${filename} module`)\n      m = runtimeRequire(Path.join(estrellaDir, filename))\n      m!.initModule(log.level, file)\n    }\n    return m!\n  }\n}\n\nexport const debug = createLazyModuleAccessor<DebugModule>(DEBUG ? \"debug.g.js\" : \"debug.js\")\nexport const watch = createLazyModuleAccessor<WatchModule>(DEBUG ? \"watch.g.js\" : \"watch.js\")\n","import {\n  TermStyle as TermStyleAPI,\n  TermStyleFun,\n  TTYStream,\n  NoTTYStream,\n} from \"../estrella\"\n\n\nexport interface TermStyle extends TermStyleAPI {\n  _hint :boolean|undefined  // original hint\n\n  // Like calling termStyle but instead of returning a new TermStyle object,\n  // the receiver (this) is updated/mutated.\n  reconfigure(w :TTYStream|NoTTYStream, hint? :boolean) :TermStyle\n}\n\n\nfunction numColors(w :TTYStream|NoTTYStream, hint? :boolean) {\n  let ncolors = 0\n  if (hint === true) {\n    // use colors regardless of TTY or not\n    let t = process.env.TERM || \"\"\n    ncolors = (\n      t && ['xterm','screen','vt100'].some(s => t.indexOf(s) != -1) ? (\n        t.indexOf('256color') != -1 ? 8 : 4\n      ) : 2\n    )\n  } else if (hint !== false && w.isTTY) {\n    // unless hint is explicitly false, use colors if stdout is a TTY\n    ncolors = w.getColorDepth()\n  }\n  return ncolors\n}\n\ntype TermStyleFunCons = (open16 :string, open256 :string, close :string) => TermStyleFun\n\n\nexport function termStyle(w :TTYStream|NoTTYStream, hint? :boolean) :TermStyle {\n  return createTermStyle(numColors(w, hint), hint)\n}\n\n\nexport function createTermStyle(ncolors :number, hint? :boolean) :TermStyle {\n  const CODE = (s :string) => `\\x1b[${s}m`\n\n  const effect :(open :string, close :string)=>TermStyleFun = (\n    ncolors > 0 || hint ? (open, close) => {\n      const a = CODE(open), b = CODE(close)\n      return s => a + s + b\n    } :\n    (_) => s => s\n  )\n\n  const color :TermStyleFunCons = (\n\n    // 256 colors support\n    ncolors >= 8 ? (_open16, open256, close) => {\n      // const open = CODE(code), close = CODE('2' + code)\n      let a = '\\x1b[' + open256 + 'm', b = '\\x1b[' + close + 'm'\n      return s => a + s + b\n    } :\n\n    // 16 colors support\n    ncolors > 0 ? (open16, _open256, close) => {\n      let a = '\\x1b[' + open16 + 'm', b = '\\x1b[' + close + 'm'\n      return s => a + s + b\n    } :\n\n    // no colors\n    (_open16, _open256, _close) => s => s\n  )\n\n  return {\n    _hint: hint,\n    ncolors,\n\n    reset     : hint || ncolors > 0 ? \"\\e[0m\" : \"\",\n\n    bold      : effect('1', '22'),\n    italic    : effect('3', '23'),\n    underline : effect('4', '24'),\n    inverse   : effect('7', '27'),\n\n    // name           16c    256c                 close\n    white       : color('37',  '38;2;255;255;255',  '39'),\n    grey        : color('90',  '38;5;244',          '39'),\n    black       : color('30',  '38;5;16',           '39'),\n    blue        : color('34',  '38;5;75',           '39'),\n    cyan        : color('36',  '38;5;87',           '39'),\n    green       : color('32',  '38;5;84',           '39'),\n    magenta     : color('35',  '38;5;213',          '39'),\n    purple      : color('35',  '38;5;141',          '39'),\n    pink        : color('35',  '38;5;211',          '39'),\n    red         : color('31',  '38;2;255;110;80',   '39'),\n    yellow      : color('33',  '38;5;227',          '39'),\n    lightyellow : color('93',  '38;5;229',          '39'),\n    orange      : color('33',  '38;5;215',          '39'),\n\n    reconfigure(w :TTYStream|NoTTYStream, hint? :boolean) :TermStyle {\n      const ncolors = numColors(w, hint)\n      if (ncolors != this.ncolors && hint != this._hint) {\n        Object.assign(this, createTermStyle(ncolors, hint))\n      }\n      return this\n    },\n\n  }\n}\n\nexport const stdoutStyle = termStyle(process.stdout)\nexport const stderrStyle = termStyle(process.stderr)\n","import { Console } from \"console\"\nimport { stdoutStyle, stderrStyle } from \"./termstyle\"\nimport { memoize } from \"./memoize\"\nimport { prog } from \"./cli\"\nimport { captureStackTrace } from \"./error\"\n\nimport { Log as LogAPI } from \"../estrella\"\n\ndeclare const DEBUG :boolean\n\nexport interface Env {\n  log :typeof log\n}\n\nexport enum LogLevel {\n  Silent = -1,// log nothing\n  Error = 0,  // only log errors\n  Warn,       // log errors and warnings\n  Info,       // log errors, warnings and info\n  Debug,      // log everything\n}\n\nlet log_console = console\nlet log_colorMode :boolean|undefined = undefined\n\nexport const log = new class Log implements LogAPI {\n  readonly SILENT = LogLevel.Silent // = -1\n  readonly ERROR  = LogLevel.Error  // = 0\n  readonly WARN   = LogLevel.Warn   // = 1\n  readonly INFO   = LogLevel.Info   // = 2\n  readonly DEBUG  = LogLevel.Debug  // = 3\n\n  level = LogLevel.Info\n\n  error(...v :any[]) :void {\n    if (log.level >= LogLevel.Error) {\n      evalFunctionInArgs(v)\n      log_console.error(stderrStyle.red(`${prog}:`), ...v)\n    }\n  }\n  warn(...v :any[]) :void {\n    if (log.level >= LogLevel.Warn) {\n      evalFunctionInArgs(v)\n      log_console.error(stderrStyle.magenta(`${prog}:`), ...v)\n    }\n  }\n  info(...v :any[]) :void {\n    if (log.level >= LogLevel.Info) {\n      evalFunctionInArgs(v)\n      log_console.log(...v)\n    }\n  }\n\n  // DEPRECATED in Estrella 1.2.2\n  readonly infoOnce = this.info\n\n  readonly debug = log_debug\n\n  get colorMode() :boolean|undefined {\n    return log_colorMode\n  }\n  set colorMode(colorMode :boolean|undefined) {\n    if (log_colorMode === colorMode) {\n      return\n    }\n    log_colorMode = colorMode\n    if (colorMode === undefined) { // auto\n      log_console = console\n    } else {\n      log_console = new Console({\n        stdout: process.stdout,\n        stderr: process.stderr,\n        colorMode\n      })\n    }\n  }\n}\n\nexport default log\n\nfunction evalFunctionInArgs(args :any[]) {\n  // evaluate first function argument\n  if (typeof args[0] == \"function\") {\n    args[0] = args[0]()\n  }\n}\n\nfunction log_debug(...v :any[]) {\n  if (log.level >= LogLevel.Debug) {\n    let meta = \"\"\n\n    if (DEBUG) {\n      // stack traces are only useful in debug builds (not mangled)\n      const stack = captureStackTrace(log_debug)\n      const frames = stack.split(\"\\n\", 5)\n      const f = frames[1]  // stack frame\n      let m = f && /at (\\w+)/.exec(f)\n      if (m) {\n        meta = \" \" + m[1]\n      } else if (!m && frames[2]) {\n        if (m = frames[2] && /at (\\w+)/.exec(frames[2])) {\n          meta = ` ${m[1]} → ${stdoutStyle.italic(\"f\")}`\n        }\n      }\n    }\n\n    evalFunctionInArgs(v)\n\n    if (v.length == 0 || (v.length == 1 && (v[0] === \"\" || v[0] === undefined))) {\n      // Nothing to be logged.\n      // This is sometimes useful when logging something complex conditionally, for example:\n      //   log.debug(() => {\n      //     if (expensiveComputation()) {\n      //       return \"redirecting foobar to fuzlol\"\n      //     }\n      //   })\n      return\n    }\n\n    log_console.log(stdoutStyle.bold(stdoutStyle.blue(`[DEBUG${meta}]`)), ...v)\n  }\n}\n","import * as Path from \"path\"\nimport { json } from \"./util\"\n\n\n// parse CLI program name (as invoked)\nexport const prog = (() :string => {\n  const $_ = process.env[\"_\"]\n  const scriptfile = process.argv[1]\n  if (!scriptfile) {\n    // unlikely\n    return $_ || process.argv[0]\n  }\n  if ($_ && !Path.isAbsolute($_)) {\n    // accurate in some shells (like bash, but not in zsh)\n    return $_\n  }\n  let prefix = \"\"\n  if ($_) {\n    const nodeExecName = Path.basename(process.execPath)\n    if ($_.endsWith(Path.sep + nodeExecName)) {\n      // the script was invoked by explicitly calling node.\n      // e.g. \"node build.js\"\n      prefix = nodeExecName + \" \"\n    }\n  }\n  if (scriptfile.startsWith(process.cwd())) {\n    let rel = Path.relative(process.cwd(), scriptfile)\n    if (!rel.startsWith(\"node_modules\"+Path.sep) &&\n        rel.indexOf(Path.sep+\"node_modules\"+Path.sep) == -1\n    ) {\n      if (Path.sep == \"/\") {\n        // on posix systems, this is needed to avoid PATH resolution\n        rel = \"./\" + rel\n      }\n      return rel\n    }\n  }\n  return prefix + Path.basename(scriptfile)\n})()\n\n\nexport function printUsageAndExit(usage :string, errmsg? :string|null) {\n  const msg = usage.trim().replace(/\\$0\\b/g, prog)\n  if (errmsg) {\n    console.error(`${prog}: ${errmsg}\\n` + msg)\n    process.exit(1)\n  } else {\n    console.log(msg)\n    process.exit(0)\n  }\n}\n\n// parseopt types\nexport interface Doc {\n  usage?   :Usage|null\n  flags    :Flags[]\n  trailer? :string\n\n  // if true, treat an unknown flag as an argument (no error)\n  unknownFlagAsArg? :boolean\n\n  // help is a function which is invoked INSTEAD OF printing help and exiting the process.\n  // The function receives three values:\n  //   flags   -- available flags\n  //   options -- flag values parsed so far\n  //   args    -- remaining, unprocessed input arguments\n  // options and args are the same values returned by parseopt()\n  //\n  help? :( (flags: FlagInfo[], options :Options, args :string[]) => void ) | null\n}\nexport type Usage = string | (()=>string)\nexport type Flags = (Flag | null | undefined | false)[]  // falsy elements are ignored\nexport type Flag  = string | [ string|string[] , string?, string? ]\nexport interface FlagInfo {\n  names        :string[]\n  description? :string\n  valueName?   :string\n  valueType?   :string\n  valueParser? :(v:string)=>any\n}\nexport type Options = { [k :string] :any }\n\n// parseopt parses command-line arguments.\n// Returns options and unparsed remaining arguments.\n//\n// flag format:\n//\n//   flag      = flagname | flagspec\n//   flagname  = \"-\"* <text>\n//   flagnames = Array< flagname+ >\n//   flagspec  = Tuple< flagnames | flagname >\n//\n// flag format examples:\n//\n//   \"verbose\"\n//   Simple boolean flag that can be set with -verbose or --verbose.\n//\n//   [ \"v\", \"Show version\" ]\n//   Boolean flag \"v\" with description text shown in program usage.\n//\n//   [ \"v, version\", \"Show version\" ]\n//   [ [\"v\", \"version\"], \"Show version\" ]\n//   Boolean flag \"v\" with alternate name \"version\" with description.\n//\n//   [ [\"v\", \"version\"] ]\n//   Boolean flag \"v\" with alternate name \"version\" without description.\n//\n//   [ \"o\", \"Output file\", \"<path>\" ]\n//   Value flag with description. Value type defaults to string.\n//   Can be invoked as -o=path, --o=path, -o path, and --o path.\n//\n//   [ \"o\", \"\", \"<path>\" ]\n//   Value flag without description.\n//\n//   [ \"limit\", \"Show no more than <limit> items\", \"<limit:number>\" ]\n//   Value flag with type constraint. Passing a value that is not a JS number\n//   causes an error message.\n//\n//   [ \"with-openssl\", \"\", \"enable:bool\" ]\n//   Boolean flag\n//\nexport function parseopt(argv :string[], doc :Doc) :[Options, string[]] {\n  let [flagmap, opts] = parseFlags(doc.flags.filter(f => f) as Flag[])\n  let options :Options = {}\n  let help = false\n  let args :string[] = []\n  let i = 0\n\n  const eatArg = () => {\n    args.push(argv.splice(i, 1)[0])\n    i--\n  }\n\n  for (; i < argv.length; i++) {\n    // read argument\n    let arg = argv[i]\n    if (arg == '--') {\n      i++\n      break\n    }\n    if (arg[0] != '-' || arg == '-') {\n      eatArg()\n      continue\n    }\n    arg = arg.replace(/^\\-+/, '')\n    let eqp = arg.indexOf('=')\n    let argval :string|undefined = undefined\n    if (eqp != -1) {\n      // e.g. -name=value\n      argval = arg.substr(eqp + 1)\n      arg = arg.substr(0, eqp)\n    }\n\n    // lookup flag\n    let opt = flagmap.get(arg)\n    if (!opt) {\n      if (arg == \"h\" || arg == \"help\") {\n        help = true\n        if (!doc.help) {\n          console.log(fmtUsage(opts, doc.usage, doc.trailer))\n          process.exit(0)\n        }\n      } else if (doc.unknownFlagAsArg) {\n        eatArg()\n        continue\n      } else {\n        printUnknownOptionsAndExit([argv[i]])\n      }\n      break\n    }\n\n    // save option\n    let value :any = true\n    if (opt.valueName) {\n      if (argval === undefined) {\n        // -k v\n        argval = argv[i + 1]\n        if (argval !== undefined && argval[0] != \"-\") {\n          i++\n        // } else if (opt.valueType == \"boolean\") {\n        //   argval = \"true\"\n        } else {\n          console.error(`missing value for option -${arg} (see ${prog} -help)`)\n          process.exit(1)\n          break\n        }\n      } // else -k=v\n      try {\n        value = opt.valueParser ? opt.valueParser(argval) : argval\n      } catch (err) {\n        console.error(`invalid value for option -${arg} (${err.message})`)\n      }\n    } else if (argval !== undefined) {\n      console.error(`unexpected value provided for flag -${arg}`)\n      process.exit(1)\n    } // else: e.g. -k\n\n    options[arg] = value\n\n    // alias spread\n    for (let alias of opt.names) {\n      if (alias == arg) {\n        continue\n      }\n      options[alias] = value\n    }\n\n  } // for (; i < argv.length; i++)\n\n  if (i < argv.length) {\n    args = args.concat(argv.slice(i))\n  }\n\n  if (help && doc.help) {\n    doc.help(opts, options, args)\n  }\n\n  return [options, args]\n}\n\n\nexport function printUnknownOptionsAndExit(args :string[]) {\n  console.error(\n    `unknown option${args.length > 1 ? \"s\" : \"\"} ${args.join(\", \")} (see ${prog} -help)`)\n  process.exit(1)\n}\n\n\n// parseFlags parses falgs and returns normalized structured options.\n// Returns:\n//   [0] Mapping of argument name (e.g. \"help\") to options.\n//   [1] Unique set of options (e.g. {flags:[\"h\",\"help\"],...}).\n//\nexport function parseFlags(flags :Flag[]) :[ Map<string,FlagInfo>, FlagInfo[] ] {\n  let fimap = new Map<string,FlagInfo>()\n  let fiv :FlagInfo[] = []\n  for (let f of flags) {\n    let fi = parseFlag(f)\n    fiv.push(fi)\n    for (let k of fi.names) {\n      if (fimap.has(k)) {\n        throw new Error(`duplicate CLI flag ${json(k)} in definition ${json(f)}`)\n      }\n      fimap.set(k, fi)\n    }\n  }\n  return [fimap, fiv]\n}\n\n\nfunction parseFlag(f :Flag) :FlagInfo {\n  const cleanFlag = (s :string) => s.replace(/(?:^|[\\s,])\\-+/g, '')\n  const splitComma = (s :string) => s.split(/\\s*,\\s*/)\n\n  if (typeof f == \"string\") {\n    return { names: splitComma(cleanFlag(f)) }\n  }\n\n  let o :FlagInfo = {\n    names: (\n      typeof f[0] == \"string\" ? splitComma(cleanFlag(f[0])) :\n      f[0].map(cleanFlag)\n    ),\n    description: f[1] || undefined\n  }\n\n  if (f[2]) {\n    let [name, type] = f[2].replace(/^[<>]+|[<>]+$/g, '').split(/:/, 2)\n    if (type) {\n      switch (type.toLowerCase()) {\n\n        case 'string':\n        case 'str':\n          type = 'string'\n          break\n\n        case 'bool':\n        case 'boolean':\n          type = 'boolean'\n          o.valueParser = s => {\n            s = s.toLowerCase()\n            return s != \"false\" && s != \"0\" && s != \"no\" && s != \"off\"\n          }\n          break\n\n        case 'number':\n        case 'num':\n        case 'float':\n        case 'int':\n          type = 'number'\n          o.valueParser = s => {\n            let n = Number(s)\n            if (isNaN(n)) {\n              throw new Error(`${json(s)} is not a number`)\n            }\n            return n\n          }\n          break\n\n        default:\n          throw new Error(`invalid argument type \"${type}\"`)\n      }\n    } else {\n      type = \"string\"\n    }\n    o.valueName = name || type\n    o.valueType = type\n  }\n  return o\n}\n\n\nexport function fmtUsage(opts :FlagInfo[], usage? :Usage|null, trailer? :string) :string {\n  // s/$name/value/\n  let vars :{[k:string]:any} = {\n    prog: prog,\n    \"0\": prog,\n  }\n  const subvars = (s :string) :string => s.replace(/\\$(\\w+)/g, (_, v) => {\n    let sub = vars[v]\n    if (!sub) {\n      throw new Error(`unknown variable $${v} (to print a dollar sign, use '\\\\$')`)\n    }\n    return sub\n  })\n\n  // start with usage\n  let s = subvars(\n    usage ?\n      typeof usage == 'function' ? usage() :\n                                   String(usage) :\n    opts.length > 0 ?\n      `Usage: $prog [options]` :\n      `Usage: $prog`\n  )\n\n  if (opts.length > 0) {\n    s += '\\noptions:\\n'\n    let longestFlagName = 0\n    let flagNames :string[] = []\n\n    for (let f of opts) {\n      let flagName = \"  -\" + (\n        // -f=,-file=<file>\n        f.valueName ?\n          f.names.join(\"=,-\") + \"=\" + (\n            f.valueType == \"boolean\" ? 'on|off' :\n                                       '<' + f.valueName + '>'\n          ) :\n        // -f, -file\n        f.names.join(\", -\")\n      )\n      longestFlagName = Math.max(longestFlagName, flagName.length)\n      flagNames.push(flagName)\n    }\n\n    for (let i = 0; i < opts.length; i++) {\n      let f = opts[i]\n      let names = flagNames[i]\n      let descr = f.description\n      if (!f.description) {\n        // default to \"Set flagname\" (\"Enable flagname\" for bool flags)\n        descr = f.valueType ? \"Set \" : \"Enable \" + f.names.reduce(\n          (a,s) => (s.length > a.length ? s : a), // pick longest name\n          \"\"\n        )\n      }\n      s += `${names.padEnd(longestFlagName, \" \")}  ${descr}`\n      if (i + 1 < opts.length) {\n        s += \"\\n\"\n      }\n    }\n  }\n\n  // end with trailer\n  if (trailer) {\n    s += \"\\n\" + subvars(trailer.replace(/[\\n\\s]+$/, \"\"))\n  }\n\n  return s\n}\n\n","import * as fs from \"fs\"\nimport { PathLike } from \"fs\"\nimport * as Path from \"path\"\nimport * as crypto from \"crypto\"\nimport { chmodp, Modifier as ChModModifier, editFileMode } from \"./chmod\"\nimport { clock, tildePath } from \"./util\"\nimport { stdoutStyle } from \"./termstyle\"\nimport log from \"./log\"\nimport { UserError } from \"./error\"\n\nimport { WatchOptions, file as filedecl, FileWriteOptions } from \"../estrella.d\"\n\n\nconst fsp = fs.promises\n\n// fileModificationLog contains a list of [filename,Date.now()] of files that where\n// modified through the API. This data is used by watch.\nexport const fileModificationLog :{[filename:string]:number} = {}\n\nexport function fileModificationLogAppend(filename :PathLike) {\n  // TODO figure out a way to make it not grow unbounded with variable file names\n  fileModificationLog[Path.resolve(String(filename))] = clock()\n}\n\nexport function fileWasModifiedRecentlyByUser(filename :string) {\n  const ageThreshold = 30000\n  const time = fileModificationLog[Path.resolve(filename)]\n  return time !== undefined && clock() - time <= ageThreshold\n}\n\n// trick to make TypeScript type check our definitions here against those in estrella.d.ts\nexport const _ts_check_file :typeof filedecl = file\n\n\n// file() reads all contents of a file (same as file.read)\nexport function file(filename :PathLike, options :{encoding:string,flag?:string}|string) :Promise<string>\nexport function file(filename :PathLike, options :{encoding?:null,flag?:string}) :Promise<Buffer>\nexport function file(filename :PathLike) :Promise<Buffer>\nexport function file(\n  filename: PathLike,\n  options? :{encoding?:string|null,flag?:string}|string,\n) :Promise<string|Buffer> {\n  return fsp.readFile(filename, options as any)\n}\n\nfile.editMode = editFileMode\n\n\nfile.chmod = (filename :PathLike, modifier :ChModModifier) => {\n  fileModificationLogAppend(filename)\n  return chmodp(filename, modifier)\n}\n\n\ntype ReadOptions = fs.BaseEncodingOptions & { flag?: string | number; }\n                 | BufferEncoding\n                 | null\n\nfunction read(\n  filename :PathLike,\n  options :{encoding:BufferEncoding, flag?:fs.OpenMode} | BufferEncoding\n) :Promise<string>\nfunction read(filename :PathLike,\n  options :{encoding?:null, flag?:fs.OpenMode} | null\n) :Promise<Buffer>\nfunction read(filename :PathLike) :Promise<Buffer>\nfunction read(filename :PathLike, options? :ReadOptions) :Promise<string|Buffer> {\n  return fsp.readFile(filename, options)\n}\nfile.read = read\n\n\nfunction readSync(\n  filename :PathLike,\n  options :{encoding:BufferEncoding,flag?:fs.OpenMode} | BufferEncoding\n) :string\nfunction readSync(filename :PathLike, options :{encoding?:null,flag?:fs.OpenMode} | null) :Buffer\nfunction readSync(filename :PathLike) :Buffer\nfunction readSync(filename :PathLike, options? :ReadOptions) :string|Buffer {\n  // Note: typecast of options since fs type defs for node12 are incorrect: type of flags\n  // do not list number, even though the official nodejs documentation does.\n  // https://nodejs.org/docs/latest-v12.x/api/fs.html#fs_file_system_flags\n  return fs.readFileSync(filename, options as ReadOptions&{flag?: string})\n}\nfile.readSync = readSync\n\n\nfile.stat = fsp.stat\n\n\nfunction mtime(filename :PathLike) :Promise<number|null>\nfunction mtime(...filenames :PathLike[]) :Promise<(number|null)[]>\nfunction mtime(...filenames :PathLike[]) :Promise<number|null|(number|null)[]> {\n  return Promise.all(filenames.map(filename =>\n    fsp.stat(filename).then(st => st.mtimeMs).catch(_ => null)\n  )).then(r => r.length == 1 ? r[0] : r)\n}\nfile.mtime = mtime\n\nfile.readall = (...filenames :PathLike[]) =>\n  Promise.all(filenames.map(fn => fsp.readFile(fn)))\n\nfile.readallText = (encoding :string|null|undefined, ...filenames :PathLike[]) =>\n  Promise.all(filenames.map(fn => fsp.readFile(fn, {\n    encoding: (encoding||\"utf8\") as BufferEncoding\n  })))\n\nfile.write = async (filename :PathLike, data :string|Uint8Array, options? :FileWriteOptions) => {\n  fileModificationLogAppend(filename)\n  const opt = options && typeof options == \"object\" ? options : {}\n  try {\n    await fsp.writeFile(filename, data, options)\n  } catch (err) {\n    if (!opt.mkdirOff && err.code == \"ENOENT\") {\n      await file.mkdirs(Path.dirname(String(filename)), opt.mkdirMode)\n      await fsp.writeFile(filename, data, options)\n    } else {\n      throw err\n    }\n  }\n  if (opt.log) {\n    let relpath = Path.relative(process.cwd(), String(filename))\n    if (relpath.startsWith(\"..\" + Path.sep)) {\n      relpath = tildePath(filename)\n    }\n    log.info(stdoutStyle.green(`Wrote ${relpath}`))\n  }\n}\n\nfile.writeSync = (filename :PathLike, data :string|Uint8Array, options? :FileWriteOptions) => {\n  // See note in readSync regarding the typecast\n  fileModificationLogAppend(filename)\n  fs.writeFileSync(filename, data, options as fs.WriteFileOptions)\n}\n\nfunction sha1(filename :PathLike) :Promise<Buffer>\nfunction sha1(filename :PathLike, outputEncoding :crypto.BinaryToTextEncoding) :Promise<string>\n\nfunction sha1(\n  filename :PathLike,\n  outputEncoding? :crypto.BinaryToTextEncoding,\n) :Promise<Buffer|string> {\n  return new Promise<Buffer|string>((resolve, reject) => {\n    const reader = fs.createReadStream(filename)\n    const h = crypto.createHash('sha1')\n    reader.on('error', reject)\n    reader.on('end', () => {\n      h.end()\n      resolve(outputEncoding ? h.digest(outputEncoding) : h.digest())\n    })\n    reader.pipe(h)\n  })\n}\n\nfile.sha1 = sha1\n\nfile.copy = (srcfile :PathLike, dstfile :PathLike, failIfExist? :boolean) => {\n  let mode = fs.constants.COPYFILE_FICLONE  // copy-on-write (only used if OS supports it)\n  if (failIfExist) {\n    mode |= fs.constants.COPYFILE_EXCL\n  }\n  fileModificationLogAppend(dstfile)\n  return fsp.copyFile(srcfile, dstfile, mode)\n}\n\nfile.move = (oldfile :PathLike, newfile :PathLike) => {\n  fileModificationLogAppend(newfile)\n  return fsp.rename(oldfile, newfile)\n}\n\nfile.mkdirs = (dir :PathLike, mode? :fs.Mode) :Promise<boolean> => {\n  return fsp.mkdir(dir, {recursive:true, mode}).then(s => !!s && s.length > 0)\n}\n\n\ntype LegacyWatchOptions = {\n  recursive? :boolean\n}\n\n\nexport async function scandir(\n  dir      :string|string[],\n  filter?  :RegExp|null,\n  options? :(WatchOptions & LegacyWatchOptions)|null,\n) :Promise<string[]> {\n  if (!options) { options = {} }\n  if (!fs.promises || !fs.promises.opendir) {\n    // opendir was added in node 12.12.0\n    throw new Error(`scandir not implemented for nodejs <12.12.0`) // TODO\n  }\n  const files :string[] = []\n  const visited = new Set<String>()\n\n  const maxdepth = (\n    options.recursive !== undefined ? // legacy option from estrella <=1.1\n      options.recursive ? Infinity : 0 :\n    options.depth !== undefined ? options.depth :\n    Infinity\n  )\n\n  async function visit(dir :string, reldir :string, depth :number) {\n    if (visited.has(dir)) {\n      // cycle\n      return\n    }\n    visited.add(dir)\n    const d = await fs.promises.opendir(dir)\n    // Note: d.close() is called implicitly by the iterator/generator\n    for await (const ent of d) {\n      let name = ent.name\n      if (ent.isDirectory()) {\n        if (maxdepth < depth) {\n          await visit(Path.join(dir, name), Path.join(reldir, name), depth + 1)\n        }\n      } else if (ent.isFile() || ent.isSymbolicLink()) {\n        if (filter && filter.test(name)) {\n          files.push(Path.join(reldir, name))\n        }\n      }\n    }\n  }\n\n  const dirs = Array.isArray(dir) ? dir : [dir]\n\n  return Promise.all(dirs.map(dir =>\n    visit(Path.resolve(dir), \".\", 0)\n  )).then(() => files.sort())\n}\n","import * as fs from \"fs\"\nimport { json } from \"./util\"\n\nconst chr = String.fromCharCode\nconst ord = (s :string, offs :number) => s.charCodeAt(offs || 0)\n\n\nexport type Modifier = number\n                     | string\n                     | string[]\n\n// chmod edits mode of a file (synchronous)\n// If m is a number, the mode is simply set to m.\n// If m is a string or list of strings, the mode is updated using editFileMode.\n// Returns the new mode set on file.\nexport function chmod(file :fs.PathLike, modifier :Modifier) :number {\n  if (typeof modifier == \"number\") {\n    fs.chmodSync(file, modifier)\n    return modifier\n  }\n  let mode = fs.statSync(file).mode\n  let newMode = editFileMode(mode, modifier)\n  if (mode != newMode) {\n    fs.chmodSync(file, newMode)\n  }\n  return newMode\n}\n\n// async version of chmod\nexport function chmodp(file :fs.PathLike, modifier :Modifier) :Promise<number> {\n  return new Promise<number>((resolve, reject) => {\n    if (typeof modifier == \"number\") {\n      return fs.chmod(file, modifier, err => {\n        err ? reject(err) : resolve(modifier)\n      })\n    }\n    fs.stat(file, (err, st) => {\n      if (err) return reject(err)\n      let newMode = editFileMode(st.mode, modifier)\n      if (st.mode == newMode) {\n        return resolve(newMode)\n      }\n      fs.chmod(file, newMode, err => {\n        err ? reject(err) : resolve(newMode)\n      })\n    })\n  })\n}\n\n\n// editFileMode takes a file mode (e.g. 0o764), applies modifiers and returns the resulting mode.\n// It accepts the same format as the Posix chmod program.\n// If multiple modifiers are provided, they are applied to mode in order.\n//\n// Grammar of modifier format:\n//\n//   mode   := clause [, clause ...]\n//   clause := [who ...] [action ...] action\n//   action := op [perm ...]\n//   who    := a | u | g | o\n//   op     := + | - | =\n//   perm   := r | w | x\n//\n// Examples:\n//\n//   // Set execute bit for user and group\n//   newMode = editFileMode(0o444, \"ug+x\") // => 0o554\n//\n//   // Set execute bit for user, write bit for group and remove all access for others\n//   newMode = editFileMode(0o444, \"+x,g+w,o-\") // => 0o560\n//\nexport function editFileMode(mode :number, modifier :string|string[]) :number {\n  const expectedFormat = `Expected format: [ugoa]*[+-=][rwx]+`\n\n  const err = (msg :string, m :any) =>\n    new Error(`${msg} in modifier ${json(m)}. ${expectedFormat}`)\n\n  let mods :string[] = []\n  for (let m of Array.isArray(modifier) ? modifier : [ modifier ]) {\n    mods = mods.concat(m.trim().split(/\\s*,+\\s*/))\n  }\n\n  for (let m of mods) {\n    let who :number[] = []\n    let all = false\n    let op = 0\n    let perm = 0\n\n    for (let i = 0; i < m.length; i++) {\n      let c = ord(m, i)\n      if (op == 0) {\n        switch (c) {\n          case 0x75: // u\n          case 0x67: // g\n          case 0x6F: // o\n            if (!all) {\n              who.push(c)\n            }\n            break\n          case 0x61: // a\n            who = [ 0x75, 0x67, 0x6F ]\n            all = true\n            break\n          case 0x2B: // +\n          case 0x2D: // -\n          case 0x3D: // =\n            op = c\n            break\n          default:\n            if (op == 0) {\n              throw err(`Invalid target or operation ${json(chr(c))}`, m)\n            }\n            break\n        }\n      } else {\n        switch (c) {\n          case 0x72: perm |= 0o4 ; break // r\n          case 0x77: perm |= 0o2 ; break // w\n          case 0x78: perm |= 0o1 ; break // x\n          default: throw err(`Invalid permission ${json(chr(c))}`, m)\n        }\n      }\n    }\n    if (op == 0) {\n      throw err(`Missing operation`, m)\n    }\n    if (who.length == 0) {\n      who = [ 0x75 ] // u\n    }\n    if (perm == 0) {\n      perm = 0o4 | 0o2 | 0o1\n    }\n\n    let mode2 = 0\n    for (let w of who) {\n      switch (w) {\n        case 0x75: mode2 |= (perm << 6) ; break  // u\n        case 0x67: mode2 |= (perm << 3) ; break  // g\n        case 0x6F: mode2 |= perm        ; break  // o\n      }\n    }\n    switch (op) {\n      case 0x2B: mode |= mode2 ; break  // +\n      case 0x2D: mode &= ~mode2 ; break // -\n      case 0x3D: mode = mode2 ; break   // =\n    }\n    // For debugging:\n    // console.log({\n    //   who: who.map(n => '0o' + n.toString(8)),\n    //   op: String.fromCharCode(op),\n    //   perm: '0o' + perm.toString(8),\n    // })\n  } // for each m in modifier\n  return mode\n}\n\n\ndeclare const DEBUG :boolean\n\n// lil' unit test for editFileMode\nif (DEBUG) {\n  const asserteq = require(\"assert\").strictEqual\n  const oct = (v :number) => \"0o\" + v.toString(8).padStart(3, '0')\n  //  input, modifiers, expected\n  const samples :\n    [ number, string[], number ][] = [\n    [ 0o444, [\"u+r\"],   0o444 ],\n    [ 0o444, [\"u+x\"],   0o544 ],\n    [ 0o444, [\"u+w\"],   0o644 ],\n    [ 0o444, [\"u+wx\"],  0o744 ],\n    [ 0o444, [\"u+rwx\"], 0o744 ],\n    [ 0o444, [\"u+r,u+w,u+x\"],    0o744 ],\n    [ 0o444, [\"u+r\", \"u+w,u+x\"], 0o744 ],\n    [ 0o444, [\"u+\"],    0o744 ], // no perm spec = all\n\n    [ 0o777, [\"u-r\"],   0o377 ],\n    [ 0o777, [\"u-wx\"],  0o477 ],\n    [ 0o777, [\"u-w\"],   0o577 ],\n    [ 0o777, [\"u-x\"],   0o677 ],\n    [ 0o777, [\"u-\"],    0o077 ],\n    [ 0o777, [\"u-rwx\"], 0o077 ],\n\n    [ 0o444, [\"g+r\"],   0o444 ],\n    [ 0o444, [\"g+x\"],   0o454 ],\n    [ 0o444, [\"g+w\"],   0o464 ],\n    [ 0o444, [\"g+wx\"],  0o474 ],\n    [ 0o444, [\"g+rwx\"], 0o474 ],\n    [ 0o444, [\"g+\"],    0o474 ],\n\n    [ 0o777, [\"g-r\"],   0o737 ],\n    [ 0o777, [\"g-wx\"],  0o747 ],\n    [ 0o777, [\"g-w\"],   0o757 ],\n    [ 0o777, [\"g-x\"],   0o767 ],\n    [ 0o777, [\"g-\"],    0o707 ],\n    [ 0o777, [\"g-rwx\"], 0o707 ],\n\n    [ 0o444, [\"o+r\"],   0o444 ],\n    [ 0o444, [\"o+x\"],   0o445 ],\n    [ 0o444, [\"o+w\"],   0o446 ],\n    [ 0o444, [\"o+wx\"],  0o447 ],\n    [ 0o444, [\"o+rwx\"], 0o447 ],\n    [ 0o444, [\"o+\"],    0o447 ],\n\n    [ 0o777, [\"o-r\"],   0o773 ],\n    [ 0o777, [\"o-wx\"],  0o774 ],\n    [ 0o777, [\"o-w\"],   0o775 ],\n    [ 0o777, [\"o-x\"],   0o776 ],\n    [ 0o777, [\"o-\"],    0o770 ],\n    [ 0o777, [\"o-rwx\"], 0o770 ],\n\n\n    [ 0o444, [\"ug+r\"],   0o444 ],\n    [ 0o444, [\"ug+x\"],   0o554 ],\n    [ 0o444, [\"ug+w\"],   0o664 ],\n    [ 0o444, [\"ug+wx\"],  0o774 ],\n    [ 0o444, [\"ug+rwx\"], 0o774 ],\n    [ 0o444, [\"ug+\"],    0o774 ],\n\n    [ 0o444, [\"ugo+r\"],   0o444 ],  [ 0o444, [\"a+r\"],   0o444 ],\n    [ 0o444, [\"ugo+x\"],   0o555 ],  [ 0o444, [\"a+x\"],   0o555 ],\n    [ 0o444, [\"ugo+w\"],   0o666 ],  [ 0o444, [\"a+w\"],   0o666 ],\n    [ 0o444, [\"ugo+wx\"],  0o777 ],  [ 0o444, [\"a+wx\"],  0o777 ],\n    [ 0o444, [\"ugo+rwx\"], 0o777 ],  [ 0o444, [\"a+rwx\"], 0o777 ],\n    [ 0o444, [\"ugo+\"],    0o777 ],  [ 0o444, [\"a+\"],    0o777 ],\n\n    [ 0o777, [\"ug-r\"],   0o337 ],\n    [ 0o777, [\"ug-wx\"],  0o447 ],\n    [ 0o777, [\"ug-w\"],   0o557 ],\n    [ 0o777, [\"ug-x\"],   0o667 ],\n    [ 0o777, [\"ug-\"],    0o007 ],\n    [ 0o777, [\"ug-rwx\"], 0o007 ],\n\n    [ 0o777, [\"ugo-r\"],   0o333 ],  [ 0o777, [\"a-r\"],   0o333 ],\n    [ 0o777, [\"ugo-wx\"],  0o444 ],  [ 0o777, [\"a-wx\"],  0o444 ],\n    [ 0o777, [\"ugo-w\"],   0o555 ],  [ 0o777, [\"a-w\"],   0o555 ],\n    [ 0o777, [\"ugo-x\"],   0o666 ],  [ 0o777, [\"a-x\"],   0o666 ],\n    [ 0o777, [\"ugo-\"],    0o000 ],  [ 0o777, [\"a-\"],    0o000 ],\n    [ 0o777, [\"ugo-rwx\"], 0o000 ],  [ 0o777, [\"a-rwx\"], 0o000 ],\n  ] // samples\n\n  samples.map(([input, mods, expect]) => {\n    let actual = editFileMode(input, mods)\n    asserteq(actual, expect,\n      `editFileMode(${oct(input)}, ${json(mods)}) => ` +\n      `${oct(actual)} != expected ${oct(expect)}`\n    )\n  })\n} // end of editFileMode tests\n","import * as extra from \"./extra\"\nimport { stderrStyle } from \"./termstyle\"\nimport { getModulePackageJSON } from \"./util\"\nimport * as typeinfo from \"./typeinfo\"\n\n\nexport class UserError extends Error {\n  constructor(msg :string) {\n    super(msg)\n    this.name = \"UserError\"\n  }\n}\n\n\n// captureStackTrace captures a stack trace, returning the formatted stack.\n// If sourcemap is true, then translate locations via source map (loads debug module.)\nexport function captureStackTrace(cons? :Function, sourcemap? :boolean) :string {\n  const Error_prepareStackTrace = Error.prepareStackTrace\n  if (!sourcemap) {\n    Error.prepareStackTrace = undefined\n  }\n  let stack = \"\"\n  try {\n    const e :any = {}\n    Error.captureStackTrace(e, cons)\n    // note: accessing e.stack invokes Error.prepareStackTrace so this must be done\n    // before restoring Error.prepareStackTrace\n    stack = e.stack as string\n  } finally {\n    Error.prepareStackTrace = Error_prepareStackTrace\n  }\n  return stack\n}\n\n\nexport function bugReportMessage(mode :\"confident\"|\"guess\", reportContextField? :string) {\n  return extra.debug().bugReportMessage(mode, reportContextField)\n}\n\n\nexport function printErrorAndExit(err :any, origin? :string) {\n  return extra.debug().printErrorAndExit(err, origin)\n}\n\n\n// attempt to install source-map-support just-in-time when an error occurs to avoid\n// taking the startup cost of 10-20ms for loading the source-map-support module.\nfunction Error_prepareStackTrace(error: Error, stack: NodeJS.CallSite[]) {\n  Error.prepareStackTrace = undefined\n  try {\n    extra.debug().installSourceMapSupport()\n    if (Error.prepareStackTrace !== Error_prepareStackTrace) {\n      return Error.prepareStackTrace!(error, stack)\n    }\n  } catch(_) {}\n  return error.stack || String(error)\n}\n\n\n// install process-level exception and rejection handlers\nError.prepareStackTrace = Error_prepareStackTrace\nprocess.on(\"uncaughtException\", printErrorAndExit)\nprocess.on(\"unhandledRejection\", (reason :{} | null | undefined, _promise :Promise<any>) => {\n  printErrorAndExit(reason||\"PromiseRejection\", \"unhandledRejection\")\n})\n","import { json } from \"./util\"\n\nconst memoizeMap = new Map()\n\nexport const isMemoized = Symbol(\"isMemoized\")\n\nexport function memoize(fn) {\n  return function memoizedCall(...args) {\n    let k = args.map(json).join(\"\\0\")\n    if (!memoizeMap.has(k)) {\n      const result = fn(...args)\n      memoizeMap.set(k, result)\n      return result\n    }\n    let v = memoizeMap.get(k)\n    if (v && typeof v == \"object\") {\n      v[isMemoized] = true\n    }\n    return v\n  }\n}\n","const stdoutIsTTY = !!process.stdout.isTTY\n    , stderrIsTTY = !!process.stderr.isTTY\n\nexport const screen = {\n  width: 60,\n  height: 20,\n  clear() {},\n  banner(ch) {\n    if (!ch) { ch = \"-\" }\n    return ch.repeat(Math.floor((screen.width - 1) / ch.length))\n  },\n}\n\nif (stdoutIsTTY || stderrIsTTY) {\n  const ws = (stdoutIsTTY && process.stdout) || process.stderr\n  const updateScreenSize = () => {\n    screen.width = ws.columns\n    screen.height = ws.rows\n  }\n  ws.on(\"resize\", updateScreenSize)\n  updateScreenSize()\n  screen.clear = () => {\n    // Note: \\ec is reported to not work on the KDE console Konsole.\n    // TODO: detect KDE Konsole and use \\e[2J instead\n    // Clear display: \"\\x1bc\"\n    // Clear Screen: \\x1b[{n}J clears the screen\n    //   n=0 clears from cursor until end of screen\n    //   n=1 clears from cursor to beginning of screen\n    //   n=2 clears entire screen\n    ws.write(\"\\x1bc\")\n  }\n  // Note: we can clear past rows relatively using these two functions:\n  // ws.moveCursor(0, -4)\n  // ws.clearScreenDown()\n}\n","import * as Path from \"path\"\nimport * as fs from \"fs\"\nimport { spawn } from \"child_process\"\n\nimport { json, jsonparseFile, findInPATH } from \"./util\"\nimport { stdoutStyle, stderrStyle } from \"./termstyle\"\nimport { screen } from \"./screen\"\nimport { findTSC, findTSConfigFile } from \"./tsutil\"\nimport { UserError } from \"./error\"\nimport log from \"./log\"\n\nconst { dirname, basename } = Path\n\n\n// defaultTSRules maps TS diagnostics codes to severity levels.\n// The special value IGNORE can be used to completely silence a diagnostic.\n// For diagnostic codes not listed, the default DiagnosticCategory for a\n// certain diagnostic is used.\nexport const defaultTSRules = {\n  6031: \"IGNORE\",  // starting compilation\n  6194: \"IGNORE\",  // Found N errors. Watching for file changes.\n  6133: \"WARNING\", // unused variable, parameter or import\n  2531: \"WARNING\", // Object is possibly 'null'\n  7006: \"WARNING\", // Parameter 'x' implicitly has an 'any' type.\n  7015: \"WARNING\", // Element implicitly has an 'any' type because index expression is not ...\n  7053: \"WARNING\", // Element implicitly has an 'any' type because expression of type can't be ...\n}\n\n\nconst IGNORE  = 0\n    , INFO    = 1\n    , WARNING = 2\n    , ERROR   = 3\n\n\nconst severities = {IGNORE,INFO,WARNING,ERROR}\n\n\nfunction addTSRules(dst, src) {\n  for (let k of Object.keys(src)) {\n    let v = severities[String(src[k]).toUpperCase()]\n    if (v === undefined) {\n      throw new UserError(\n        `Invalid value for TS rule ${k}: ${json(v)} -- expected value to be one of: `+\n        Object.keys(severities).map(json).join(\", \")\n      )\n    }\n    dst[k] = v\n  }\n}\n\n\n// returns a promise which resolves to a boolean \"no errors\", when the TSC process ends.\n// Note that in watch mode, the promise only resolves after explicitly calling cancel.\n// The returned promise is cancellable. I.e. p.cancel()\n//\nexport function tslint(options /*:TSLintOptions*/) {\n  if (!options) { options = {} }\n  let cancellation = {\n    cancelled: false,\n    cancel(){},\n  }\n  let p = new Promise((resolve, reject) => {\n\n  if (options.mode == \"off\") {\n    return resolve(true)\n  }\n\n  const cwd = options.cwd || process.cwd()\n\n  // find tsconfig.json file\n  let tsconfigFile = options.tsconfigFile\n  if (tsconfigFile === undefined) {\n    // Note: options.tsconfigFile=null|\"\" means \"explicitly no ts config file\"\n    tsconfigFile = findTSConfigFile(options.srcdir ? Path.resolve(cwd, options.srcdir) : cwd)\n  }\n  if (options.mode != \"on\" && !tsconfigFile) {\n    // no tsconfig file found -- in auto mode, we consider this \"not a TypeScript project\".\n    return resolve(true)\n  }\n\n  const options_format = options.format ? options.format.toLowerCase() : \"\"\n  const logShortInfo    = options_format.startsWith(\"short\")\n  const logShortWarning = options_format.startsWith(\"short\")\n  const logShortError   = options_format == \"short-all\"\n\n  // find tsc program\n  let tscprog = findTSC(options.cwd /* ok if undefined */)\n  if (tscprog == \"tsc\" && options.mode != \"on\") {\n    // look up tsc in PATH\n    if (!(tscprog = findInPATH(tscprog))) {\n      // we found a tsconfig.json file but not tsc\n      log.warn(\n        `tsc not found in node_modules or PATH. However a tsconfig.json file was found in ` +\n        Path.relative(process.cwd(), dirname(tsconfigFile)) + `.` +\n        ` Set tslint options.tslint=\"off\" or pass -no-diag on the command line to disable tsc.`\n      )\n      return resolve(true)\n    }\n  }\n\n  // rules\n  const tsrules = {}\n  addTSRules(tsrules, defaultTSRules)\n  if (options.rules) {\n    addTSRules(tsrules, options.rules)\n  }\n\n  // CLI arguments\n  let args = [\n    \"--noEmit\",\n    options.colors && \"--pretty\",\n    options.watch && \"--watch\",\n    tsconfigFile && \"--project\", tsconfigFile,\n  ].concat(options.args || []).filter(a => a)\n\n  log.debug(() => `spawning process ${tscprog} ${json(args,2)}`)\n\n  // spawn tsc process\n  const p = spawn(tscprog, args, {\n    stdio: ['inherit', 'pipe', 'inherit'],\n    cwd,\n  })\n\n  // kill process on exit to avoid EPIPE errors\n  const onProcessExitHandler = () => {\n    try { p.kill() } catch (_) {}\n  }\n  process.on('exit', onProcessExitHandler)\n\n  // cancellation handler\n  cancellation.cancel = () => {\n    // called just once (guarded by user cancel function)\n    p.kill()\n  }\n\n  const infoStyle  = s => s\n      , warnStyle  = stdoutStyle.orange\n      , errorStyle = stdoutStyle.red\n      , okStyle    = stdoutStyle.green\n\n  const _TS_buf = Buffer.from(\" TS\")\n  const Found__buf = Buffer.from(\"Found \")\n  const ANSI_clear_buf = Buffer.from(\"\\x1bc\")\n  const Starting_compilation_buf = Buffer.from(\"tarting compilation\")\n  const Starting_incremental_compilation_buf = Buffer.from(\"tarting incremental compilation\")\n\n  const tsmsgbuf = []\n  let tscode = 0\n  let lastRunHadErrors = false\n  let stats = {\n    errors: 0,\n    warnings: 0,\n    other: 0,\n    reset() {\n      this.errors = 0\n      this.warnings = 0\n      this.other = 0\n    },\n  }\n\n  let isIdle = false\n\n\n  function onSessionEnd() {\n    if (!options.quiet || stats.errors >= 0) {\n      options.watch && console.log(screen.banner(\"—\"))\n      let summary = []\n      if (stats.errors > 0) {\n        summary.push(errorStyle(\"TS: \" + plural(`$ error`, `$ errors`, stats.errors)))\n      } else {\n        summary.push(okStyle(\"TS: OK\"))\n      }\n      if (stats.warnings > 0) {\n        summary.push(warnStyle(plural(`$ warning`, `$ warnings`, stats.warnings)))\n      }\n      if (stats.other > 0) {\n        summary.push(plural(`$ message`, `$ messages`, stats.other))\n      }\n      console.log(summary.join(\"   \"))\n      options.watch && console.log(screen.banner(\"—\"))\n    }\n    lastRunHadErrors = stats.errors > 0\n    options.onEnd && options.onEnd(stats)\n    stats.reset()\n    isIdle = true\n  }\n\n\n  // called when tsmsgbuf contains one or more lines of one TypeScript message.\n  function flushTSMessage(compilationPassCompleted) {\n    // console.log(`------------------- TS${tscode} ------------------`)\n    // console.log({ tsmsgbuf: tsmsgbuf.map(b => b.toString(\"utf8\")) })\n\n    // reset buffer\n    let lines = tsmsgbuf.slice()\n    tsmsgbuf.length = 0\n\n    if (tscode == 0) {\n\n      // pick the first non-empty line\n      let i = 0\n      let line0 = lines[i++]\n      while (line0.length == 0 || line0[0] == 0x0A && i < lines.length) {\n        line0 = lines[i++]\n      }\n\n      // check if the line is the \"starting\" message\n      if (line0.includes(Starting_compilation_buf) ||\n          line0.includes(Starting_incremental_compilation_buf)\n      ) {\n        stats.reset()\n        // ignore \"Starting compilation [in watch mode...]\" message\n        // alt spelling in more recent typescript versions:\n        //   \"Starting incremental compilation...\"\n        return compilationPassCompleted && onSessionEnd()\n      }\n\n      if (lines.every(line => line.length <= 1)) {\n        // ignore empty message\n        return compilationPassCompleted && onSessionEnd()\n      }\n    } else {\n      const errorRe = /(?:\\x1b\\[\\d+m|)error(?:\\x1b\\[\\d+m|)/g\n      let line0 = lines.shift().toString(\"utf8\")\n      // console.log(\"TSLINT\", {line0, tscode, sev: tsrules[tscode]})\n\n      switch (tsrules[tscode]) {\n        case IGNORE: return compilationPassCompleted && onSessionEnd()\n\n        case INFO:\n          // rewrite potentially ANSI-colored first line \"error\"\n          line0 = line0.replace(errorRe, infoStyle(\"info\"))\n          if (logShortInfo) {\n            lines = []\n          } else {\n            restyleSrcLineWaves(lines, infoStyle)\n          }\n          stats.other++\n          break\n\n        case WARNING:\n          // rewrite potentially ANSI-colored first line \"error\"\n          line0 = line0.replace(errorRe, warnStyle(\"warning\"))\n          if (logShortWarning) {\n            lines = []\n          } else {\n            restyleSrcLineWaves(lines, warnStyle)\n          }\n          stats.warnings++\n          break\n\n        default: // ERROR or other\n          if (logShortError) {\n            lines = []\n          }\n          if (errorRe.test(line0)) {\n            stats.errors++\n          } else {\n            stats.other++\n          }\n          break\n      }\n      process.stdout.write(line0)\n    }\n\n    // write lines to stdout\n    lines.forEach(v => process.stdout.write(v))\n\n    compilationPassCompleted && onSessionEnd()\n  }\n\n\n  function restyleSrcLineWaves(lines, stylefn) {\n    for (let i = 1; i < lines.length; i++) {\n      let line = lines[i]\n      if (line.includes(0x7e)) { // ~\n        let s = line.toString(\"utf8\") // \"\\x1b[91m\"\n        s = s.replace(/\\x1b\\[\\d+m(\\s*~+)/g, stylefn(\"$1\"))\n        lines[i] = s  // ok to set string instead of Buffer\n      }\n    }\n  }\n\n\n  function plural(singular, plural, n) {\n    return (n == 1 ? singular : plural).replace(/\\$/g, n)\n  }\n\n  lineReader(p.stdout, (line, flush) => {\n    if (!options.clearScreen) {\n      line = stripANSIClearCode(line)\n    }\n    if (flush) {\n      if (line.length > 0) {\n        tsmsgbuf.push(line)\n      }\n      if (tsmsgbuf.length > 0) {\n        flushTSMessage()\n      }\n      return\n    }\n\n    if (isIdle && line.length > 1) {\n      // first non-empty line after isIdle state has been entered marks the start of\n      // a new session.\n      isIdle = false\n      options.onRestart && options.onRestart()\n    }\n\n    if (line.includes(Found__buf)) {\n      let s = stripANSICodesStr(line.toString(\"utf8\"))\n      if (/^(?:\\[[^\\]]+\\] |[\\d\\:PAM \\-]+|)Found \\d+ error/.test(s)) {\n        // TypeScript has completed a compilation pass\n        flushTSMessage(true)\n        tscode = 0\n        return // don't add this line to line buffer\n      } else {\n        flushTSMessage(false)\n      }\n      tscode = 0\n    } else {\n      // console.log(\"--> \" + line.subarray(0, line.length-1).toString(\"utf8\"))\n      if (line.includes(_TS_buf)) {\n        const s = line.toString(\"utf8\")\n        const m = /(?:\\x1b\\[\\d+m|)error(?:\\x1b\\[\\d+m\\x1b\\[\\d+m|) TS(\\d+)\\:/.exec(s)\n        // const m = /(?:\\x1b\\[\\d+m|)error(?:\\x1b\\[\\d+m|) TS(\\d+)\\:/.exec(s)\n        let tscode2 = m ? parseInt(m[1]) : 0\n        if (tscode2 > 0 && !isNaN(tscode2)) {\n          if (tsmsgbuf.length > 0) {\n            flushTSMessage()\n          }\n          tscode = tscode2\n        }\n      }\n    }\n    tsmsgbuf.push(line)\n  })\n\n  // lineReader(p.stderr, line => {\n  //   process.stderr.write(line)\n  // })\n\n  p.on('close', code => {\n    // console.log(`tsc exited with code ${code}`)\n    process.removeListener('exit', onProcessExitHandler)\n    resolve(!lastRunHadErrors)\n  })\n\n  function stripANSICodesStr(s) {\n    return s.replace(/\\x1b\\[\\d+m/g, \"\")\n  }\n\n  function stripANSIClearCode(buf) {\n    // strip \"clear\" ANSI code is present in buf\n    let i = buf.indexOf(ANSI_clear_buf)\n    return (\n      i == -1 ? buf :\n      i == 0 ? buf.subarray(3) :\n      Buffer.concat([buf.subarray(0,i), buf.subarray(i+3)], buf.length - 3)\n    )\n  }\n  }) // Promise\n  p.cancel = () => {\n    if (!cancellation.cancelled) {\n      cancellation.cancelled = true\n      cancellation.cancel()\n    }\n    return p\n  }\n  return p\n} // end function tslint\n\nconst emptyBuffer = Buffer.allocUnsafe(0)\n\n// TODO replace this with io.readlines\nfunction lineReader(r, onLine) {\n  let bufs = [], bufz = 0\n  const readbuf = data => {\n    let offs = 0\n    while (true) {\n      let i = data.indexOf(0x0A, offs)\n      if (i == -1) {\n        if (offs < data.length - 1) {\n          const chunk = data.subarray(offs)\n          bufs.push(chunk)\n          bufz += chunk.length\n        }\n        break\n      }\n      i++\n      let buf = data.subarray(offs, i)\n      if (bufz > 0) {\n        buf = Buffer.concat(bufs.concat(buf), bufz + buf.length)\n        bufs.length = 0\n        bufz = 0\n      }\n      onLine(buf, false)\n      offs = i\n    }\n  }\n  const flush = () => {\n    if (bufs.length > 0) {\n      onLine(Buffer.concat(bufs, bufz), true)\n    } else {\n      onLine(emptyBuffer, true)\n    }\n  }\n\n  // TEST\n  // readbuf(Buffer.from(\"hello\"))\n  // readbuf(Buffer.from(\" world\\n\"))\n  // readbuf(Buffer.from(\"How\"))\n  // readbuf(Buffer.from(\"'s \"))\n  // readbuf(Buffer.from(\"it go\"))\n  // readbuf(Buffer.from(\"ing?\\n\"))\n  // readbuf(Buffer.from(\"quite well\\nI hope!\\nBye\\n\"))\n  // readbuf(Buffer.from(\"bye.\"))\n  // flush()\n  // lineReader(0, line => {\n  //   console.log({line:line.toString(\"utf8\")})\n  // })\n\n  r.on(\"data\", readbuf)\n  r.on(\"close\", flush)\n  r.on(\"end\", flush)\n}\n","import * as Path from \"path\"\nimport * as fs from \"fs\"\nimport { CompilerOptions } from \"typescript\"\n\nimport { jsonparseFile, isWindows } from \"./util\"\nimport { BuildConfig as BuildConfigPub } from \"../estrella.d\"\nimport log from \"./log\"\n\nconst TS_CONFIG_FILE = Symbol(\"TS_CONFIG_FILE\")\nconst TS_CONFIG = Symbol(\"TS_CONFIG\")\n\ntype BuildConfig = BuildConfigPub & {\n  [TS_CONFIG]?      :CompilerOptions|null\n  [TS_CONFIG_FILE]? :string|null\n}\n\nconst { dirname, basename } = Path\n\n\nexport function findTSC(cwd :string) :string {\n  let npmPath = \"\"\n  let tmpcwd = process.cwd()\n  const exe = isWindows ? \"tsc.cmd\" : \"tsc\"\n  if (cwd) {\n    process.chdir(cwd)\n  }\n  try {\n    npmPath = require.resolve(\"typescript\")\n  } catch (_) {}\n  if (cwd) {\n    process.chdir(tmpcwd)\n  }\n  if (npmPath) {\n    const find = Path.sep + \"node_modules\" + Path.sep\n    let i = npmPath.indexOf(find)\n    if (i != -1) {\n      return Path.join(npmPath.substr(0, i + find.length - Path.sep.length), \".bin\", exe)\n    }\n  }\n  // not found in node_modules\n  return exe\n}\n\n\nexport function findTSConfigFile(dir :string, maxParentDir? :string) :string|null {\n  for (let path of searchTSConfigFile(dir, maxParentDir)) {\n    try {\n      const st = fs.statSync(path)\n      if (st.isFile()) {\n        return path\n      }\n    } catch(_) {}\n  }\n  return null\n}\n\n\nexport function* searchTSConfigFile(dir :string, maxParentDir? :string) :Generator<string> {\n  // start at dir and search for dir + tsconfig.json,\n  // moving to the parent dir until found or until parent dir is the root dir.\n  // If maxParentDir is set, then stop when reaching directory maxParentDir.\n  dir = Path.resolve(dir)\n  const root = Path.parse(dir).root\n  maxParentDir = maxParentDir ? Path.resolve(maxParentDir) : root\n  while (true) {\n    yield Path.join(dir, \"tsconfig.json\")\n    if (dir == maxParentDir) {\n      // stop. this was the last dir we were asked to search\n      break\n    }\n    dir = dirname(dir)\n    if (dir == root) {\n      // don't search \"/\"\n      break\n    }\n  }\n}\n\n\nexport function tsConfigFileSearchDirForConfig(config :BuildConfig) :string {\n  let dir = config.cwd || process.cwd()\n  if (config.entryPoints && config.entryPoints.length > 0) {\n    // TODO: pick the most specific common denominator dir path of all entryPoints\n    dir = Path.resolve(dir, Path.dirname(config.entryPoints[0]))\n  }\n  return dir\n}\n\n\nexport function getTSConfigFileForConfig(config :BuildConfig) :string|null {\n  let file = config[TS_CONFIG_FILE]\n  if (file === undefined) {\n    if (\n      config.tslint === \"off\" || config.tslint === false ||\n      config.tsc === \"off\" || config.tsc === false\n    ) {\n      file = null\n    } else {\n      let dir = tsConfigFileSearchDirForConfig(config)\n      file = findTSConfigFile(dir, config.cwd)\n    }\n    Object.defineProperty(config, TS_CONFIG_FILE, { value: file })\n  }\n  return file\n}\n\n\nexport function getTSConfigForConfig(config :BuildConfig) :CompilerOptions|null {\n  let tsconfig = config[TS_CONFIG]\n  if (tsconfig === undefined) {\n    const file = getTSConfigFileForConfig(config)\n    if (file) try {\n      tsconfig = jsonparseFile(file)\n    } catch(err) {\n      log.warn(()=> `failed to parse ${file}: ${err.stack||err}`)\n    }\n    if (!tsconfig) {\n      tsconfig = null\n    }\n    Object.defineProperty(config, TS_CONFIG, { value: tsconfig })\n  }\n  return tsconfig\n}\n\n","import * as filepath from \"path\"\nimport * as fs from \"fs\"\n\nimport { BuildResult } from \"../estrella\"\nimport { BuildConfig } from \"./config\"\nimport log from \"./log\"\nimport { repr } from \"./util\"\nimport { Cmd, startCmd } from \"./exec\"\nimport { stdoutStyle } from \"./termstyle\"\nimport * as io from \"./io\"\nimport * as signal from \"./signal\"\nimport { UserError } from \"./error\"\n\n\nlet _initialized = false\nlet _deinitialized = false\nlet _runContexts = new Set<RunContext>()\n\nfunction init() {\n  if (_initialized) { return }\n  _initialized = true\n  process.on(\"beforeExit\", exitCode      => atexit(DEBUG && `process.on beforeExit ${exitCode}`))\n  process.on(\"exit\",       exitCode      => atexit(DEBUG && `process.on exit ${exitCode}`))\n  const onsignal = (sig: NodeJS.Signals) => atexit(DEBUG && `process.on signal ${sig}`)\n  signal.addListener(\"SIGINT\", onsignal)\n  signal.addListener(\"SIGHUP\", onsignal)\n  signal.addListener(\"SIGTERM\", onsignal)\n  signal.addListener(\"SIGPIPE\", onsignal)\n}\n\n\nfunction atexit(cause :string|false) {\n  if (_deinitialized) { return }\n  _deinitialized = true\n\n  // any log messages must be sync since process is about to terminate\n  const logerr = (msg :string) => fs.writeSync((process.stderr as any).fd, msg + \"\\n\")\n\n  try {\n    // log in debug mode\n    if (DEBUG) {\n      let runningCount = 0\n      for (let ctx of _runContexts) {\n        if (ctx.cmd.running) {\n          runningCount++\n        }\n      }\n      if (runningCount > 0) {\n        logerr(`[DEBUG run.atexit] run.atexit (${cause})`)\n      }\n    }\n\n    // Send SIGTERM to any running processes.\n    // It's better to send SIGTERM than SIGKILL in this case since in almost all scenarios\n    // processes are well-behaved and won't ignore SIGTERM (forever.) On the flipside, sending\n    // SIGKILL may cause some processes to miss out on important atexit code\n    for (let ctx of _runContexts) {\n      if (ctx.cmd.running) {\n        DEBUG && logerr(`[DEBUG run.atexit] sending SIGTERM to ${ctx.cmd}`)\n        try {\n          ctx.cmd.signal(\"SIGTERM\")\n        } catch(_) {}\n      }\n    }\n\n    _runContexts.clear()\n  } catch (err) {\n    logerr(`ignoring error in run.atexit: ${err.stack||err}`)\n  }\n}\n\n\n// run.configure is called by build1 with a mutable copy of config.\n// If config.run is not falsy, this function sets up onStart and onEnd handlers on config\n// to manage execution of the build product.\nexport function configure(config :BuildConfig) {\n  if (!config.run) {\n    return\n  }\n\n  log.debug(()=> `run.configure run=${repr(config.run)}`)\n\n  const ctx = new RunContext(config)\n  _runContexts.add(ctx)\n\n  // const onStartNext = config.onStart\n  // config.onStart = async (config, changedFiles, bctx) => {\n  //   if (typeof onStartNext == \"function\") {\n  //     await onStartNext(config, changedFiles, bctx)\n  //   }\n  //   return ctx.onStartBuild(changedFiles)\n  // }\n\n  const onEndNext = config.onEnd\n  config.onEnd = async (config, buildResult, bctx) => {\n    await ctx.onEndBuild(buildResult)\n    if (typeof onEndNext == \"function\") {\n      return onEndNext(config, buildResult, bctx)\n    }\n  }\n\n  init()\n}\n\n\n// waitAll waits for all running commands to exit.\n// Returns the largest exit code (i.e. 0 if all processes exited cleanly.)\nexport function waitAll() :Promise<number> {\n  return Promise.all(\n    Array.from(_runContexts).map(ctx => ctx.cmd.promise)\n  ).then(exitCodes => exitCodes.reduce((a,c) => Math.max(a,c), 0))\n}\n\n\nclass RunContext {\n  readonly config  :Readonly<BuildConfig>\n  readonly cmd     :Cmd\n  readonly cmdname :string  // shown in logs\n\n  _logOnExit = true // state used by onEndBuild to decide if exit is logged or not\n\n  constructor(config :Readonly<BuildConfig>) {\n    this.config = config\n\n    // Create a command object with stdout and stderr forwarding (/dev/null for stdin)\n    this.cmd = new Cmd(\"\")\n    this.cmd.stdout = \"inherit\"\n    this.cmd.stderr = \"inherit\"\n    this.cmd.env[\"ESTRELLA_PATH\"] = __filename\n    this.cmd.env[\"ESTRELLA_VERSION\"] = VERSION\n\n    if (typeof config.run == \"string\") {\n      this.cmd.command = config.run\n      this.cmd.shell = true\n      this.cmdname = config.run\n\n    } else if (typeof config.run == \"boolean\") {\n      if (!config.outfile) {\n        throw new UserError(`please set config.outfile=<file> or config.run=<file>`)\n      }\n      this.cmd.command = process.execPath // node\n      this.cmd.args = [ config.outfileAbs ]\n      this.cmdname = config.outfile\n\n    } else {\n      if (!config.run || config.run.length == 0) {\n        throw new UserError(\"config.run is an empty list\")\n      }\n      this.cmd.command = config.run[0]\n      this.cmd.args = config.run.slice(1)\n      this.cmdname = config.run.join(\" \")\n      if (this.cmdname.length > 60) {\n        this.cmdname = this.cmdname.substr(0,57) + \"...\"\n      }\n    }\n  }\n\n  async onEndBuild(buildResult :BuildResult) {\n    if (buildResult.errors.length > 0) {\n      // don't start or restart a process if the build failed\n      return\n    }\n\n    // okay, let's start or restart this.cmd\n    const cmd = this.cmd\n    const style = stdoutStyle.pink\n\n    // if the program is still running, stop it first\n    const restart = cmd.running\n    if (cmd.running) {\n      this._logOnExit = false\n      log.debug(() => `Stopping ${this.cmdname} [${cmd.pid}] ...`)\n      await cmd.kill()\n    }\n\n    // start new process\n    log.debug(() => `Starting command ${repr([cmd.command, ...cmd.args])}`)\n    cmd.start()\n\n    // log info about the process starting and existing in watch mode\n    if (this.config.watch) {\n      log.info(() => style(`${restart ? \"Restarted\" : \"Running\"} ${this.cmdname} [${cmd.pid}]`))\n      this._logOnExit = true\n      cmd.promise.then(exitCode => {\n        this._logOnExit && log.info(() => style(`${this.cmdname} exited (${exitCode})`))\n      })\n    }\n  }\n}\n\n","/*\nThis module is an adoptation of Go's simple and elegant os/exec.Cmd package.\nIt provides a reliable and simple way to run sub-processes.\n\nThe API and semantics prioritize clarity & simplicity over ease.\nThere are two important members:\n\nclass Cmd(command :string, ...args :string[]) implements CmdOptions\n  Create a new command structure for running a sub-process\n\nfunction startCmd(command :string, args? :string[], options? :CmdOptions)\n  Create & start a command. Thin wrapper around new Cmd... with strong TypeScript typings.\n\n----------------------------------------------------------------------------------------------\nstartCmd examples\n\nExample: Pipe one command's output into another's input:\n  const [,{stdout:dateout}] = startCmd(\"date\", [], {stdout:\"pipe\"})\n  const [cmd, stdio] = startCmd(\"cat\", [], { stdin: dateout, stdout: \"inherit\" })\n  await cmd.wait()\n\n----------------------------------------------------------------------------------------------\nCmd examples\n\nExample: Print output of top to stdout\n  const cmd = new Cmd(\"top\")\n  cmd.stdout = process.stdout\n  await cmd.run()\n\nExample: Get output of uname -a\n  console.log(await (new Cmd(\"uname\", \"-a\")).output(\"utf8\"))\n\nExample: Provide a buffer for stdin and capture stdout as text\n  const cmd = new Cmd(\"tr\", \"[:lower:]\", \"[:upper:]\")\n  cmd.stdin = Buffer.from(\"Hello world\\n\")\n  console.log(await cmd.output(\"utf8\"))\n\nExample: Provide a file for stdin and catpure stdout as text\n  const cmd = new Cmd(\"tr\", \"[:upper:]\", \"[:lower:]\")\n  cmd.stdin = io.createFileReader(\"jokes.txt\")\n  console.log(await cmd.output(\"utf8\"))\n\nExample: Execute a command in a shell, listing the contents of a directory\n  const cmd = new Cmd(\"if [ -d . ]; then ls; fi\")\n  cmd.shell = true\n  cmd.dir = \"~\"\n  console.log(await cmd.output(\"utf8\"))\n\nExample: Pipe one command's output into another's input\n  const date = new Cmd(\"date\")\n  date.stdout = \"pipe\"\n  const { stdout: dateout } = date.start()\n  const cmd = new Cmd(\"cat\")\n  cmd.stdin = dateout\n  cmd.stdout = process.stdout\n  await cmd.run()\n\n*/\nimport * as fs from \"fs\"\nimport * as os from \"os\"\nimport * as subproc from \"child_process\"\nimport { Writable, Readable, PassThrough as PassThroughStream } from \"stream\"\n\nimport * as io from \"./io\"\nimport { createTimeout } from \"./timeout\"\nimport { repr, expandTildePath, isWindows } from \"./util\"\nimport log from \"./log\"\n\nexport interface Pipes<In=io.Writer|null, Out=io.Reader|null, Err=io.Reader|null> {\n  readonly stdin      :In   // valid if Cmd.stdin==\"pipe\"\n  readonly stdout     :Out  // valid if Cmd.stdout==\"pipe\"\n  readonly stderr     :Err  // valid if Cmd.stderr==\"pipe\"\n  readonly extraFiles :(io.Reader|io.Writer|null)[]  // where extraFiles[N]==\"pipe\"\n}\n\ninterface CmdOptions {\n  dir?         :string  // working directory. If empty, uses current working directory\n  env?         :{[name:string]:string|undefined}  // process environment\n  shell?       :boolean | string  // run command in the system-default shell\n  stdin?       :Readable | \"inherit\" | \"pipe\" | Buffer | io.Reader | null // fd 0\n  stdout?      :Writable | \"inherit\" | \"pipe\" | null // fd 1\n  stderr?      :Writable | \"inherit\" | \"pipe\" | null // fd 2\n  extraFiles?  :(Readable | \"pipe\" | null)[]  // fd 3...\n  windowsHide? :boolean\n}\n\n// startCmd launches an external command process.\n// It's a convenience function around c=new Cmd();c.start() with strengthened TypeScript types.\n//\n// Form 1/2a: When no stdio options are provided, no pipes are returned\nexport function startCmd(command :string, args? :string[]) :[Cmd]\nexport function startCmd(command :string, args :string[], options :CmdOptions & {\n  stdin?: never,\n  stdout?: never,\n  stderr?: never,\n  extraFiles? :never,\n}) :[Cmd]\n//\n// Form 1/2b: no args\nexport function startCmd(command :string, options :CmdOptions & {\n  stdin?: never,\n  stdout?: never,\n  stderr?: never,\n  extraFiles? :never,\n}) :[Cmd]\n//\n// Form 2/2a: When stdio options are provided, the pipe ends and cmd are returned as a tuple:\nexport function startCmd<\n  // at least one stdio input is defined\n  Options extends CmdOptions & (\n    { stdin:  CmdOptions[\"stdin\"] } |\n    { stdout: CmdOptions[\"stdout\"] } |\n    { stderr: CmdOptions[\"stderr\"] } |\n    { extraFiles: CmdOptions[\"extraFiles\"] }\n  ),\n  I = Options extends {stdin: \"pipe\"} ? io.Writer : null,\n  O = Options extends {stdout:\"pipe\"} ? io.Reader : null,\n  E = Options extends {stderr:\"pipe\"} ? io.Reader : null,\n>(\n  command :string,\n  args    :string[],\n  options :Options,\n) :[Cmd, Pipes<I,O,E>]\n//\n// Form 2/2b: no args\nexport function startCmd<\n  // at least one stdio input is defined\n  Options extends CmdOptions & (\n    { stdin:  CmdOptions[\"stdin\"] } |\n    { stdout: CmdOptions[\"stdout\"] } |\n    { stderr: CmdOptions[\"stderr\"] } |\n    { extraFiles: CmdOptions[\"extraFiles\"] }\n  ),\n  I = Options extends {stdin: \"pipe\"} ? io.Writer : null,\n  O = Options extends {stdout:\"pipe\"} ? io.Reader : null,\n  E = Options extends {stderr:\"pipe\"} ? io.Reader : null,\n>(\n  command :string,\n  options :Options,\n) :[Cmd, Pipes<I,O,E>]\n//\n// Implementation:\nexport function startCmd(command :string, args? :string[]|CmdOptions, options? :CmdOptions) {\n  if (!args || !Array.isArray(args)) {\n    if (args && typeof args == \"object\") {\n      options = args as CmdOptions\n    }\n    args = []\n  }\n  if (!options) {\n    options = {}\n  }\n  const cmd = new Cmd(command, ...args)\n  for (let k in options) {\n    ;(cmd as any)[k] = (options as any)[k]\n  }\n  const cmdio = cmd.start()\n  if (options && (\n    \"stdin\" in options ||\n    \"stdout\" in options ||\n    \"stderr\" in options ||\n    \"extraFiles\" in options\n  )) {\n    return [ cmd, cmdio ]\n  }\n  return cmd\n}\n\n\nconst notStartedError = \"process not started\"\n\nexport type SignalMode = \"standard\" | \"group\"\n\n\n// Cmd represents an external command being prepared or run\nexport class Cmd implements Required<CmdOptions> {\n  command     :string\n  args        :string[]\n  dir         :string = \"\"  // working directory. If empty, uses current working directory\n  env         :{[name:string]:string|undefined} = {...process.env}  // process environment\n  shell       :boolean | string = false  // run command in the system-default shell\n  stdin       :Readable | \"inherit\" | \"pipe\" | Buffer | io.Reader | null = null // fd 0\n  stdout      :Writable | \"inherit\" | \"pipe\" | null = null // fd 1\n  stderr      :Writable | \"inherit\" | \"pipe\" | null = null // fd 2\n  extraFiles  :(Readable | \"pipe\" | null)[] = []  // fd 3...\n  windowsHide :boolean = true\n\n  readonly process  :subproc.ChildProcess | null = null  // underlying process\n  readonly promise  :Promise<number>  // resolves with status code when process exits\n  readonly running  :boolean = false  // true while the underlying process is running\n  readonly pid      :number = 0       // pid, valid after start() has been called\n  readonly exitCode :number = -1\n    // exit code of the exited process, or -1 if the process hasn't exited or was\n    // terminated by a signal.\n\n  constructor(command :string, ...args :string[]) {\n    this.command = command\n    this.args = args\n    this.promise = Promise.reject(new Error(notStartedError))\n    this.promise.catch(_=>{}) // avoid uncaught promise\n  }\n\n  // start launches the command process.\n  // If the process fails to launch, this function throws an error.\n  // Returns caller's end of I/O pipes. Returns null if no stdio pipes were configured.\n  // See startCmd() function as an alternative with stronger TypeScript typings.\n  start() :Pipes|null { return null } // separate impl\n\n  // run starts the specified command and waits for it to complete.\n  // Returns process exit status code.\n  run(timeout? :number) :Promise<number> {\n    this.start()\n    return this.wait(timeout)\n  }\n\n  // output runs the specified command and returns its standard output.\n  // If the program does not exit with status 0, an error is thrown.\n  output(encoding :null|undefined, timeout? :number|null) :Promise<Buffer>\n  output(encoding :BufferEncoding, timeout? :number|null) :Promise<string>\n  output(encoding? :BufferEncoding|null, timeout? :number|null) :Promise<Buffer|string> {\n    this.stdout = \"pipe\"\n    if (!this.stderr) {\n      this.stderr = \"pipe\"\n    }\n\n    const { stdout, stderr } = this.start()!\n    const stdoutBuf = io.createWriteBuffer()\n    const stderrBuf = io.createWriteBuffer()\n\n    stdout!.stream.on(\"data\", chunk => {\n      stdoutBuf.push(chunk)\n    })\n\n    if (stderr) {\n      stderr.stream.on(\"data\", chunk => {\n        stderrBuf.push(chunk)\n      })\n    }\n\n    return this.wait(timeout as number || 0).then(exitCode => {\n      if (exitCode != 0) {\n        let errstr = \"\"\n        const errbuf = stderrBuf.buffer()\n        try {\n          errstr = errbuf.toString(\"utf8\")\n        } catch (_) {\n          errstr = errbuf.toString(\"ascii\")\n        }\n        if (errstr.length > 0) {\n          errstr = \". stderr output:\\n\" + errstr\n        }\n        throw new Error(`command exited with status ${exitCode}${errstr}`)\n      }\n      const buf = stdoutBuf.buffer()\n      return encoding ? buf.toString(encoding) : buf\n    })\n  }\n\n  // wait for process to exit, with an optional timeout expressed in milliseconds.\n  // Returns the exit status. Throws TIMEOUT on timeout.\n  wait(timeout? :number, timeoutSignal? :Signal) :Promise<number> {\n    if (timeout === undefined || timeout <= 0) {\n      return this.promise\n    }\n    return this._waitTimeout(timeout, (err, _resolve, reject) => {\n      log.debug(()=>`${this} wait timeout reached; killing process`)\n      err.message = \"Cmd.wait timeout\"\n      return this.kill(timeoutSignal).then(() => reject(err))\n    })\n  }\n\n  // signal sends sig to the underlying process and returns true if sending the signal worked.\n  // mode defaults to \"standard\"\n  //\n  // If the signal is successfully sent (not neccessarily delivered) true is returned.\n  // If the process is not running, false is returned (no effect.)\n  // If the process has not been started, an exception is thrown.\n  // If the signal is not supported by the platform, an exception is thrown.\n  // If another error occur, like signalling permissions, false is returned.\n  //\n  signal(sig :Signal, mode? :SignalMode) :boolean {\n    const p = this._checkproc()\n    if (mode == \"group\") {\n      // Signalling process groups via negative pid is supported on most POSIX systems.\n      // This causes subprocesses that the command process may have started to also receive\n      // the signal.\n      try {\n        process.kill(-p.pid, sig)\n        return true\n      } catch (_) {\n        // will fail if the process is not in its own group or if its is already dead.\n        // fall through to \"proc\" mode:\n      }\n    }\n    return p.kill(sig)\n  }\n\n  // kill terminates the command by sending signal sig to the process and waiting for it to exit.\n  // mode defaults to \"group\".\n  //\n  // If the process has not exited within timeout milliseconds, SIGKILL is sent.\n  // The timeout should be reasonably large to allow well-behaved processed to run atexit code but\n  // small enough so that an ill-behaved process is killed within a reasonable timeframe.\n  // If timeout <= 0 then the returned promise will only resolve if and when the process exits,\n  // which could be never if the process ignores sig.\n  //\n  async kill(sig :Signal=\"SIGTERM\", timeout :number=500, mode? :SignalMode) :Promise<number> {\n    const p = this._checkproc()\n    if (!this.signal(sig, mode || \"group\")) {\n      return p.exitCode || 0\n    }\n    if (timeout <= 0) {\n      return this.promise\n    }\n    return this._waitTimeout(timeout, (_, resolve) => {\n      log.debug(()=>`${this} kill timeout reached; sending SIGKILL`)\n      p.kill(\"SIGKILL\")\n      return this.promise.then(resolve)\n    })\n  }\n\n  toString() :string {\n    return this.process ? `Cmd[${this.pid}]` : \"Cmd\"\n  }\n\n  // -------- internal --------\n\n  _resolve :(exitStatus:number)=>void = ()=>{}\n  _reject  :(reason?:any)=>void = ()=>{}\n\n  _checkproc() :subproc.ChildProcess {\n    if (!this.process) {\n      throw new Error(notStartedError)\n    }\n    return this.process\n  }\n\n  _rejectAndKill(reason? :any) {\n    this._reject(reason)\n  }\n\n  _onerror = (err :Error) => {\n    log.debug(()=>`${this} error:\\n${err.stack||err}`)\n    this._reject(err)\n  }\n\n  _onexit = (code: number, signal: NodeJS.Signals) => {\n    // run after process exits\n    const cmd = this as Mutable<Cmd>\n    log.debug(()=>`${cmd} exited status=${code} signal=${signal}`)\n    cmd.running = false\n    if (code === null || signal !== null) {\n      assert(typeof signal == \"string\")\n      cmd.exitCode = -(os.constants.signals[signal] || 1)\n    } else {\n      cmd.exitCode = code || 0\n    }\n    cmd._resolve(cmd.exitCode)\n  }\n\n  // _waitTimeout starts a timer which is cancelled when the process exits.\n  // If the timer expires before the process exits, onTimeout is called with a mutable\n  // TimeoutError that you can pass to reject and a set of promise resolution functions,\n  // which control the promise returned by this function.\n  _waitTimeout(\n    timeout :number,\n    onTimeout :(\n      timeoutErr :Error,\n      resolve: (code?:number)=>void,\n      reject:  (reason?:any)=>void,\n    )=>Promise<any>,\n  ) {\n    return new Promise<number>((resolve, reject) => {\n      let timeoutOccured = false\n      this.promise.then(exitCode => {\n        if (!timeoutOccured) {\n          resolve(exitCode)\n        }\n      })\n      return createTimeout(this.promise, timeout, timeoutErr => {\n        timeoutOccured = true\n        // now, even if the process exits and calls cmd._resolve, the timeout-enabled\n        // promise returned will not resolve. Instead, we call the onTimeout handler\n        // which can take its sweet time and eventually, when it's done, call either\n        // resolve or reject.\n        onTimeout(timeoutErr, resolve as (code?:number)=>void, reject)\n      })\n    })\n  }\n}\n\n\nCmd.prototype.start = function start(this :Cmd) :Pipes|null {\n  const cmd = this as Mutable<Cmd>\n\n  if (cmd.running) {\n    throw new Error(\"start() called while command is running\")\n  }\n\n  // reset exit code\n  cmd.exitCode = -1\n\n  // create a new promise\n  cmd.promise = new Promise<number>((res,rej) => {\n    cmd._resolve = res\n    cmd._reject = rej\n  })\n\n  // configure stdin which may be a buffer\n  let stdin :Readable | \"inherit\" | \"pipe\" | null = null\n  let stdinStreamNeedsPiping :Readable | null = null\n  if (cmd.stdin instanceof Buffer) {\n    stdin = \"pipe\"\n  } else if (io.isReader(cmd.stdin)) {\n    if (typeof (cmd.stdin.stream as any).fd == \"string\") {\n      // Nodejs' child_process module can handle \"Socket\" type of streams directly.\n      // \"Socket\" really is just the name for a stream around a file descriptor.\n      stdin = cmd.stdin.stream\n    } else {\n      stdin = \"pipe\"\n      stdinStreamNeedsPiping = cmd.stdin.stream\n    }\n  } else {\n    stdin = cmd.stdin\n  }\n\n  // spawn a process\n  const spawnOptions :subproc.SpawnOptions = {\n    stdio: [\n      stdin || 'ignore',\n      (\n        cmd.stdout === process.stdout ? 1 :\n        cmd.stdout || 'ignore'\n      ),\n      (\n        cmd.stderr === process.stderr ? 2 :\n        cmd.stderr ? cmd.stderr : 'ignore'\n      ),\n      ...cmd.extraFiles\n    ],\n    cwd: cmd.dir ? expandTildePath(cmd.dir) : undefined,\n    env: cmd.env,\n    shell: cmd.shell,\n    windowsHide: cmd.windowsHide,\n\n    // On non-windows platforms, set detached so that p gets its own process group, allowing us to\n    // signal its process tree.\n    // Note that this option has a different meaning on Windows and screws with stdio inheritance.\n    detached: !isWindows,\n  }\n  // log.debug(()=> `exec spawn ${repr(cmd.command)}, ${repr(cmd.args)} ${repr(spawnOptions)}`)\n  const p = subproc.spawn(cmd.command, cmd.args, spawnOptions)\n\n  // This is a bit of a hack, working around an awkward design choice in nodejs' child_process\n  // module where spawn errors are deliberately delayed until the next runloop iteration.\n  // The effect of this choice means that we don't know if creating a new process, which is a\n  // synchronous operation, succeeded until the next runloop frame.\n  // We have one thing going for us here: p.pid is undefined when spawn failed, so we can\n  // look at p.pid to know if there will be an error event in the next runoop frame or not, but\n  // we don't know anything about the error yet; not until the next runloop frame.\n  // See https://github.com/nodejs/node/blob/v14.12.0/lib/internal/child_process.js#L379-L390\n  if (p.pid === undefined) {\n    cmd.process = null\n    cmd.pid = 0\n    // guesstimate the actual error by checking status of command file\n    const err = guessSpawnError(cmd)\n    cmd._reject(err)\n    throw err\n  }\n\n  // set process & running state\n  cmd.running = true\n  cmd.process = p\n  cmd.pid = p.pid\n\n  // attach event listeners\n  p.on(\"exit\", cmd._onexit)\n  p.on('error', cmd._reject)\n\n  log.debug(()=>`${cmd} started (${repr(cmd.command)})`)\n\n  // stdin buffer?\n  if (p.stdin) {\n    if (cmd.stdin instanceof Buffer) {\n      const r = new PassThroughStream()\n      r.end(cmd.stdin)\n      r.pipe(p.stdin)\n      p.stdin = null\n    } else if (stdinStreamNeedsPiping) {\n      stdinStreamNeedsPiping.pipe(p.stdin)\n      p.stdin = null\n    }\n  }\n\n  // if there are no pipes, return no pipes\n  if (!p.stdin && !p.stdout && !p.stderr && p.stdio.length < 4) {\n    return null\n  }\n\n  // TODO figure out how to make this properly TypeScript typed.\n  // Ideally the return type of start() should depend on the values of Cmd.std{in,out,err}\n  // but I can't figure out how to do that with TypeScript, so here we are, casting null to\n  // a non-null type, asking for trouble. All for the sake of not having to do \"!\" for every\n  // call to stdio objects returned from start()...\n  const cmdio :Pipes = {\n    stdin:      p.stdin  ? io.createWriter(p.stdin)  : null,\n    stdout:     p.stdout ? io.createReader(p.stdout) : null,\n    stderr:     p.stderr ? io.createReader(p.stderr) : null,\n    extraFiles: p.stdio.slice(3).map(stream =>\n      io.isReadableStream(stream) ? io.createReader(stream) :\n      io.isWritableStream(stream) ? io.createWriter(stream) :\n      null\n    ),\n  }\n\n  return cmdio\n}\n\n\nfunction guessSpawnError(cmd :Cmd) :Error {\n  // guesstimate the actual error by checking status of command file\n  let code = \"\"\n  let msg = \"unspecified error\"\n  if (cmd.shell == false) {\n    try {\n      fs.accessSync(cmd.dir, fs.constants.R_OK | fs.constants.X_OK)\n      const st = fs.statSync(cmd.command)\n      if ((st.mode & fs.constants.S_IFREG) == 0) {\n        // not a regular file\n        code = \"EACCES\"\n      } else {\n        // very likely some sort of I/O error\n        code = \"EIO\"\n      }\n    } catch (err) {\n      code = err.code || \"ENOENT\"\n    }\n    msg = io.errorCodeMsg(code) || msg\n  }\n  if (!code) {\n    // check dir\n    try {\n      fs.accessSync(cmd.dir, fs.constants.R_OK | fs.constants.X_OK)\n      code = \"EIO\"\n    } catch (err) {\n      code = err.code || \"ENOENT\"\n    }\n    msg = io.errorCodeMsg(code) || msg\n    if (code) {\n      msg = msg + \"; cmd.dir=\" + repr(cmd.dir)\n    }\n  }\n  if (!code) {\n    code = \"UNKNOWN\"\n  }\n  const e = new Error(`failed to spawn process ${repr(cmd.command)} (${code} ${msg})`)\n  ;(e as any).code = code\n  return e\n}\n\n\nexport type Signal = NodeJS.Signals | number\n\n\n// this function is never used but here to test the complex typescript types of spawn()\nfunction _TEST_typescript_startCmd() {\n  {\n    const _empty1 :[Cmd] =\n      startCmd(\"a\", [])\n    const _empty2 :[Cmd] =\n      startCmd(\"a\", [], { dir: \"\" })\n\n    const ____  :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", [], { stdin:null, stdout:null, stderr:\"inherit\" })\n    const ____2 :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", [], { stdin:null, stdout:null, stderr:null })\n    const ____3 :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", [], { stdin:null })\n    const ____4 :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", [], { stdout:null })\n    const ____5 :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", [], { stderr:null })\n\n    const _extraFiles :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", [], { extraFiles:[] })\n\n    const _p__  :[Cmd,Pipes<io.Writer,null,null>] =\n      startCmd(\"a\", [], { stdin:\"pipe\", stdout:null, stderr:null })\n    const _p__2 :[Cmd,Pipes<io.Writer,null,null>] =\n      startCmd(\"a\", [], { stdin:\"pipe\" })\n\n    const _pp_  :[Cmd,Pipes<io.Writer,io.Reader,null>] =\n      startCmd(\"a\", [], { stdin:\"pipe\", stdout:\"pipe\", stderr:null })\n    const _pp_2 :[Cmd,Pipes<io.Writer,io.Reader,null>] =\n      startCmd(\"a\", [], { stdin:\"pipe\", stdout:\"pipe\" })\n\n    const _ppp  :[Cmd,Pipes<io.Writer,io.Reader,io.Reader>] =\n      startCmd(\"a\", [], { stdin:\"pipe\", stdout:\"pipe\", stderr:\"pipe\" })\n\n    const __pp  :[Cmd,Pipes<null,io.Reader,io.Reader>] =\n      startCmd(\"a\", [], { stdin:null, stdout:\"pipe\", stderr:\"pipe\" })\n    const __pp2 :[Cmd,Pipes<null,io.Reader,io.Reader>] =\n      startCmd(\"a\", [], { stdout:\"pipe\", stderr:\"pipe\" })\n\n    const _p_p  :[Cmd,Pipes<io.Writer,null,io.Reader>] =\n      startCmd(\"a\", [], { stdin:\"pipe\", stdout:null, stderr:\"pipe\" })\n    const _p_p2 :[Cmd,Pipes<io.Writer,null,io.Reader>] =\n      startCmd(\"a\", [], { stdin:\"pipe\",              stderr:\"pipe\" })\n\n    const ___p  :[Cmd,Pipes<null,null,io.Reader>] =\n      startCmd(\"a\", [], { stdin:null, stdout:null, stderr:\"pipe\" })\n    const ___p2 :[Cmd,Pipes<null,null,io.Reader>] =\n      startCmd(\"a\", [], { stderr:\"pipe\" })\n  }\n\n  // ---- copy of above, but args omitted ----\n  {\n    const _empty1 :[Cmd] =\n      startCmd(\"a\")\n    const _empty2 :[Cmd] =\n      startCmd(\"a\", { dir: \"\" })\n\n    const ____  :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", { stdin:null, stdout:null, stderr:\"inherit\" })\n    const ____2 :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", { stdin:null, stdout:null, stderr:null })\n    const ____3 :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", { stdin:null })\n    const ____4 :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", { stdout:null })\n    const ____5 :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", { stderr:null })\n\n    const _extraFiles :[Cmd,Pipes<null,null,null>] =\n      startCmd(\"a\", { extraFiles:[] })\n\n    const _p__  :[Cmd,Pipes<io.Writer,null,null>] =\n      startCmd(\"a\", { stdin:\"pipe\", stdout:null, stderr:null })\n    const _p__2 :[Cmd,Pipes<io.Writer,null,null>] =\n      startCmd(\"a\", { stdin:\"pipe\" })\n\n    const _pp_  :[Cmd,Pipes<io.Writer,io.Reader,null>] =\n      startCmd(\"a\", { stdin:\"pipe\", stdout:\"pipe\", stderr:null })\n    const _pp_2 :[Cmd,Pipes<io.Writer,io.Reader,null>] =\n      startCmd(\"a\", { stdin:\"pipe\", stdout:\"pipe\" })\n\n    const _ppp  :[Cmd,Pipes<io.Writer,io.Reader,io.Reader>] =\n      startCmd(\"a\", { stdin:\"pipe\", stdout:\"pipe\", stderr:\"pipe\" })\n\n    const __pp  :[Cmd,Pipes<null,io.Reader,io.Reader>] =\n      startCmd(\"a\", { stdin:null, stdout:\"pipe\", stderr:\"pipe\" })\n    const __pp2 :[Cmd,Pipes<null,io.Reader,io.Reader>] =\n      startCmd(\"a\", { stdout:\"pipe\", stderr:\"pipe\" })\n\n    const _p_p  :[Cmd,Pipes<io.Writer,null,io.Reader>] =\n      startCmd(\"a\", { stdin:\"pipe\", stdout:null, stderr:\"pipe\" })\n    const _p_p2 :[Cmd,Pipes<io.Writer,null,io.Reader>] =\n      startCmd(\"a\", { stdin:\"pipe\",              stderr:\"pipe\" })\n\n    const ___p  :[Cmd,Pipes<null,null,io.Reader>] =\n      startCmd(\"a\", { stdin:null, stdout:null, stderr:\"pipe\" })\n    const ___p2 :[Cmd,Pipes<null,null,io.Reader>] =\n      startCmd(\"a\", { stderr:\"pipe\" })\n  }\n\n}\n","import { Writable, Readable } from \"stream\"\nimport * as fs from \"fs\"\n\nimport { TYPE } from \"./util\"\nimport * as extra from \"./extra\"\n\n\nexport function isReadableStream(s :Readable|Writable|null|undefined) :s is Readable {\n  return s && (s as any).read\n}\n\nexport function isWritableStream(s :Readable|Writable|null|undefined) :s is Writable {\n  return s && (s as any).write\n}\n\n\nexport interface Reader extends AsyncIterable<Buffer> {\n  // read data with optional size limit.\n  //\n  // size -- max number of bytes to read.\n  //   If size is not given or negative, read everything.\n  //   If size is given and the returned buffer's length is smaller than size, then\n  //   the stream has ended (EOF.)\n  //\n  // encoding -- how to decode the data into a string.\n  //   If provided, decode the read bytes as `encoding`.\n  //   Note that the size parameter always denotes bytes to read, not characters.\n  //\n  read(size? :number) :Promise<Buffer>\n  read(size :number|undefined|null, encoding :BufferEncoding) :Promise<string>\n  read(encoding :BufferEncoding) :Promise<string>\n\n  // read chunks as they arrive into the underlying buffer.\n  //\n  // Example:\n  //   for await (const chunk of r) {\n  //     console.log(chunk)  // Buffer<48 65 6c 6c 6f>\n  //   }\n  //\n  [Symbol.asyncIterator](): AsyncIterableIterator<Buffer>\n\n  // underlying nodejs stream object\n  readonly stream :Readable\n\n  readonly [TYPE] :\"Reader\"\n}\n\nexport interface Writer {\n  readonly stream :Writable\n  readonly [TYPE] :\"Writer\"\n}\n\nexport const emptyBuffer = Buffer.allocUnsafe(0)\n\n\nexport function isReader(value :any) :value is Reader {\n  return value && typeof value == \"object\" && value[TYPE] == \"Reader\"\n}\n\nexport function isWriter(value :any) :value is Writer {\n  return value && typeof value == \"object\" && value[TYPE] == \"Writer\"\n}\n\nexport function createReader(stream? :Readable|null) :Reader {\n  return stream ? new StreamReader(stream) : InvalidReader\n}\n\nexport function createWriter(stream? :Writable|null) :Writer {\n  // TODO\n  return stream ? {\n    [TYPE]: \"Writer\",\n    stream,\n  } : InvalidWriter\n}\n\nexport function createFileReader(filename :string) :Reader {\n  return new FileReader(filename)\n}\n\n\nexport const InvalidReader = new class implements Reader {\n  readonly [TYPE] = \"Reader\"\n  _E() { return new Error(\"stream not readable\") }\n  get stream() :Readable { throw this._E() }\n  [Symbol.asyncIterator]() :AsyncIterableIterator<Buffer> { throw this._E() }\n  read() { return Promise.reject(this._E()) }\n}\n\nexport const InvalidWriter = new class implements Writer {\n  readonly [TYPE] = \"Writer\"\n  _E() { return new Error(\"stream not writable\") }\n  get stream() :Writable { throw this._E() }\n}\n\n// ------------------------------------------------------------------------------------\n// Reader\n\nexport class StreamReader implements Reader {\n  readonly [TYPE] = \"Reader\"\n  readonly stream :Readable\n\n  _ended = false\n\n  constructor(stream :Readable) {\n    this.stream = stream\n    stream.pause()  // makes it possible to use read()\n    stream.once(\"end\", () => {\n      this._ended = true\n    })\n  }\n\n  [Symbol.asyncIterator]() :AsyncIterableIterator<Buffer> {\n    return this.stream[Symbol.asyncIterator]()\n  }\n\n  async read(size? :number) :Promise<Buffer>\n  async read(size :number|undefined|null, encoding :BufferEncoding) :Promise<string>\n  async read(encoding :BufferEncoding) :Promise<string>\n  async read(size? :number|null|BufferEncoding, encoding? :BufferEncoding) :Promise<Buffer|string> {\n    const stream = this.stream\n\n    // stream must be paused in order to call stream.read()\n    stream.pause()\n\n    // stream.read(size) semantics:\n    //   if size is undefined:\n    //     return any data in the internal buffer\n    //     returns null if the internal buffer is empty\n    //   else\n    //     if size bytes are available\n    //       return buffer of that length\n    //     else if EOF\n    //       return whatever is in the internal buffer\n    //     else\n    //       return null\n    //\n\n    if (typeof size == \"string\") {\n      encoding = size\n      size = Number.MAX_SAFE_INTEGER\n    } else if (size === undefined || size === null || size < 0) {\n      size = Number.MAX_SAFE_INTEGER\n    } else if (size == 0) {\n      return encoding ? \"\" : emptyBuffer\n    }\n\n    if (stream.readable) {\n      // if we are lucky, the requested amount of data is already in the stream's buffer.\n      // in the case the stream ended, pass undefined for size which causes this call to return\n      // whatever remains in the buffer.\n      let buf = stream.read(this._ended ? undefined : size)\n      if (buf) {\n        return encoding ? buf.toString(encoding) : buf\n      }\n    }\n\n    // stream ended and there is nothing else to read.\n    // Return an empty buffer\n    if (this._ended) {\n      return encoding ? \"\" : emptyBuffer\n    }\n\n    // data not yet available\n    const buffers :Buffer[] = []\n    let buffersLen = 0  // accumulative length of `buffers`\n\n    if (stream.readable) {\n      const buf = stream.read() // read what is in the buffer\n      if (buf) {\n        buffers.push(buf)\n        buffersLen += buf.length\n      }\n    }\n\n    // console.log(\n    //   `READ 2 awaiting more data`+\n    //   ` (has ${buffersLen}, want ${size == Number.MAX_SAFE_INTEGER ? \"ALL\" : size} bytes)`)\n\n    while (buffersLen < size && !this._ended) {\n      await new Promise((resolve, reject) => {\n        stream.once('error', reject)\n        stream.once('end', resolve)\n        stream.once('readable', resolve)\n      })\n\n      // read no more than what we need\n      let buf = stream.read(size - buffersLen)\n      if (!buf) {\n        // if that fails it means that the stream's buffer is smaller.\n        // retrieve whatever is in the buffer\n        buf = stream.read()\n      }\n      if (buf) {\n        buffers.push(buf)\n        buffersLen += buf.length\n      }\n    }\n\n    const buf = joinbufs(buffers)\n\n    return encoding ? buf.toString(encoding) : buf\n  }\n}\n\n\nexport class FileReader extends StreamReader {\n  constructor(filename :string) {\n    super(fs.createReadStream(filename))\n  }\n}\n\n\nexport function joinbufs(bufs :Buffer[], totalLength? :number) :Buffer {\n  return (\n    bufs.length == 0 ? emptyBuffer :\n    bufs.length == 1 ? bufs[0] :\n    Buffer.concat(bufs, totalLength)\n  )\n}\n\n\nexport type WBuf = Buffer[] & _WBuf\ninterface _WBuf {\n  buffer() :Buffer // returns everything added so far as one contiguous byte array\n}\n\nexport function createWriteBuffer() :WBuf {\n  const w = [] as any as WBuf\n  let totalLength = 0\n  const push = w.push\n  w.push = (b :Buffer) => {\n    totalLength += b.length\n    return push.call(w, b)\n  }\n  w.buffer = () => {\n    return joinbufs(w, totalLength)\n  }\n  return w\n}\n\n// readlines yields line by line while reading from source\nexport function readlines(source :AsyncIterable<Buffer>) :AsyncGenerator<Buffer,void>\n//\nexport function readlines(\n  source :AsyncIterable<Buffer>,\n  encoding :BufferEncoding,\n) :AsyncGenerator<string,void>\n//\nexport async function* readlines(\n  source :AsyncIterable<Buffer>,\n  encoding? :BufferEncoding,\n) :AsyncGenerator<Buffer|string,void> {\n  let bufs :Buffer[] = []\n  let bufz = 0\n\n  for await (const data of source) {\n    let offs = 0\n    while (true) {\n      let i = data.indexOf(0x0A, offs)\n      if (i == -1) {\n        if (offs < data.length - 1) {\n          const chunk = data.subarray(offs)\n          bufs.push(chunk)\n          bufz += chunk.length\n        }\n        break\n      }\n      i++\n      let buf = data.subarray(offs, i)\n      if (bufz > 0) {\n        buf = Buffer.concat(bufs.concat(buf), bufz + buf.length)\n        bufs.length = 0\n        bufz = 0\n      }\n      yield encoding ? buf.toString(encoding) : buf\n      offs = i\n    }\n  }\n\n  if (bufs.length > 0) {\n    // last line does not end with a line break\n    const buf = Buffer.concat(bufs, bufz)\n    yield encoding ? buf.toString(encoding) : buf\n  }\n}\n\n\n\n// -------------------------------------------------------------------------------\n\ntype LibUVErrors = extra.DebugModule[\"libuv_errors\"]\n\nexport function errorCodeMsg(errorCode :string) :string {\n  const libuv_errors = extra.debug().libuv_errors\n  return libuv_errors[errorCode as keyof LibUVErrors] || \"\"\n}\n","export function createTimeout<T>(\n  promise         :Promise<T>,\n  timeout         :number,\n  rejectOnTimeout :(e:Error)=>void,\n) :Promise<T> {\n  const timeoutTimer = setTimeout(() => {\n    const e = new Error(\"timeout\")\n    e.name = \"Timeout\"\n    rejectOnTimeout(e)\n  }, timeout)\n  return promise.then(r => {\n    clearTimeout(timeoutTimer)\n    return r\n  }, e => {\n    clearTimeout(timeoutTimer)\n    throw e\n  })\n}\n","import * as fs from \"fs\"\nimport * as os from \"os\"\n\nexport type Signal = NodeJS.Signals\nexport type SignalsListener = NodeJS.SignalsListener\n\n\ninterface ListenerEntry {\n  listeners :Set<SignalsListener>\n  rootListener :(sig :Signal)=>void\n}\n\nconst _listenermap = new Map<Signal,ListenerEntry>()\n\n// addListener registers f to be called upon receiving signal sig.\n//\n// The semantics of this function is different than process.on(sig, f): The process is always\n// terminated after all handlers have been invoked.\n//\nexport function addListener(sig :Signal, f :SignalsListener) {\n  // any log messages must be sync since process is about to terminate\n  const logerr = (msg :string) => fs.writeSync((process.stderr as any).fd, msg + \"\\n\")\n\n  let ent = _listenermap.get(sig)\n  if (ent) {\n    ent.listeners.add(f)\n  } else {\n    const listeners = new Set<SignalsListener>([f])\n    const rootListener = (sig :Signal) => {\n      // output linebreak after sigint as it is most likely from user pressing ^C in terminal\n      if (sig == \"SIGINT\") {\n        fs.writeSync(/*STDOUT*/1, \"\\n\")\n      }\n\n      // invoke all listeners\n      DEBUG && logerr(`[signal.ts] calling ${listeners.size} registered listeners`)\n      try {\n        for (let f of listeners) {\n          f(sig)\n        }\n      } catch (err) {\n        logerr(`error in signal listener: ${err.stack||err}`)\n      }\n\n      // exit process\n      process.exit(-(os.constants.signals[sig] || 1))\n\n      // // remove all listeners from process\n      // for (let [sig, ent] of _listenermap.entries()) {\n      //   process.removeListener(sig, ent.rootListener)\n      // }\n      // // Signal process again, which will cause a proper \"signal\" termination.\n      // // This may be important for a parent program running estrella.\n      // process.kill(process.pid, sig)\n    }\n    process.on(sig, rootListener)\n    _listenermap.set(sig, { rootListener, listeners })\n  }\n}\n\nexport function removeListener(sig :Signal, f :SignalsListener) {\n  const ent = _listenermap.get(sig)\n  if (ent) {\n    ent.listeners.delete(f)\n    if (ent.listeners.size == 0) {\n      _listenermap.delete(sig)\n      process.removeListener(sig, ent.rootListener)\n    }\n  }\n}\n","import { json, tildePath } from \"./util\"\nimport log from \"./log\"\nimport { TypeScriptAPI, TSInterface, TSTypeProp } from \"../estrella\"\n\n// hack to make tsc work vanilla with our weird srcdir-based tsconfig (needed for examples to work)\nimport * as TS from \"../node_modules/typescript/lib/typescript.d\"\n\n// type Program = TS.Program\ntype CompilerOptions = TS.CompilerOptions\ntype InterfaceDeclaration = TS.InterfaceDeclaration\ntype SourceFile = TS.SourceFile\n\nexport function createTSAPI(tsapi? :typeof TS) :TypeScriptAPI | null {\n  let ts = tsapi as typeof TS\n  if (!ts) {\n    // load typescript module if available, or return null\n    log.debug(\"typescript API requested; attempting to load typescript module\")\n    try {\n      const X = require  // work around an issue in esbuild with require.X()\n      ts = X(\"typescript\") as typeof TS\n      if (parseFloat(ts.versionMajorMinor) < 3.5) {\n        // typescript too old\n        log.warn(\n          `typescript ${ts.version} is too old; disabling \"ts\" API.\\n` +\n          `  You are seeing this message because you are importing the ts API.\\n` +\n          `  Either install a more recent version of typescript or remove the ts import.`\n        )\n        return null\n      }\n      log.debug(() =>\n        `loaded typescript ${ts.version} from ${tildePath(X.resolve(\"typescript\"))}`)\n    } catch (_) {\n      // API unavailable\n      log.debug(() => `failed to load typescript; module unavailable`)\n      return null\n    }\n  }\n\n  const compilerHostCache = new Map<string,[TS.CompilerHost,CompilerOptions]>()\n\n  function getCompilerHost(options: CompilerOptions) :[TS.CompilerHost,CompilerOptions] {\n    const cacheKey = json(Object.keys(options).sort().map(k => [k,options[k]]))\n    const cacheEntry = compilerHostCache.get(cacheKey)\n    if (cacheEntry) {\n      log.debug(\"ts.getCompilerHost cache hit\")\n      return cacheEntry\n    }\n    options = {\n      newLine: ts.NewLineKind.LineFeed, // TS 4.0.3 crashes if not set\n      ...options\n    }\n    const host = ts.createCompilerHost(options, /*setParentNodes*/true)\n    const result :[TS.CompilerHost,CompilerOptions] = [host, options]\n    compilerHostCache.set(cacheKey, result)\n    log.debug(\"ts.getCompilerHost cache miss\")\n    return result\n  }\n\n\n  async function parse(source :string, options?: CompilerOptions) :Promise<SourceFile>\n\n  async function parse(\n    source :{[filename:string]:string},\n    options?: CompilerOptions,\n  ) :Promise<{[filename:string]:SourceFile}>\n\n  async function parse(\n    source :string | {[filename:string]:string},\n    options?: CompilerOptions,\n  ) :Promise<SourceFile|{[filename:string]:SourceFile}> {\n    const sources = typeof source == \"string\" ? {\"/<source>/a.ts\":source} : source\n    const filenames = Object.keys(sources)\n\n    const [host, compilerOptions] = getCompilerHost(options||{})\n\n    const readFile = host.readFile\n    host.readFile = (filename: string) => {\n      // console.log(\"readFile\", filename)\n      if (filename in sources) {\n        return sources[filename]\n      }\n      return readFile(filename)\n    }\n\n    // This is SLOW. Usually around 500ms for even a single empty file\n    const prog = ts.createProgram(filenames, compilerOptions, host)\n\n    if (typeof source == \"string\") {\n      return prog.getSourceFile(filenames[0])!\n    }\n    const nodes :{[filename:string]:SourceFile} = {}\n    for (let fn of filenames) {\n      nodes[fn] = prog.getSourceFile(fn)!\n    }\n    return nodes\n  }\n\n\n  async function parseFile(srcfile :string, options?: CompilerOptions) :Promise<SourceFile> {\n    // TODO worker\n    return _parsefile(srcfile, options)\n  }\n\n\n  function _parsefile(srcfile :string, options?: CompilerOptions) :SourceFile {\n    const [host, compilerOptions] = getCompilerHost(options || {})\n    const prog = ts.createProgram([srcfile], compilerOptions, host)\n    const file = prog.getSourceFile(srcfile)\n    if (!file) {\n      throw new Error(`${srcfile}: file not found`)\n    }\n    return file\n  }\n\n\n  function interfaceInfo(\n    srcfile :string,\n    interfaceName :string,\n    options?: CompilerOptions,\n  ) :Promise<TSInterface|null> {\n    return interfacesInfo(srcfile, [interfaceName], options).then(v => v[0])\n  }\n\n  async function interfacesInfo(\n    srcfile :string,\n    interfaceNames :string[] | null,\n    options?: CompilerOptions,\n  ) :Promise<(TSInterface|null)[]> {\n    // TODO move ts to subprocess/worker\n    const file = _parsefile(srcfile, options)\n    return interfacesInfoAST(file, interfaceNames)\n  }\n\n\n  function interfacesInfoAST(\n    file :SourceFile,\n    interfaceNames :string[] | null,\n  ) :(TSInterface|null)[] {\n    const ifdecls = topLevelInterfaceDeclarations(file)\n\n    const shortCircuit = new Map<InterfaceDeclaration,TSInterface>()\n    const infov :(TSInterface|null)[] = []\n\n    for (let name of (interfaceNames || ifdecls.keys())) {\n      const node = ifdecls.get(name)\n      if (!node) {\n        infov.push(null)\n        continue\n      }\n      infov.push(createTSInterface(file, node, ifdecls, shortCircuit))\n    }\n\n    return infov\n  }\n\n\n  function createTSInterface(\n    file         :SourceFile,\n    ifnode       :InterfaceDeclaration,\n    ifdecls      :Map<string,InterfaceDeclaration>,\n    shortCircuit :Map<InterfaceDeclaration,TSInterface>,\n  ) :TSInterface {\n    const info1 = shortCircuit.get(ifnode)\n    if (info1) {\n      return info1\n    }\n\n    const info :TSInterface = {\n      heritage: [],\n      name:     ifnode.name.escapedText as string,\n      props    :{},\n      computedProps() {\n        const props :{[name:string]:TSTypeProp} = {}\n        for (let h of info.heritage) {\n          Object.assign(props, h.props)\n        }\n        Object.assign(props, info.props)\n        return props\n      },\n      lookupProp(name :string) :TSTypeProp|null {\n        let p :TSTypeProp|null = info.props[name]\n        if (!p) {\n          for (let h of info.heritage) {\n            if (p = h.lookupProp(name)) {\n              break\n            }\n          }\n        }\n        return p\n      },\n    }\n\n    shortCircuit.set(ifnode, info)\n\n    // heritage types (i.e. from \"Bar\" in \"interface Foo extends Bar\")\n    if (ifnode.heritageClauses) for (let hc of ifnode.heritageClauses) { // hc :HeritageClause\n      for (let t of hc.types) { // t :ExpressionWithTypeArguments\n        const expr = t.expression\n        if (ts.isIdentifier(expr)) {\n          const heritageNode = ifdecls.get(expr.escapedText as string)\n          if (heritageNode) {\n            info.heritage.push(createTSInterface(file, heritageNode, ifdecls, shortCircuit))\n          } // else just ignore it\n        }\n      }\n    }\n\n    // build info.props\n    ifnode.forEachChild(n => {\n      if (ts.isPropertySignature(n)) {\n        const prop = createTSTypeProp(n, file, info)\n        info.props[prop.name] = prop\n      }\n    })\n\n    return info\n  }\n\n\n  function createTSTypeProp(\n    n :TS.PropertySignature,\n    file :SourceFile,\n    parent :TSInterface,\n  ) :TSTypeProp {\n    // console.log(\"PropertySignature\", n.name.escapedText, n)\n    const pos = ts.getLineAndCharacterOfPosition(file, n.pos)\n\n    let _typestr :string|null = null\n    const _type = n.type\n    const name = propName(n.name)\n\n    const typeprop = {\n      name,\n      type: _type,\n      get typestr() :string {\n        if (_typestr === null) {\n          _typestr = _type ? fmt(_type, file) : \"any\"\n        }\n        Object.defineProperty(typeprop, \"typestr\", {enumerable:true, value:_typestr})\n        return _typestr\n      },\n      srcfile: file.fileName,\n      srcline: pos.line,\n      srccol:  pos.character,\n      parent,\n    }\n    return typeprop\n  }\n\n\n  function propName(n :TS.PropertyName) :string {\n    switch (n.kind) {\n\n    case ts.SyntaxKind.Identifier:\n    case ts.SyntaxKind.PrivateIdentifier:\n      return n.escapedText as string\n\n    case ts.SyntaxKind.StringLiteral:\n    case ts.SyntaxKind.NumericLiteral:\n      return n.text\n\n    case ts.SyntaxKind.ComputedPropertyName:\n      // TODO printer\n      return \"[computed]\"\n\n    default:\n      return \"?\"\n    }\n  }\n\n\n  // returns all top-level interface declarations in file\n  function topLevelInterfaceDeclarations(file :SourceFile) :Map<string,InterfaceDeclaration> {\n    const m = new Map<string,InterfaceDeclaration>()\n    ts.forEachChild(file, n => {\n      if (n.kind == ts.SyntaxKind.InterfaceDeclaration) {\n        m.set(\n          (n as InterfaceDeclaration).name.escapedText as string,\n          n as InterfaceDeclaration,\n        )\n      } else {\n        // console.log(\"unhandled n in switch:\", ts.SyntaxKind[n.kind])\n      }\n    })\n    return m\n  }\n\n\n  const basicPrinter = ts.createPrinter({\n    removeComments: true,\n    newLine: ts.NewLineKind.LineFeed,\n    omitTrailingSemicolon: true,\n    noEmitHelpers: true,\n  })\n\n\n  /*EXPORT*/ function fmt(node :TS.Node, file? :SourceFile) :string {\n    if (!file) {\n      // find source file by walking up the AST\n      let n = node\n      while (n.kind != ts.SyntaxKind.SourceFile) {\n        n = n.parent\n        if (!n) {\n          throw new Error(\"node without SourceFile parent (provide file to ts.fmt)\")\n        }\n      }\n      file = n as TS.SourceFile\n    }\n    return basicPrinter.printNode(ts.EmitHint.Unspecified, node, file)\n  }\n\n  return {\n    ts,\n    getCompilerHost,\n    parse,\n    parseFile,\n    interfaceInfo,\n    interfacesInfo,\n    interfacesInfoAST,\n    fmt,\n  }\n\n}\n\n// const programCache = new Map<string,Program>() // {srcfile:{options:program}}\n// function getProgram(srcfiles :string[], options: CompilerOptions) {\n//   const cacheKey = srcfiles.map(f => Path.resolve(f)).join(\":\") + \"\\n\" + (\n//     Object.keys(options).sort().map(k => `${options[k]}\\n`)\n//   )\n//   let prog = programCache.get(cacheKey)\n//   if (!prog) {\n//     prog = ts.createProgram(srcfiles, options)\n//     programCache.set(cacheKey, prog)\n//   }\n//   return prog\n// }\n","// Do not edit. Generated by build.js\n\nexport const esbuild = {\n  version:      \"0.8.25\",\n  BuildOptions: new Set([\n    \"sourcemap\"         , // boolean | 'inline' | 'external'\n    \"format\"            , // Format\n    \"globalName\"        , // string\n    \"target\"            , // string | string[]\n    \"minify\"            , // boolean\n    \"minifyWhitespace\"  , // boolean\n    \"minifyIdentifiers\" , // boolean\n    \"minifySyntax\"      , // boolean\n    \"charset\"           , // Charset\n    \"treeShaking\"       , // TreeShaking\n    \"jsxFactory\"        , // string\n    \"jsxFragment\"       , // string\n    \"define\"            , // { [key: string]: string; }\n    \"pure\"              , // string[]\n    \"avoidTDZ\"          , // boolean\n    \"keepNames\"         , // boolean\n    \"banner\"            , // string\n    \"footer\"            , // string\n    \"color\"             , // boolean\n    \"logLevel\"          , // LogLevel\n    \"errorLimit\"        , // number\n    \"bundle\"            , // boolean\n    \"splitting\"         , // boolean\n    \"outfile\"           , // string\n    \"metafile\"          , // string\n    \"outdir\"            , // string\n    \"outbase\"           , // string\n    \"platform\"          , // Platform\n    \"external\"          , // string[]\n    \"loader\"            , // { [ext: string]: Loader; }\n    \"resolveExtensions\" , // string[]\n    \"mainFields\"        , // string[]\n    \"write\"             , // boolean\n    \"tsconfig\"          , // string\n    \"outExtension\"      , // { [ext: string]: string; }\n    \"publicPath\"        , // string\n    \"inject\"            , // string[]\n    \"incremental\"       , // boolean\n    \"entryPoints\"       , // string[]\n    \"stdin\"             , // StdinOptions\n    \"plugins\"           , // Plugin[]\n  ]), // BuildOptions\n}\n\nexport const estrella = {\n  BuildConfig: new Set([\n    \"entry\"       , // string | string[]\n    \"debug\"       , // boolean\n    \"watch\"       , // boolean | WatchOptions\n    \"cwd\"         , // string\n    \"quiet\"       , // boolean\n    \"silent\"      , // boolean\n    \"clear\"       , // boolean\n    \"tslint\"      , // boolean | \"auto\" | \"on\" | \"off\" | TSLintBasicOptions\n    \"onStart\"     , // (config: Readonly<BuildConfig>, changedFiles: string[], ctx: BuildContext, esbuildOptions: any) => Promise<void> | any\n    \"onEnd\"       , // (config: Readonly<BuildConfig>, buildResult: BuildResult, ctx: BuildContext) => Promise<void> | any\n    \"outfileMode\" , // number | string | string[]\n    \"run\"         , // boolean | string | string[]\n    \"tsc\"         , // boolean | \"auto\" | \"on\" | \"off\"\n    \"tsrules\"     , // TSRules\n    \"title\"       , // string\n  ]), // BuildConfig\n}","import * as filepath from \"path\"\nimport { sha1 } from \"./hash\"\nimport { isCLI } from \"./util\"\nimport {\n  BuildConfig as UserBuildConfig,\n  BuildContext as UserBuildContext,\n} from \"../estrella.d\"\n\n\nexport interface BuildContext extends UserBuildContext {\n  addCancelCallback(f :()=>void) :void\n}\n\n\nexport interface BuildConfig extends UserBuildConfig {\n  cwd :string // never undefined\n\n  // unique but stable ID of the build, used for temp files and caching\n  readonly projectID :string\n\n  // absolute path to outfile (empty if outfile is empty)\n  readonly outfileAbs :string\n\n  setOutfile(outfile :string) :void\n\n  // Computes projectID based on current configuration and updates value of this.projectID.\n  // Depends on the following config properties:\n  // - cwd\n  // - outfile\n  // - entryPoints\n  //\n  updateProjectID() :string\n\n  // true if the build is cancelled (BuildProcess.cancel() was called)\n  buildIsCancelled :boolean\n\n  // true if outfile is a temporary file\n  outfileIsTemporary :boolean\n\n  // if true, copy outfile to stdout when it has changes\n  outfileCopyToStdout :boolean\n\n  // true if metafile is a temporary file\n  metafileIsTemporary :boolean\n}\n\nexport function createBuildConfig(userConfig :UserBuildConfig, defaultCwd :string) :BuildConfig {\n  let buildIsCancelled = false\n  let outfileIsTemporary = false\n  let outfileCopyToStdout = false\n  let metafileIsTemporary = false\n  let outfileAbs = \"\"\n\n  function computeProjectID(config :UserBuildConfig) :string {\n    const projectKey = [config.cwd, config.outfile||\"\", ...(\n      Array.isArray(config.entryPoints) ? config.entryPoints :\n      config.entryPoints ? [config.entryPoints] :\n      []\n    )].join(filepath.delimiter)\n    return base36EncodeBuf(sha1(Buffer.from(projectKey, \"utf8\")))\n  }\n\n  let projectID = \"\"\n\n  const config :BuildConfig = Object.create({\n    get outfileAbs() :string { return outfileAbs },\n\n    setOutfile(outfile :string) :void {\n      config.outfile = outfile\n      outfileAbs = (\n        outfile && outfile != \"-\" ? filepath.resolve(config.cwd, outfile) :\n        \"\"\n      )\n    },\n\n    get projectID() :string { return projectID },\n\n    updateProjectID() :string {\n      projectID = computeProjectID(config)\n      return projectID\n    },\n\n    get buildIsCancelled() :boolean { return buildIsCancelled },\n    set buildIsCancelled(y :boolean) { buildIsCancelled = y },\n\n    get outfileIsTemporary() :boolean { return outfileIsTemporary },\n    set outfileIsTemporary(y :boolean) { outfileIsTemporary = y },\n\n    get outfileCopyToStdout() :boolean { return outfileCopyToStdout },\n    set outfileCopyToStdout(y :boolean) { outfileCopyToStdout = y },\n\n    get metafileIsTemporary() :boolean { return metafileIsTemporary },\n    set metafileIsTemporary(y :boolean) { metafileIsTemporary = y },\n  })\n\n  Object.assign(config, userConfig)\n\n  config.cwd = (\n    userConfig.cwd ? filepath.resolve(userConfig.cwd) :\n    (!isCLI && process.mainModule) ? process.mainModule.path :\n    defaultCwd\n  )\n  config.setOutfile(userConfig.outfile || \"\")\n  config.updateProjectID()\n\n  return config\n}\n\n\nfunction base36EncodeBuf(buf :Buffer) {\n  let s = \"\"\n  for (let i = 0; i < buf.length; i += 4) {\n    s += buf.readUInt32LE(i).toString(36)\n  }\n  return s\n}\n","import * as crypto from \"crypto\"\n\nexport type StringEncoding = crypto.BinaryToTextEncoding\nexport type InputData      = string | NodeJS.ArrayBufferView\n\nexport function sha1(input :InputData) :Buffer\nexport function sha1(input :InputData, outputEncoding :StringEncoding) :string\n\nexport function sha1(input :InputData, outputEncoding? :StringEncoding) :Buffer|string {\n  const h = crypto.createHash('sha1').update(input)\n  return outputEncoding ? h.digest(outputEncoding) : h.digest()\n}\n"],"mappings":"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","names":[]}