{"version":3,"sources":["../src/util.js","../node_modules/picomatch/lib/constants.js","../node_modules/picomatch/lib/utils.js","../node_modules/picomatch/lib/scan.js","../node_modules/picomatch/lib/parse.js","../node_modules/picomatch/lib/picomatch.js","../node_modules/picomatch/index.js","../node_modules/readdirp/index.js","../node_modules/normalize-path/index.js","../node_modules/anymatch/index.js","../node_modules/is-extglob/index.js","../node_modules/is-glob/index.js","../node_modules/glob-parent/index.js","../node_modules/braces/lib/utils.js","../node_modules/braces/lib/stringify.js","../node_modules/is-number/index.js","../node_modules/to-regex-range/index.js","../node_modules/fill-range/index.js","../node_modules/braces/lib/compile.js","../node_modules/braces/lib/expand.js","../node_modules/braces/lib/constants.js","../node_modules/braces/lib/parse.js","../node_modules/braces/index.js","../node_modules/binary-extensions/index.js","../node_modules/is-binary-path/index.js","../node_modules/chokidar/lib/constants.js","../node_modules/chokidar/lib/nodefs-handler.js","../node_modules/chokidar/lib/fsevents-handler.js","../node_modules/chokidar/index.js","../src/watch/watch.ts","../src/log.ts","../src/termstyle.ts","../src/cli.ts","../src/extra.ts","../src/file.ts","../src/chmod.ts","../src/error.ts","../src/watch/fswatch.ts"],"sourcesContent":["import * as fs from \"fs\"\nimport * as Path from \"path\"\nimport * as os from \"os\"\nimport { performance } from \"perf_hooks\"\nimport { stdoutStyle } from \"./termstyle\"\nimport { inspect } from \"util\"\n\nexport const json = (val, pretty, showHidden) => JSON.stringify(val, showHidden, pretty)\nexport const clock = () => performance.now()\n\n// running on Windows?\nexport const isWindows = process.platform.startsWith(\"win\")\n\n// generic symbols\nexport const TYPE = Symbol(\"TYPE\")\n\n// runtimeRequire(id :string) :any\nexport function runtimeRequire(id) {\n  // _runtimeRequire is defined at compile time by build.js (== require)\n  try { return _runtimeRequire(id) } catch { return null }\n}\nruntimeRequire.resolve = id => {\n  try { return _runtimeRequire.resolve(id) } catch { return \"\" }\n}\n\n// isCLI is true if estrella is invoked directly and not imported as a module\nexport const isCLI = module.id == \".\" || process.mainModule.filename == __filename\n\n\nexport function repr(val, prettyOrOptions) {\n  let options = {\n    colors: stdoutStyle.ncolors > 0,\n  }\n  if (typeof prettyOrOptions == \"object\") {\n    options = { ...prettyOrOptions }\n  } else if (prettyOrOptions !== undefined) {\n    options.compact = !prettyOrOptions\n  }\n  return inspect(val, options)\n}\n\n\nexport function resolveModulePackageFile(moduleSpec) {\n  const mainfile = runtimeRequire.resolve(moduleSpec)\n  let dir = Path.dirname(Path.resolve(mainfile))\n  let lastdir = Path.sep // lastdir approach to support Windows (not just check for \"/\")\n  while (dir != lastdir) {\n    let pfile = Path.join(dir, \"package.json\")\n    if (fs.existsSync(pfile)) {\n      return pfile\n    }\n    dir = Path.dirname(dir)\n  }\n  throw new Error(`package.json not found for module ${moduleSpec}`)\n}\n\n\nexport function getModulePackageJSON(moduleSpec) {\n  const pfile = resolveModulePackageFile(moduleSpec)\n  return jsonparseFile(pfile)\n}\n\n\nlet _tmpdir = \"\"\n\nexport function tmpdir() {\n  if (!_tmpdir) {\n    // Some systems return paths with symlinks.\n    // esbuild does \"realpath\" on some pathnames and thus reporting with esbuild's metafile\n    // may be incorrect if this is not canonical.\n    _tmpdir = fs.realpathSync.native(os.tmpdir())\n  }\n  return _tmpdir\n}\n\n\nexport function fmtDuration(ms) {\n  return (\n    ms >= 59500 ? (ms/60000).toFixed(0) + \"min\" :\n    ms >= 999.5 ? (ms/1000).toFixed(1) + \"s\" :\n    ms.toFixed(2) + \"ms\"\n  )\n}\n\nexport function fmtByteSize(bytes) {\n  return (\n    bytes >= 1024*1000 ? (bytes/(1024*1000)).toFixed(1) + \"MB\" :\n    bytes >= 1000 ? (bytes/1024).toFixed(1) + \"kB\" :\n    bytes + \"B\"\n  )\n}\n\nexport function findInPATH(executableName) {\n  const exeFileMode = isWindows ? 0xFFFFFFFF : fs.constants.X_OK\n  const PATH = new Set((process.env.PATH || \"\").split(Path.delimiter))\n\n  for (let dir of PATH) {\n    let path = Path.join(Path.resolve(dir), executableName)\n    if (isWindows) {\n      path += \".cmd\"\n    }\n    while (true) {\n      try {\n        let st = fs.statSync(path)\n        if (st.isSymbolicLink()) {\n          path = fs.realpathSync.native(path)\n          continue // try again\n        } else if (st.isFile() && (st.mode & exeFileMode)) {\n          return path\n        }\n      } catch (_) {\n        if (isWindows && path.endsWith(\".cmd\")) {\n          path = Path.join(Path.resolve(dir), executableName) + \".exe\"\n          continue // try with .exe extension\n        }\n      }\n      break\n    }\n  }\n  return null\n}\n\n\n// jsonparse parses \"relaxed\" JSON which can be in JavaScript format\nexport function jsonparse(jsonText, filename /*optional*/) {\n  try {\n    return JSON.parse(json)\n  } catch (err) {\n    return require(\"vm\").runInNewContext(\n      '(' + jsonText + ')',\n      { /* sandbox */ },\n      { filename, displayErrors: true }\n    )\n  }\n}\n\nexport function jsonparseFile(filename) {\n  const json = fs.readFileSync(filename, \"utf8\")\n  try {\n    return jsonparse(json)\n  } catch (err) {\n    throw new Error(`failed to parse ${filename}: ${err.message || err}`)\n  }\n}\n\n\n// ~/hello => /home/user/hello\nexport function expandTildePath(path) {\n  const homedir = os.homedir()\n  if (path == \"~\") {\n    return homedir\n  }\n  if (path.startsWith(\"~\" + Path.sep)) {\n    return homedir + path.substr(1)\n  }\n  return path\n}\n\n// /home/user/hello => ~/hello\nexport function tildePath(path) {\n  const s = Path.resolve(path)\n  const homedir = os.homedir()\n  if (s.startsWith(homedir)) {\n    return \"~\" + s.substr(homedir.length)\n  }\n  return s\n}\n","'use strict';\n\nconst path = require('path');\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  SEP: path.sep,\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n","'use strict';\n\nconst path = require('path');\nconst win32 = process.platform === 'win32';\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = require('./constants');\n\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.supportsLookbehinds = () => {\n  const segs = process.version.slice(1).split('.').map(Number);\n  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {\n    return true;\n  }\n  return false;\n};\n\nexports.isWindows = options => {\n  if (options && typeof options.windows === 'boolean') {\n    return options.windows;\n  }\n  return win32 === true || path.sep === '\\\\';\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n","'use strict';\n\nconst utils = require('./utils');\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = require('./constants');\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = { value: '', depth: 0, isGlob: false };\n\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = { value: '', depth: 0, isGlob: false };\n\n      if (finished === true) continue;\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS\n        || code === CHAR_AT\n        || code === CHAR_ASTERISK\n        || code === CHAR_QUESTION_MARK\n        || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n          break;\n        }\n      }\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nmodule.exports = scan;\n","'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = (opts) => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index];\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.prev.type === 'bos' && eos()) {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance() || '';\n      } else {\n        value += advance() || '';\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = (opts) => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst path = require('path');\nconst scan = require('./scan');\nconst parse = require('./parse');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.compileRe = (parsed, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return parsed.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${parsed.output})${append}`;\n  if (parsed && parsed.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = parsed;\n  }\n\n  return regex;\n};\n\npicomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  const opts = options || {};\n  let parsed = { negated: false, fastpaths: true };\n  let prefix = '';\n  let output;\n\n  if (input.startsWith('./')) {\n    input = input.slice(2);\n    prefix = parsed.prefix = './';\n  }\n\n  if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    output = parse.fastpaths(input, options);\n  }\n\n  if (output === undefined) {\n    parsed = parse(input, options);\n    parsed.prefix = prefix + (parsed.prefix || '');\n  } else {\n    parsed.output = output;\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n","'use strict';\n\nmodule.exports = require('./lib/picomatch');\n","'use strict';\n\nconst fs = require('fs');\nconst { Readable } = require('stream');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst picomatch = require('picomatch');\n\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG = '!';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP']);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry =>\n          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n      return entry => !negative.some(f => f(entry.basename));\n    }\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      /* eslint-disable no-unused-vars */\n      fileFilter: (path) => true,\n      directoryFilter: (path) => true,\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions, ...options };\n    const { root, type } = opts;\n\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n\n    const statMethod = opts.lstat ? lstat : stat;\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\n    if (process.platform === 'win32' && stat.length === 3) {\n      this._stat = path => statMethod(path, { bigint: true });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath.resolve(root);\n    this._isDirent = ('Dirent' in fs) && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\n\n    // Launch stream with one parent, the root dir.\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const { path, depth, files = [] } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n\n            const entryType = await this._getEntryType(entry);\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n    try {\n      files = await readdir(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n    return {files, depth, path};\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath.resolve(sysPath.join(path, basename));\n      entry = {path: sysPath.relative(this._root, fullPath), fullPath, basename};\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    if (!stats) {\n      return;\n    }\n    if (stats.isFile()) {\n      return 'file';\n    }\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n    if (stats && stats.isSymbolicLink()) {\n      const full = entry.fullPath;\n      try {\n        const entryRealPath = await realpath(full);\n        const entryRealPathStats = await lstat(entryRealPath);\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n        if (entryRealPathStats.isDirectory()) {\n          const len = entryRealPath.length;\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {\n            return this._onError(new Error(\n              `Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`\n            ));\n          }\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options)\n      .on('data', entry => files.push(entry))\n      .on('end', () => resolve(files))\n      .on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\n\nmodule.exports = readdirp;\n","/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nmodule.exports = function(path, stripTrailing) {\n  if (typeof path !== 'string') {\n    throw new TypeError('expected path to be a string');\n  }\n\n  if (path === '\\\\' || path === '/') return '/';\n\n  var len = path.length;\n  if (len <= 1) return path;\n\n  // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n  var prefix = '';\n  if (len > 4 && path[3] === '\\\\') {\n    var ch = path[2];\n    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n      path = path.slice(2);\n      prefix = '//';\n    }\n  }\n\n  var segs = path.split(/[/\\\\]+/);\n  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n    segs.pop();\n  }\n  return prefix + segs.join('/');\n};\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nconst picomatch = require('picomatch');\nconst normalizePath = require('normalize-path');\n\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\nconst BANG = '!';\nconst DEFAULT_OPTIONS = {returnIndex: false};\nconst arrify = (item) => Array.isArray(item) ? item : [item];\n\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return (string) => matcher === string || glob(string);\n  }\n  if (matcher instanceof RegExp) {\n    return (string) => matcher.test(string);\n  }\n  return (string) => false;\n};\n\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n  const _path = isList ? args[0] : args;\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' +\n      Object.prototype.toString.call(_path))\n  }\n  const path = normalizePath(_path);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\nconst anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;\n  const returnIndex = opts.returnIndex || false;\n\n  // Early cache for matchers.\n  const mtchers = arrify(matchers);\n  const negatedGlobs = mtchers\n    .filter(item => typeof item === 'string' && item.charAt(0) === BANG)\n    .map(item => item.slice(1))\n    .map(item => picomatch(item, opts));\n  const patterns = mtchers.map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    }\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch.default = anymatch;\nmodule.exports = anymatch;\n","/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nmodule.exports = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n  while ((match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str))) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n","/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isExtglob = require('is-extglob');\nvar chars = { '{': '}', '(': ')', '[': ']'};\nvar strictRegex = /\\\\(.)|(^!|\\*|[\\].+)]\\?|\\[[^\\\\\\]]+\\]|\\{[^\\\\}]+\\}|\\(\\?[:!=][^\\\\)]+\\)|\\([^|]+\\|[^\\\\)]+\\))/;\nvar relaxedRegex = /\\\\(.)|(^!|[*?{}()[\\]]|\\(\\?)/;\n\nmodule.exports = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var regex = strictRegex;\n  var match;\n\n  // optionally relax regex\n  if (options && options.strict === false) {\n    regex = relaxedRegex;\n  }\n\n  while ((match = regex.exec(str))) {\n    if (match[2]) return true;\n    var idx = match.index + match[0].length;\n\n    // if an open bracket/brace/paren is escaped,\n    // set the index to the next closing character\n    var open = match[1];\n    var close = open ? chars[open] : null;\n    if (open && close) {\n      var n = str.indexOf(close, idx);\n      if (n !== -1) {\n        idx = n + 1;\n      }\n    }\n\n    str = str.slice(idx);\n  }\n  return false;\n};\n","'use strict';\n\nvar isGlob = require('is-glob');\nvar pathPosixDirname = require('path').posix.dirname;\nvar isWin32 = require('os').platform() === 'win32';\n\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\/]*.*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n */\nmodule.exports = function globParent(str, opts) {\n  var options = Object.assign({ flipBackslashes: true }, opts);\n\n  // flip windows path separators\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  }\n\n  // special case for strings ending in enclosure containing path separator\n  if (enclosure.test(str)) {\n    str += slash;\n  }\n\n  // preserves full path in case of trailing path separator\n  str += 'a';\n\n  // remove path parts that are globby\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob(str) || globby.test(str));\n\n  // remove escape chars and return result\n  return str.replace(escaped, '$1');\n};\n","'use strict';\n\nexports.isInteger = num => {\n  if (typeof num === 'number') {\n    return Number.isInteger(num);\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isInteger(Number(num));\n  }\n  return false;\n};\n\n/**\n * Find a node of the given type\n */\n\nexports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n/**\n * Find a node of the given type\n */\n\nexports.exceedsLimit = (min, max, step = 1, limit) => {\n  if (limit === false) return false;\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n  return ((Number(max) - Number(min)) / Number(step)) >= limit;\n};\n\n/**\n * Escape the given node with '\\\\' before node.value\n */\n\nexports.escapeNode = (block, n = 0, type) => {\n  let node = block.nodes[n];\n  if (!node) return;\n\n  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n    if (node.escaped !== true) {\n      node.value = '\\\\' + node.value;\n      node.escaped = true;\n    }\n  }\n};\n\n/**\n * Returns true if the given brace node should be enclosed in literal braces\n */\n\nexports.encloseBrace = node => {\n  if (node.type !== 'brace') return false;\n  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n    node.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a brace node is invalid.\n */\n\nexports.isInvalidBrace = block => {\n  if (block.type !== 'brace') return false;\n  if (block.invalid === true || block.dollar) return true;\n  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n    block.invalid = true;\n    return true;\n  }\n  if (block.open !== true || block.close !== true) {\n    block.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a node is an open or close node\n */\n\nexports.isOpenOrClose = node => {\n  if (node.type === 'open' || node.type === 'close') {\n    return true;\n  }\n  return node.open === true || node.close === true;\n};\n\n/**\n * Reduce an array of text nodes.\n */\n\nexports.reduce = nodes => nodes.reduce((acc, node) => {\n  if (node.type === 'text') acc.push(node.value);\n  if (node.type === 'range') node.type = 'text';\n  return acc;\n}, []);\n\n/**\n * Flatten an array\n */\n\nexports.flatten = (...args) => {\n  const result = [];\n  const flat = arr => {\n    for (let i = 0; i < arr.length; i++) {\n      let ele = arr[i];\n      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\n    }\n    return result;\n  };\n  flat(args);\n  return result;\n};\n","'use strict';\n\nconst utils = require('./utils');\n\nmodule.exports = (ast, options = {}) => {\n  let stringify = (node, parent = {}) => {\n    let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n    return output;\n  };\n\n  return stringify(ast);\n};\n\n","/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function(num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n  return false;\n};\n","/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst isNumber = require('is-number');\n\nconst toRegexRange = (min, max, options) => {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = { relaxZeros: true, ...options };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = { min, max, a, b };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives, opts);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return { pattern: start, count: [], digits: 0 };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit, options);\n\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let { string } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default: {\n      return relax ? `0{0,${diff}}` : `0{${diff}}`;\n    }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange.cache = {};\ntoRegexRange.clearCache = () => (toRegexRange.cache = {});\n\n/**\n * Expose `toRegexRange`\n */\n\nmodule.exports = toRegexRange;\n","/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nconst util = require('util');\nconst toRegexRange = require('to-regex-range');\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\n\nconst stringify = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? ('-' + input) : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, { wrap: false, ...options });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = { negatives: [], positives: [] };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1\n      ? toSequence(parts, options)\n      : toRegex(range, null, { wrap: false, ...options });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {\n    return invalidRange(start, end, options);\n  }\n\n\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, { wrap: false, options });\n  }\n\n  return range;\n};\n\nconst fill = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill(start, end, 1, { transform: step });\n  }\n\n  if (isObject(step)) {\n    return fill(start, end, 0, step);\n  }\n\n  let opts = { ...options };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nmodule.exports = fill;\n","'use strict';\n\nconst fill = require('fill-range');\nconst utils = require('./utils');\n\nconst compile = (ast, options = {}) => {\n  let walk = (node, parent = {}) => {\n    let invalidBlock = utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? (prefix + node.value) : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? (prefix + node.value) : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n      let range = fill(...args, { ...options, wrap: false, toRegex: true });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n    return output;\n  };\n\n  return walk(ast);\n};\n\nmodule.exports = compile;\n","'use strict';\n\nconst fill = require('fill-range');\nconst stringify = require('./stringify');\nconst utils = require('./utils');\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  let result = [];\n\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));\n      }\n    }\n  }\n  return utils.flatten(result);\n};\n\nconst expand = (ast, options = {}) => {\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  let walk = (node, parent = {}) => {\n    node.queue = [];\n\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nmodule.exports = expand;\n","'use strict';\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n\n  // Digits\n  CHAR_0: '0', /* 0 */\n  CHAR_9: '9', /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A', /* A */\n  CHAR_LOWERCASE_A: 'a', /* a */\n  CHAR_UPPERCASE_Z: 'Z', /* Z */\n  CHAR_LOWERCASE_Z: 'z', /* z */\n\n  CHAR_LEFT_PARENTHESES: '(', /* ( */\n  CHAR_RIGHT_PARENTHESES: ')', /* ) */\n\n  CHAR_ASTERISK: '*', /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&', /* & */\n  CHAR_AT: '@', /* @ */\n  CHAR_BACKSLASH: '\\\\', /* \\ */\n  CHAR_BACKTICK: '`', /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r', /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */\n  CHAR_COLON: ':', /* : */\n  CHAR_COMMA: ',', /* , */\n  CHAR_DOLLAR: '$', /* . */\n  CHAR_DOT: '.', /* . */\n  CHAR_DOUBLE_QUOTE: '\"', /* \" */\n  CHAR_EQUAL: '=', /* = */\n  CHAR_EXCLAMATION_MARK: '!', /* ! */\n  CHAR_FORM_FEED: '\\f', /* \\f */\n  CHAR_FORWARD_SLASH: '/', /* / */\n  CHAR_HASH: '#', /* # */\n  CHAR_HYPHEN_MINUS: '-', /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */\n  CHAR_LEFT_CURLY_BRACE: '{', /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */\n  CHAR_LINE_FEED: '\\n', /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0', /* \\u00A0 */\n  CHAR_PERCENT: '%', /* % */\n  CHAR_PLUS: '+', /* + */\n  CHAR_QUESTION_MARK: '?', /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}', /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */\n  CHAR_SEMICOLON: ';', /* ; */\n  CHAR_SINGLE_QUOTE: '\\'', /* ' */\n  CHAR_SPACE: ' ', /*   */\n  CHAR_TAB: '\\t', /* \\t */\n  CHAR_UNDERSCORE: '_', /* _ */\n  CHAR_VERTICAL_LINE: '|', /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n","'use strict';\n\nconst stringify = require('./stringify');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH, /* \\ */\n  CHAR_BACKTICK, /* ` */\n  CHAR_COMMA, /* , */\n  CHAR_DOT, /* . */\n  CHAR_LEFT_PARENTHESES, /* ( */\n  CHAR_RIGHT_PARENTHESES, /* ) */\n  CHAR_LEFT_CURLY_BRACE, /* { */\n  CHAR_RIGHT_CURLY_BRACE, /* } */\n  CHAR_LEFT_SQUARE_BRACKET, /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\n  CHAR_DOUBLE_QUOTE, /* \" */\n  CHAR_SINGLE_QUOTE, /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = require('./constants');\n\n/**\n * parse\n */\n\nconst parse = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = { type: 'root', input, nodes: [] };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n  let memo = {};\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({ type: 'bos' });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({ type: 'text', value: '\\\\' + value });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n\n      let closed = true;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({ type: 'paren', nodes: [] });\n      stack.push(block);\n      push({ type: 'text', value });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({ type: 'text', value });\n        continue;\n      }\n      block = stack.pop();\n      push({ type: 'text', value });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n\n      block = push(brace);\n      stack.push(block);\n      push({ type: 'open', value });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n\n      push({ type, value });\n      depth--;\n\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, { type: 'text', value: stringify(block) }];\n      }\n\n      push({ type: 'comma', value });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({ type: 'dot', value });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({ type: 'text', value });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({ type: 'eos' });\n  return ast;\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst stringify = require('./lib/stringify');\nconst compile = require('./lib/compile');\nconst expand = require('./lib/expand');\nconst parse = require('./lib/parse');\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces.create(pattern, options);\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces.parse = (input, options = {}) => parse(input, options);\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n  return compile(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n\n  let result = expand(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n return options.expand !== true\n    ? braces.compile(input, options)\n    : braces.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nmodule.exports = braces;\n","module.exports = require('./binary-extensions.json');\n","'use strict';\nconst path = require('path');\nconst binaryExtensions = require('binary-extensions');\n\nconst extensions = new Set(binaryExtensions);\n\nmodule.exports = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());\n","'use strict';\n\nconst {sep} = require('path');\nconst {platform} = process;\n\nexports.EV_ALL = 'all';\nexports.EV_READY = 'ready';\nexports.EV_ADD = 'add';\nexports.EV_CHANGE = 'change';\nexports.EV_ADD_DIR = 'addDir';\nexports.EV_UNLINK = 'unlink';\nexports.EV_UNLINK_DIR = 'unlinkDir';\nexports.EV_RAW = 'raw';\nexports.EV_ERROR = 'error';\n\nexports.STR_DATA = 'data';\nexports.STR_END = 'end';\nexports.STR_CLOSE = 'close';\n\nexports.FSEVENT_CREATED = 'created';\nexports.FSEVENT_MODIFIED = 'modified';\nexports.FSEVENT_DELETED = 'deleted';\nexports.FSEVENT_MOVED = 'moved';\nexports.FSEVENT_CLONED = 'cloned';\nexports.FSEVENT_UNKNOWN = 'unknown';\nexports.FSEVENT_TYPE_FILE = 'file';\nexports.FSEVENT_TYPE_DIRECTORY = 'directory';\nexports.FSEVENT_TYPE_SYMLINK = 'symlink';\n\nexports.KEY_LISTENERS = 'listeners';\nexports.KEY_ERR = 'errHandlers';\nexports.KEY_RAW = 'rawEmitters';\nexports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n\nexports.DOT_SLASH = `.${sep}`;\n\nexports.BACK_SLASH_RE = /\\\\/g;\nexports.DOUBLE_SLASH_RE = /\\/\\//;\nexports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\nexports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\nexports.REPLACER_RE = /^\\.[/\\\\]/;\n\nexports.SLASH = '/';\nexports.SLASH_SLASH = '//';\nexports.BRACE_START = '{';\nexports.BANG = '!';\nexports.ONE_DOT = '.';\nexports.TWO_DOTS = '..';\nexports.STAR = '*';\nexports.GLOBSTAR = '**';\nexports.ROOT_GLOBSTAR = '/**/*';\nexports.SLASH_GLOBSTAR = '/**';\nexports.DIR_SUFFIX = 'Dir';\nexports.ANYMATCH_OPTS = {dot: true};\nexports.STRING_TYPE = 'string';\nexports.FUNCTION_TYPE = 'function';\nexports.EMPTY_STR = '';\nexports.EMPTY_FN = () => {};\nexports.IDENTITY_FN = val => val;\n\nexports.isWindows = platform === 'win32';\nexports.isMacos = platform === 'darwin';\nexports.isLinux = platform === 'linux';\n","'use strict';\n\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst isBinaryPath = require('is-binary-path');\nconst {\n  isWindows,\n  isLinux,\n  EMPTY_FN,\n  EMPTY_STR,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE,\n  EV_ADD,\n  EV_ADD_DIR,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  BRACE_START,\n  STAR\n} = require('./constants');\n\nconst THROTTLE_MODE_WATCH = 'watch';\n\nconst open = promisify(fs.open);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst close = promisify(fs.close);\nconst fsrealpath = promisify(fs.realpath);\n\nconst statMethods = { lstat, stat };\n\n// TODO: emit errors properly. Example: EMFILE on Macos.\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\n\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n  container.add(item);\n};\n\nconst clearItem = cont => key => {\n  const set = cont[key];\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\n\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\n\nconst isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;\n\n/**\n * @typedef {String} Path\n */\n\n// fs_watch helpers\n\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\nconst FsWatchInstances = new Map();\n\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {watchedPath: path});\n\n    // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(\n        sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath)\n      );\n    }\n  };\n  try {\n    return fs.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], (listener) => {\n    listener(val1, val2, val3);\n  });\n};\n\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {listener, errHandler, rawEmitter} = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n\n  /** @type {fs.FSWatcher=} */\n  let watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(\n      path, options, listener, errHandler, rawEmitter\n    );\n    return watcher.close.bind(watcher);\n  }\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(\n      path,\n      options,\n      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),\n      errHandler, // no need to use broadcast here\n      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)\n    );\n    if (!watcher) return;\n    watcher.on(EV_ERROR, async (error) => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (isWindows && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close();\n      // }\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n// fs_watchFile helpers\n\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nconst FsWatchFileInstances = new Map();\n\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {listener, rawEmitter} = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n\n  /* eslint-disable no-unused-vars, prefer-destructuring */\n  let listeners = new Set();\n  let rawEmitters = new Set();\n\n  const copts = cont && cont.options;\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    // \"Upgrade\" the watcher to persistence or a quicker interval.\n    // This creates some unlikely edge case issues if the user mixes\n    // settings in a very weird way, but solving for those cases\n    // doesn't seem worthwhile for the added complexity.\n    listeners = cont.listeners;\n    rawEmitters = cont.rawEmitters;\n    fs.unwatchFile(fullPath);\n    cont = undefined;\n  }\n\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, (rawEmitter) => {\n          rawEmitter(EV_CHANGE, fullPath, {curr, prev});\n        });\n        const currmtime = curr.mtimeMs;\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, (listener) => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n/**\n * @mixin\n */\nclass NodeFsHandler {\n\n/**\n * @param {import(\"../index\").FSWatcher} fsW\n */\nconstructor(fsW) {\n  this.fsw = fsW;\n  this._boundHandleError = (error) => fsW._handleError(error);\n}\n\n/**\n * Watch file for changes with fs_watchFile or fs_watch.\n * @param {String} path to file or dir\n * @param {Function} listener on fs change\n * @returns {Function} closer for the watcher instance\n */\n_watchWithNodeFs(path, listener) {\n  const opts = this.fsw.options;\n  const directory = sysPath.dirname(path);\n  const basename = sysPath.basename(path);\n  const parent = this.fsw._getWatchedDir(directory);\n  parent.add(basename);\n  const absolutePath = sysPath.resolve(path);\n  const options = {persistent: opts.persistent};\n  if (!listener) listener = EMPTY_FN;\n\n  let closer;\n  if (opts.usePolling) {\n    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?\n      opts.binaryInterval : opts.interval;\n    closer = setFsWatchFileListener(path, absolutePath, options, {\n      listener,\n      rawEmitter: this.fsw._emitRaw\n    });\n  } else {\n    closer = setFsWatchListener(path, absolutePath, options, {\n      listener,\n      errHandler: this._boundHandleError,\n      rawEmitter: this.fsw._emitRaw\n    });\n  }\n  return closer;\n}\n\n/**\n * Watch a file and emit add event if warranted.\n * @param {Path} file Path\n * @param {fs.Stats} stats result of fs_stat\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @returns {Function} closer for the watcher instance\n */\n_handleFile(file, stats, initialAdd) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const dirname = sysPath.dirname(file);\n  const basename = sysPath.basename(file);\n  const parent = this.fsw._getWatchedDir(dirname);\n  // stats is always present\n  let prevStats = stats;\n\n  // if the file is already being watched, do nothing\n  if (parent.has(basename)) return;\n\n  const listener = async (path, newStats) => {\n    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n    if (!newStats || newStats.mtimeMs === 0) {\n      try {\n        const newStats = await stat(file);\n        if (this.fsw.closed) return;\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE, file, newStats);\n        }\n        if (isLinux && prevStats.ino !== newStats.ino) {\n          this.fsw._closeFile(path)\n          prevStats = newStats;\n          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n        } else {\n          prevStats = newStats;\n        }\n      } catch (error) {\n        // Fix issues where mtime is null but file is still present\n        this.fsw._remove(dirname, basename);\n      }\n      // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      // Check that change event was not fired because of changed only accessTime.\n      const at = newStats.atimeMs;\n      const mt = newStats.mtimeMs;\n      if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n        this.fsw._emit(EV_CHANGE, file, newStats);\n      }\n      prevStats = newStats;\n    }\n  }\n  // kick off the watcher\n  const closer = this._watchWithNodeFs(file, listener);\n\n  // emit an add event if we're supposed to\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n    if (!this.fsw._throttle(EV_ADD, file, 0)) return;\n    this.fsw._emit(EV_ADD, file, stats);\n  }\n\n  return closer;\n}\n\n/**\n * Handle symlinks encountered while reading a dir.\n * @param {Object} entry returned by readdirp\n * @param {String} directory path of dir being read\n * @param {String} path of this item\n * @param {String} item basename of this item\n * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n */\nasync _handleSymlink(entry, directory, path, item) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const full = entry.fullPath;\n  const dir = this.fsw._getWatchedDir(directory);\n\n  if (!this.fsw.options.followSymlinks) {\n    // watch symlink directly (don't follow) and detect changes\n    this.fsw._incrReadyCount();\n    const linkPath = await fsrealpath(path);\n    if (this.fsw.closed) return;\n    if (dir.has(item)) {\n      if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n        this.fsw._symlinkPaths.set(full, linkPath);\n        this.fsw._emit(EV_CHANGE, path, entry.stats);\n      }\n    } else {\n      dir.add(item);\n      this.fsw._symlinkPaths.set(full, linkPath);\n      this.fsw._emit(EV_ADD, path, entry.stats);\n    }\n    this.fsw._emitReady();\n    return true;\n  }\n\n  // don't follow the same symlink more than once\n  if (this.fsw._symlinkPaths.has(full)) {\n    return true;\n  }\n\n  this.fsw._symlinkPaths.set(full, true);\n}\n\n_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n  // Normalize the directory name on Windows\n  directory = sysPath.join(directory, EMPTY_STR);\n\n  if (!wh.hasGlob) {\n    throttler = this.fsw._throttle('readdir', directory, 1000);\n    if (!throttler) return;\n  }\n\n  const previous = this.fsw._getWatchedDir(wh.path);\n  const current = new Set();\n\n  let stream = this.fsw._readdirp(directory, {\n    fileFilter: entry => wh.filterPath(entry),\n    directoryFilter: entry => wh.filterDir(entry),\n    depth: 0\n  }).on(STR_DATA, async (entry) => {\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    const item = entry.path;\n    let path = sysPath.join(directory, item);\n    current.add(item);\n\n    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {\n      return;\n    }\n\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    // Files that present in current directory snapshot\n    // but absent in previous are added to watch list and\n    // emit `add` event.\n    if (item === target || !target && !previous.has(item)) {\n      this.fsw._incrReadyCount();\n\n      // ensure relativeness of path is preserved in case of watcher reuse\n      path = sysPath.join(dir, sysPath.relative(dir, path));\n\n      this._addToNodeFs(path, initialAdd, wh, depth + 1);\n    }\n  }).on(EV_ERROR, this._boundHandleError);\n\n  return new Promise(resolve =>\n    stream.once(STR_END, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      const wasThrottled = throttler ? throttler.clear() : false;\n\n      resolve();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.getChildren().filter((item) => {\n        return item !== directory &&\n          !current.has(item) &&\n          // in case of intersecting globs;\n          // a path may have been filtered out of this readdir, but\n          // shouldn't be removed because it matches a different glob\n          (!wh.hasGlob || wh.filterPath({\n            fullPath: sysPath.resolve(directory, item)\n          }));\n      }).forEach((item) => {\n        this.fsw._remove(directory, item);\n      });\n\n      stream = undefined;\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    })\n  );\n}\n\n/**\n * Read directory to add / remove files from `@watched` list and re-read it on change.\n * @param {String} dir fs path\n * @param {fs.Stats} stats\n * @param {Boolean} initialAdd\n * @param {Number} depth relative to user-supplied path\n * @param {String} target child path targeted for watch\n * @param {Object} wh Common watch helpers for this path\n * @param {String} realpath\n * @returns {Promise<Function>} closer for the watcher instance.\n */\nasync _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n  const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));\n  const tracked = parentDir.has(sysPath.basename(dir));\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);\n  }\n\n  // ensure dir is tracked (harmless if redundant)\n  parentDir.add(sysPath.basename(dir));\n  this.fsw._getWatchedDir(dir);\n  let throttler;\n  let closer;\n\n  const oDepth = this.fsw.options.depth;\n  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n    if (!target) {\n      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n      if (this.fsw.closed) return;\n    }\n\n    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n      // if current directory is removed, do nothing\n      if (stats && stats.mtimeMs === 0) return;\n\n      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n    });\n  }\n  return closer;\n}\n\n/**\n * Handle added file, directory, or glob pattern.\n * Delegates call to _handleFile / _handleDir after checks.\n * @param {String} path to file or ir\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @param {Object} priorWh depth relative to user-supplied path\n * @param {Number} depth Child path actually targeted for watch\n * @param {String=} target Child path actually targeted for watch\n * @returns {Promise}\n */\nasync _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n  const ready = this.fsw._emitReady;\n  if (this.fsw._isIgnored(path) || this.fsw.closed) {\n    ready();\n    return false;\n  }\n\n  const wh = this.fsw._getWatchHelpers(path, depth);\n  if (!wh.hasGlob && priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = entry => priorWh.filterPath(entry);\n    wh.filterDir = entry => priorWh.filterDir(entry);\n  }\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return false;\n    }\n\n    const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);\n    let closer;\n    if (stats.isDirectory()) {\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n      if (this.fsw.closed) return;\n      // preserve this symlink's target path\n      if (path !== targetPath && targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(targetPath, true);\n      }\n    } else if (stats.isSymbolicLink()) {\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      const parent = sysPath.dirname(wh.watchPath);\n      this.fsw._getWatchedDir(parent).add(wh.watchPath);\n      this.fsw._emit(EV_ADD, wh.watchPath, stats);\n      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n      if (this.fsw.closed) return;\n\n      // preserve this symlink's target path\n      if (targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);\n      }\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd);\n    }\n    ready();\n\n    this.fsw._addPathCloser(path, closer);\n    return false;\n\n  } catch (error) {\n    if (this.fsw._handleError(error)) {\n      ready();\n      return path;\n    }\n  }\n}\n\n}\n\nmodule.exports = NodeFsHandler;\n","'use strict';\n\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\n\nlet fsevents;\ntry {\n  fsevents = require('fsevents');\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst {\n  EV_ADD,\n  EV_CHANGE,\n  EV_ADD_DIR,\n  EV_UNLINK,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE,\n  EMPTY_FN,\n  IDENTITY_FN\n} = require('./constants');\n\nconst Depth = (value) => isNaN(value) ? {} : {depth: value};\n\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\nconst statMethods = { stat, lstat };\n\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n\n// fsevents instance helper functions\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\nconst FSEventsWatchers = new Map();\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nconst consolidateThreshhold = 10;\n\nconst wrongEventFlags = new Set([\n  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\n]);\n\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {stop};\n};\n\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;\n  const parentPath = sysPath.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = sysPath.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (\n      fullPath === resolvedPath ||\n      !fullPath.indexOf(resolvedPath + sysPath.sep)\n    ) listener(fullPath, flags, info);\n  };\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  let watchedParent = false;\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  }\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return () => {\n    const lst = cont.listeners;\n\n    lst.delete(filteredListener);\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nconst couldConsolidate = (path) => {\n  let count = 0;\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// returns boolean indicating whether fsevents can be used\nconst canUse = () => fsevents && FSEventsWatchers.size < 128;\n\n// determines subdirectory traversal levels from root to path\nconst calcDepth = (path, root) => {\n  let i = 0;\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\n  return i;\n};\n\n// returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\nconst sameTypes = (info, stats) => (\n  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||\n  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||\n  info.type === FSEVENT_TYPE_FILE && stats.isFile()\n)\n\n/**\n * @mixin\n */\nclass FsEventsHandler {\n\n/**\n * @param {import('../index').FSWatcher} fsw\n */\nconstructor(fsw) {\n  this.fsw = fsw;\n}\ncheckIgnored(path, stats) {\n  const ipaths = this.fsw._ignoredPaths;\n  if (this.fsw._isIgnored(path, stats)) {\n    ipaths.add(path);\n    if (stats && stats.isDirectory()) {\n      ipaths.add(path + ROOT_GLOBSTAR);\n    }\n    return true;\n  }\n\n  ipaths.delete(path);\n  ipaths.delete(path + ROOT_GLOBSTAR);\n}\n\naddOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;\n  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n}\n\nasync checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  try {\n    const stats = await stat(path)\n    if (this.fsw.closed) return;\n    if (sameTypes(info, stats)) {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  } catch (error) {\n    if (error.code === 'EACCES') {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  }\n}\n\nhandleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  if (this.fsw.closed || this.checkIgnored(path)) return;\n\n  if (event === EV_UNLINK) {\n    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY\n    // suppress unlink events on never before seen files\n    if (isDirectory || watchedDir.has(item)) {\n      this.fsw._remove(parent, item, isDirectory);\n    }\n  } else {\n    if (event === EV_ADD) {\n      // track new directories\n      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n        // push symlinks back to the top of the stack to get handled\n        const curDepth = opts.depth === undefined ?\n          undefined : calcDepth(fullPath, realPath) + 1;\n        return this._addToFsEvents(path, false, true, curDepth);\n      }\n\n      // track new paths\n      // (other than symlinks being followed, which will be tracked soon)\n      this.fsw._getWatchedDir(parent).add(item);\n    }\n    /**\n     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n     */\n    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n    this.fsw._emit(eventName, path);\n    if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);\n  }\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} watchPath  - file/dir path to be watched with fsevents\n * @param {String} realPath   - real path (in case of symlinks)\n * @param {Function} transform  - path transformer\n * @param {Function} globFilter - path filter in case a glob pattern was provided\n * @returns {Function} closer for the watcher instance\n*/\n_watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n  if (this.fsw.closed) return;\n  if (this.fsw._isIgnored(watchPath)) return;\n  const opts = this.fsw.options;\n  const watchCallback = async (fullPath, flags, info) => {\n    if (this.fsw.closed) return;\n    if (\n      opts.depth !== undefined &&\n      calcDepth(fullPath, realPath) > opts.depth\n    ) return;\n    const path = transform(sysPath.join(\n      watchPath, sysPath.relative(watchPath, fullPath)\n    ));\n    if (globFilter && !globFilter(path)) return;\n    // ensure directories are tracked\n    const parent = sysPath.dirname(path);\n    const item = sysPath.basename(path);\n    const watchedDir = this.fsw._getWatchedDir(\n      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent\n    );\n\n    // correct for wrong events emitted\n    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n      if (typeof opts.ignored === FUNCTION_TYPE) {\n        let stats;\n        try {\n          stats = await stat(path);\n        } catch (error) {}\n        if (this.fsw.closed) return;\n        if (this.checkIgnored(path, stats)) return;\n        if (sameTypes(info, stats)) {\n          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        } else {\n          this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } else {\n      switch (info.event) {\n      case FSEVENT_CREATED:\n      case FSEVENT_MODIFIED:\n        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      case FSEVENT_DELETED:\n      case FSEVENT_MOVED:\n        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  };\n\n  const closer = setFSEventsListener(\n    watchPath,\n    realPath,\n    watchCallback,\n    this.fsw._emitRaw\n  );\n\n  this.fsw._emitReady();\n  return closer;\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} linkPath path to symlink\n * @param {String} fullPath absolute path to the symlink\n * @param {Function} transform pre-existing path transformer\n * @param {Number} curDepth level of subdirectories traversed to where symlink is\n * @returns {Promise<void>}\n */\nasync _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n  // don't follow the same symlink more than once\n  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n  this.fsw._symlinkPaths.set(fullPath, true);\n  this.fsw._incrReadyCount();\n\n  try {\n    const linkTarget = await realpath(linkPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(linkTarget)) {\n      return this.fsw._emitReady();\n    }\n\n    this.fsw._incrReadyCount();\n\n    // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link's path\n    this._addToFsEvents(linkTarget || linkPath, (path) => {\n      let aliasedPath = linkPath;\n      if (linkTarget && linkTarget !== DOT_SLASH) {\n        aliasedPath = path.replace(linkTarget, linkPath);\n      } else if (path !== DOT_SLASH) {\n        aliasedPath = sysPath.join(linkPath, path);\n      }\n      return transform(aliasedPath);\n    }, false, curDepth);\n  } catch(error) {\n    if (this.fsw._handleError(error)) {\n      return this.fsw._emitReady();\n    }\n  }\n}\n\n/**\n *\n * @param {Path} newPath\n * @param {fs.Stats} stats\n */\nemitAdd(newPath, stats, processPath, opts, forceAdd) {\n  const pp = processPath(newPath);\n  const isDir = stats.isDirectory();\n  const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));\n  const base = sysPath.basename(pp);\n\n  // ensure empty dirs get tracked\n  if (isDir) this.fsw._getWatchedDir(pp);\n  if (dirObj.has(base)) return;\n  dirObj.add(base);\n\n  if (!opts.ignoreInitial || forceAdd === true) {\n    this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);\n  }\n}\n\ninitWatch(realPath, path, wh, processPath) {\n  if (this.fsw.closed) return;\n  const closer = this._watchWithFsEvents(\n    wh.watchPath,\n    sysPath.resolve(realPath || wh.watchPath),\n    processPath,\n    wh.globFilter\n  );\n  this.fsw._addPathCloser(path, closer);\n}\n\n/**\n * Handle added path with fsevents\n * @param {String} path file/dir path or glob pattern\n * @param {Function|Boolean=} transform converts working path to what the user expects\n * @param {Boolean=} forceAdd ensure add is emitted\n * @param {Number=} priorDepth Level of subdirectories already traversed.\n * @returns {Promise<void>}\n */\nasync _addToFsEvents(path, transform, forceAdd, priorDepth) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const opts = this.fsw.options;\n  const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\n\n  const wh = this.fsw._getWatchHelpers(path);\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      throw null;\n    }\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\n\n      // don't recurse further if it would exceed depth setting\n      if (priorDepth && priorDepth > opts.depth) return;\n\n      // scan the contents of the dir\n      this.fsw._readdirp(wh.watchPath, {\n        fileFilter: entry => wh.filterPath(entry),\n        directoryFilter: entry => wh.filterDir(entry),\n        ...Depth(opts.depth - (priorDepth || 0))\n      }).on(STR_DATA, (entry) => {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (this.fsw.closed) {\n          return;\n        }\n        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n\n        const joinedPath = sysPath.join(wh.watchPath, entry.path);\n        const {fullPath} = entry;\n\n        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n          // preserve the current depth here since it can't be derived from\n          // real paths past the symlink\n          const curDepth = opts.depth === undefined ?\n            undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n        }\n      }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {\n        this.fsw._emitReady();\n      });\n    } else {\n      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n      this.fsw._emitReady();\n    }\n  } catch (error) {\n    if (!error || this.fsw._handleError(error)) {\n      // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n      this.fsw._emitReady();\n      this.fsw._emitReady();\n    }\n  }\n\n  if (opts.persistent && forceAdd !== true) {\n    if (typeof transform === FUNCTION_TYPE) {\n      // realpath has already been resolved\n      this.initWatch(undefined, path, wh, processPath);\n    } else {\n      let realPath;\n      try {\n        realPath = await realpath(wh.watchPath);\n      } catch (e) {}\n      this.initWatch(realPath, path, wh, processPath);\n    }\n  }\n}\n\n}\n\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;\n","'use strict';\n\nconst { EventEmitter } = require('events');\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst readdirp = require('readdirp');\nconst anymatch = require('anymatch').default;\nconst globParent = require('glob-parent');\nconst isGlob = require('is-glob');\nconst braces = require('braces');\nconst normalizePath = require('normalize-path');\n\nconst NodeFsHandler = require('./lib/nodefs-handler');\nconst FsEventsHandler = require('./lib/fsevents-handler');\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n\n  STR_CLOSE,\n  STR_END,\n\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n\n  isWindows,\n  isMacos\n} = require('./lib/constants');\n\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = (value = []) => Array.isArray(value) ? value : [value];\nconst flatten = (list, result = []) => {\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = (paths_) => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n  return paths.map(normalizePathToUnix);\n};\n\n// If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\nconst toUnix = (string) => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n  if (prepend) {\n    str = SLASH + str;\n  }\n  return str;\n};\n\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));\n\nconst normalizeIgnored = (cwd = EMPTY_STR) => (path) => {\n  if (typeof path !== STRING_TYPE) return path;\n  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n};\n\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n  return sysPath.join(cwd, path);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {items} = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {items} = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n\n    const dir = this.path;\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {items} = this;\n    if (!items) return;\n    return items.has(item);\n  }\n\n  /**\n   * @returns {Array<String>}\n   */\n  getChildren() {\n    const {items} = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach((parts) => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?\n        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return sysPath.join(this.watchPath,\n      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))\n    );\n  }\n\n  filterPath(entry) {\n    const {stats} = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?\n      this.globFilter(resolvedPath) : true;\n    return matchesGlob &&\n      this.fsw._isntIgnored(resolvedPath, stats) &&\n      this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach((path) => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some((parts) => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n}\n\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nclass FSWatcher extends EventEmitter {\n// Not indenting methods for history sake; for now.\nconstructor(_opts) {\n  super();\n\n  const opts = {};\n  if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n  /** @type {Map<String, DirEntry>} */\n  this._watched = new Map();\n  /** @type {Map<String, Array>} */\n  this._closers = new Map();\n  /** @type {Set<String>} */\n  this._ignoredPaths = new Set();\n\n  /** @type {Map<ThrottleType, Map>} */\n  this._throttled = new Map();\n\n  /** @type {Map<Path, String|Boolean>} */\n  this._symlinkPaths = new Map();\n\n  this._streams = new Set();\n  this.closed = false;\n\n  // Set up default options.\n  if (undef(opts, 'persistent')) opts.persistent = true;\n  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n  if (undef(opts, 'interval')) opts.interval = 100;\n  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n  // Enable fsevents on OS X when polling isn't explicitly enabled.\n  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n  // If we can't use fsevents, ensure the options reflect it's disabled.\n  const canUseFsEvents = FsEventsHandler.canUse();\n  if (!canUseFsEvents) opts.useFsEvents = false;\n\n  // Use polling on Mac if not using fsevents.\n  // Other platforms use non-polling fs_watch.\n  if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n    opts.usePolling = isMacos;\n  }\n\n  // Global override (useful for end-developers that need to force polling for all\n  // instances of chokidar, regardless of usage/dependency depth)\n  const envPoll = process.env.CHOKIDAR_USEPOLLING;\n  if (envPoll !== undefined) {\n    const envLower = envPoll.toLowerCase();\n\n    if (envLower === 'false' || envLower === '0') {\n      opts.usePolling = false;\n    } else if (envLower === 'true' || envLower === '1') {\n      opts.usePolling = true;\n    } else {\n      opts.usePolling = !!envLower;\n    }\n  }\n  const envInterval = process.env.CHOKIDAR_INTERVAL;\n  if (envInterval) {\n    opts.interval = Number.parseInt(envInterval, 10);\n  }\n\n  // Editor atomic write normalization enabled by default with fs.watch\n  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n  if (opts.atomic) this._pendingUnlinks = new Map();\n\n  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n\n  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n  const awf = opts.awaitWriteFinish;\n  if (awf) {\n    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n    if (!awf.pollInterval) awf.pollInterval = 100;\n    this._pendingWrites = new Map();\n  }\n  if (opts.ignored) opts.ignored = arrify(opts.ignored);\n\n  let readyCalls = 0;\n  this._emitReady = () => {\n    readyCalls++;\n    if (readyCalls >= this._readyCount) {\n      this._emitReady = EMPTY_FN;\n      this._readyEmitted = true;\n      // use process.nextTick to allow time for listener to be bound\n      process.nextTick(() => this.emit(EV_READY));\n    }\n  };\n  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n  this._readyEmitted = false;\n  this.options = opts;\n\n  // Initialize with proper watcher.\n  if (opts.useFsEvents) {\n    this._fsEventsHandler = new FsEventsHandler(this);\n  } else {\n    this._nodeFsHandler = new NodeFsHandler(this);\n  }\n\n  // Youre frozen when your hearts not open.\n  Object.freeze(opts);\n}\n\n// Public methods\n\n/**\n * Adds paths to be watched on an existing FSWatcher instance\n * @param {Path|Array<Path>} paths_\n * @param {String=} _origAdd private; for handling non-existent paths to be watched\n * @param {Boolean=} _internal private; indicates a non-user add\n * @returns {FSWatcher} for chaining\n */\nadd(paths_, _origAdd, _internal) {\n  const {cwd, disableGlobbing} = this.options;\n  this.closed = false;\n  let paths = unifyPaths(paths_);\n  if (cwd) {\n    paths = paths.map((path) => {\n      const absPath = getAbsolutePath(path, cwd);\n\n      // Check `path` instead of `absPath` because the cwd portion can't be a glob\n      if (disableGlobbing || !isGlob(path)) {\n        return absPath;\n      }\n      return normalizePath(absPath);\n    });\n  }\n\n  // set aside negated glob strings\n  paths = paths.filter((path) => {\n    if (path.startsWith(BANG)) {\n      this._ignoredPaths.add(path.slice(1));\n      return false;\n    }\n\n    // if a path is being added that was previously ignored, stop ignoring it\n    this._ignoredPaths.delete(path);\n    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n\n    return true;\n  });\n\n  if (this.options.useFsEvents && this._fsEventsHandler) {\n    if (!this._readyCount) this._readyCount = paths.length;\n    if (this.options.persistent) this._readyCount *= 2;\n    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));\n  } else {\n    if (!this._readyCount) this._readyCount = 0;\n    this._readyCount += paths.length;\n    Promise.all(\n      paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })\n    ).then(results => {\n      if (this.closed) return;\n      results.filter(item => item).forEach(item => {\n        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n      });\n    });\n  }\n\n  return this;\n}\n\n/**\n * Close watchers or start ignoring events from specified paths.\n * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n * @returns {FSWatcher} for chaining\n*/\nunwatch(paths_) {\n  if (this.closed) return this;\n  const paths = unifyPaths(paths_);\n  const {cwd} = this.options;\n\n  paths.forEach((path) => {\n    // convert to absolute path unless relative path already matches\n    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n      if (cwd) path = sysPath.join(cwd, path);\n      path = sysPath.resolve(path);\n    }\n\n    this._closePath(path);\n\n    this._ignoredPaths.add(path);\n    if (this._watched.has(path)) {\n      this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n    }\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n  });\n\n  return this;\n}\n\n/**\n * Close watchers and remove all listeners from watched paths.\n * @returns {Promise<void>}.\n*/\nclose() {\n  if (this.closed) return this._closePromise;\n  this.closed = true;\n\n  // Memory management.\n  this.removeAllListeners();\n  const closers = [];\n  this._closers.forEach(closerList => closerList.forEach(closer => {\n    const promise = closer();\n    if (promise instanceof Promise) closers.push(promise);\n  }));\n  this._streams.forEach(stream => stream.destroy());\n  this._userIgnored = undefined;\n  this._readyCount = 0;\n  this._readyEmitted = false;\n  this._watched.forEach(dirent => dirent.dispose());\n  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n    this[`_${key}`].clear();\n  });\n\n  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n  return this._closePromise;\n}\n\n/**\n * Expose list of watched paths\n * @returns {Object} for chaining\n*/\ngetWatched() {\n  const watchList = {};\n  this._watched.forEach((entry, dir) => {\n    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n    watchList[key || ONE_DOT] = entry.getChildren().sort();\n  });\n  return watchList;\n}\n\nemitWithAll(event, args) {\n  this.emit(...args);\n  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n}\n\n// Common helpers\n// --------------\n\n/**\n * Normalize and emit events.\n * Calling _emit DOES NOT MEAN emit() would be called!\n * @param {EventName} event Type of event\n * @param {Path} path File or directory path\n * @param {*=} val1 arguments to be passed with event\n * @param {*=} val2\n * @param {*=} val3\n * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\nasync _emit(event, path, val1, val2, val3) {\n  if (this.closed) return;\n\n  const opts = this.options;\n  if (isWindows) path = sysPath.normalize(path);\n  if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n  /** @type Array<any> */\n  const args = [event, path];\n  if (val3 !== undefined) args.push(val1, val2, val3);\n  else if (val2 !== undefined) args.push(val1, val2);\n  else if (val1 !== undefined) args.push(val1);\n\n  const awf = opts.awaitWriteFinish;\n  let pw;\n  if (awf && (pw = this._pendingWrites.get(path))) {\n    pw.lastChange = new Date();\n    return this;\n  }\n\n  if (opts.atomic) {\n    if (event === EV_UNLINK) {\n      this._pendingUnlinks.set(path, args);\n      setTimeout(() => {\n        this._pendingUnlinks.forEach((entry, path) => {\n          this.emit(...entry);\n          this.emit(EV_ALL, ...entry);\n          this._pendingUnlinks.delete(path);\n        });\n      }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n      return this;\n    }\n    if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n      event = args[0] = EV_CHANGE;\n      this._pendingUnlinks.delete(path);\n    }\n  }\n\n  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n    const awfEmit = (err, stats) => {\n      if (err) {\n        event = args[0] = EV_ERROR;\n        args[1] = err;\n        this.emitWithAll(event, args);\n      } else if (stats) {\n        // if stats doesn't exist the file must have been deleted\n        if (args.length > 2) {\n          args[2] = stats;\n        } else {\n          args.push(stats);\n        }\n        this.emitWithAll(event, args);\n      }\n    };\n\n    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n    return this;\n  }\n\n  if (event === EV_CHANGE) {\n    const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n    if (isThrottled) return this;\n  }\n\n  if (opts.alwaysStat && val1 === undefined &&\n    (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)\n  ) {\n    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n    let stats;\n    try {\n      stats = await stat(fullPath);\n    } catch (err) {}\n    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n    if (!stats || this.closed) return;\n    args.push(stats);\n  }\n  this.emitWithAll(event, args);\n\n  return this;\n}\n\n/**\n * Common handler for errors\n * @param {Error} error\n * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\n_handleError(error) {\n  const code = error && error.code;\n  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&\n    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))\n  ) {\n    this.emit(EV_ERROR, error);\n  }\n  return error || this.closed;\n}\n\n/**\n * Helper utility for throttling\n * @param {ThrottleType} actionType type being throttled\n * @param {Path} path being acted upon\n * @param {Number} timeout duration of time to suppress duplicate actions\n * @returns {Object|false} tracking object or false if action should be suppressed\n */\n_throttle(actionType, path, timeout) {\n  if (!this._throttled.has(actionType)) {\n    this._throttled.set(actionType, new Map());\n  }\n\n  /** @type {Map<Path, Object>} */\n  const action = this._throttled.get(actionType);\n  /** @type {Object} */\n  const actionPath = action.get(path);\n\n  if (actionPath) {\n    actionPath.count++;\n    return false;\n  }\n\n  let timeoutObject;\n  const clear = () => {\n    const item = action.get(path);\n    const count = item ? item.count : 0;\n    action.delete(path);\n    clearTimeout(timeoutObject);\n    if (item) clearTimeout(item.timeoutObject);\n    return count;\n  };\n  timeoutObject = setTimeout(clear, timeout);\n  const thr = {timeoutObject, clear, count: 0};\n  action.set(path, thr);\n  return thr;\n}\n\n_incrReadyCount() {\n  return this._readyCount++;\n}\n\n/**\n * Awaits write operation to finish.\n * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n * @param {Path} path being acted upon\n * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n * @param {EventName} event\n * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n */\n_awaitWriteFinish(path, threshold, event, awfEmit) {\n  let timeoutHandler;\n\n  let fullPath = path;\n  if (this.options.cwd && !sysPath.isAbsolute(path)) {\n    fullPath = sysPath.join(this.options.cwd, path);\n  }\n\n  const now = new Date();\n\n  const awaitWriteFinish = (prevStat) => {\n    fs.stat(fullPath, (err, curStat) => {\n      if (err || !this._pendingWrites.has(path)) {\n        if (err && err.code !== 'ENOENT') awfEmit(err);\n        return;\n      }\n\n      const now = Number(new Date());\n\n      if (prevStat && curStat.size !== prevStat.size) {\n        this._pendingWrites.get(path).lastChange = now;\n      }\n      const pw = this._pendingWrites.get(path);\n      const df = now - pw.lastChange;\n\n      if (df >= threshold) {\n        this._pendingWrites.delete(path);\n        awfEmit(undefined, curStat);\n      } else {\n        timeoutHandler = setTimeout(\n          awaitWriteFinish,\n          this.options.awaitWriteFinish.pollInterval,\n          curStat\n        );\n      }\n    });\n  };\n\n  if (!this._pendingWrites.has(path)) {\n    this._pendingWrites.set(path, {\n      lastChange: now,\n      cancelWait: () => {\n        this._pendingWrites.delete(path);\n        clearTimeout(timeoutHandler);\n        return event;\n      }\n    });\n    timeoutHandler = setTimeout(\n      awaitWriteFinish,\n      this.options.awaitWriteFinish.pollInterval\n    );\n  }\n}\n\n_getGlobIgnored() {\n  return [...this._ignoredPaths.values()];\n}\n\n/**\n * Determines whether user has asked to ignore this path.\n * @param {Path} path filepath or dir\n * @param {fs.Stats=} stats result of fs.stat\n * @returns {Boolean}\n */\n_isIgnored(path, stats) {\n  if (this.options.atomic && DOT_RE.test(path)) return true;\n  if (!this._userIgnored) {\n    const {cwd} = this.options;\n    const ign = this.options.ignored;\n\n    const ignored = ign && ign.map(normalizeIgnored(cwd));\n    const paths = arrify(ignored)\n      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))\n      .map((path) => path + SLASH_GLOBSTAR);\n    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n  }\n\n  return this._userIgnored([path, stats]);\n}\n\n_isntIgnored(path, stat) {\n  return !this._isIgnored(path, stat);\n}\n\n/**\n * Provides a set of common helpers and properties relating to symlink and glob handling.\n * @param {Path} path file, directory, or glob pattern being watched\n * @param {Number=} depth at any depth > 0, this isn't a glob\n * @returns {WatchHelper} object containing helpers for this path\n */\n_getWatchHelpers(path, depth) {\n  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n  const follow = this.options.followSymlinks;\n\n  return new WatchHelper(path, watchPath, follow, this);\n}\n\n// Directory helpers\n// -----------------\n\n/**\n * Provides directory tracking objects\n * @param {String} directory path of the directory\n * @returns {DirEntry} the directory's tracking object\n */\n_getWatchedDir(directory) {\n  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n  const dir = sysPath.resolve(directory);\n  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n  return this._watched.get(dir);\n}\n\n// File helpers\n// ------------\n\n/**\n * Check for read permissions.\n * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n * @param {fs.Stats} stats - object, result of fs_stat\n * @returns {Boolean} indicates whether the file can be read\n*/\n_hasReadPermissions(stats) {\n  if (this.options.ignorePermissionErrors) return true;\n\n  // stats.mode may be bigint\n  const md = stats && Number.parseInt(stats.mode, 10);\n  const st = md & 0o777;\n  const it = Number.parseInt(st.toString(8)[0], 10);\n  return Boolean(4 & it);\n}\n\n/**\n * Handles emitting unlink events for\n * files and directories, and via recursion, for\n * files and directories within directories that are unlinked\n * @param {String} directory within which the following item is located\n * @param {String} item      base path of item/directory\n * @returns {void}\n*/\n_remove(directory, item, isDirectory) {\n  // if what is being deleted is a directory, get that directory's paths\n  // for recursive deleting and cleaning of watched object\n  // if it is not a directory, nestedDirectoryChildren will be empty array\n  const path = sysPath.join(directory, item);\n  const fullPath = sysPath.resolve(path);\n  isDirectory = isDirectory != null\n    ? isDirectory\n    : this._watched.has(path) || this._watched.has(fullPath);\n\n  // prevent duplicate handling in case of arriving here nearly simultaneously\n  // via multiple paths (such as _handleFile and _handleDir)\n  if (!this._throttle('remove', path, 100)) return;\n\n  // if the only watched file is removed, watch for its return\n  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n    this.add(directory, item, true);\n  }\n\n  // This will create a new entry in the watched object in either case\n  // so we got to do the directory check beforehand\n  const wp = this._getWatchedDir(path);\n  const nestedDirectoryChildren = wp.getChildren();\n\n  // Recursively remove children directories / files.\n  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\n\n  // Check if item was on the watched list and remove it\n  const parent = this._getWatchedDir(directory);\n  const wasTracked = parent.has(item);\n  parent.remove(item);\n\n  // If we wait for this file to be fully written, cancel the wait.\n  let relPath = path;\n  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n    const event = this._pendingWrites.get(relPath).cancelWait();\n    if (event === EV_ADD) return;\n  }\n\n  // The Entry will either be a directory that just got removed\n  // or a bogus entry to a file, in either case we have to remove it\n  this._watched.delete(path);\n  this._watched.delete(fullPath);\n  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\n\n  // Avoid conflicts if we later create another file with the same name\n  if (!this.options.useFsEvents) {\n    this._closePath(path);\n  }\n}\n\n/**\n * Closes all watchers for a path\n * @param {Path} path\n */\n_closePath(path) {\n  this._closeFile(path)\n  const dir = sysPath.dirname(path);\n  this._getWatchedDir(dir).remove(sysPath.basename(path));\n}\n\n/**\n * Closes only file-specific watchers\n * @param {Path} path\n */\n_closeFile(path) {\n  const closers = this._closers.get(path);\n  if (!closers) return;\n  closers.forEach(closer => closer());\n  this._closers.delete(path);\n}\n\n/**\n *\n * @param {Path} path\n * @param {Function} closer\n */\n_addPathCloser(path, closer) {\n  if (!closer) return;\n  let list = this._closers.get(path);\n  if (!list) {\n    list = [];\n    this._closers.set(path, list);\n  }\n  list.push(closer);\n}\n\n_readdirp(root, opts) {\n  if (this.closed) return;\n  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};\n  let stream = readdirp(root, options);\n  this._streams.add(stream);\n  stream.once(STR_CLOSE, () => {\n    stream = undefined;\n  });\n  stream.once(STR_END, () => {\n    if (stream) {\n      this._streams.delete(stream);\n      stream = undefined;\n    }\n  });\n  return stream;\n}\n\n}\n\n// Export FSWatcher class\nexports.FSWatcher = FSWatcher;\n\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nexports.watch = watch;\n","import * as filepath from \"path\"\nimport { Metafile as ESBuildMetafile } from \"esbuild\"\nimport { WatchOptions, WatchCallback, CancellablePromise, FileEvent } from \"../../estrella.d\"\nimport { BuildConfig, BuildContext } from \"../config\"\nimport * as _file from \"../file\"\nimport { log, LogLevel } from \"../log\"\nimport { repr } from \"../util\"\n\nimport { FSWatcher, FSWatcherOptions } from \"./fswatch\"\n\n\ntype FileModule = typeof _file\nlet file :FileModule\n\n\nexport function initModule(logLevel :LogLevel, filem :FileModule) {\n  log.level = logLevel\n  file = filem\n}\n\nfunction makeFSWatcherOptions(options :WatchOptions) :FSWatcherOptions {\n  return {\n    ...options,\n    isChangeSelfOriginating(filename :string) :boolean {\n      return file.fileWasModifiedRecentlyByUser(filename)\n    },\n  }\n}\n\n\nlet fswatcherMap = new Map<string,FSWatcher>() // projectID => FSWatcher\n\n\n// used by estrella itself, when config.watch is enabled\nexport async function watchFiles(\n  config         :BuildConfig,\n  getESBuildMeta :()=>ESBuildMetafile|null,\n  ctx            :BuildContext,\n  callback       :(changes :FileEvent[]) => Promise<void>,\n) :Promise<void> {\n  const projectID = config.projectID\n  let fswatcher = fswatcherMap.get(projectID)\n\n  if (!fswatcher) {\n    const watchOptions = config.watch && typeof config.watch == \"object\" ? config.watch : {}\n    fswatcher = new FSWatcher(makeFSWatcherOptions(watchOptions))\n    fswatcherMap.set(projectID, fswatcher)\n    fswatcher.basedir = config.cwd || process.cwd()\n    fswatcher.onChange = (changes) => {\n      // invoke the callback, which in turn rebuilds the project and writes a fresh\n      // esbuild metafile which we then read in refreshFiles.\n      callback(changes).then(refreshFiles)\n    }\n    ctx.addCancelCallback(() => {\n      fswatcher!.promise.cancel()\n    })\n    log.debug(`fswatch started for project#${projectID}`)\n  }\n\n  function refreshFiles() {\n    // Read metadata produced by esbuild, describing source files and product files.\n    // The metadata may be null or have a missing inputs prop in case esbuild failed.\n    const esbuildMeta = getESBuildMeta()\n    log.debug(\"fswatch refreshFiles with esbuildMeta\", esbuildMeta)\n    if (!esbuildMeta || !esbuildMeta.inputs) {\n      // esbuild failed -- don't change what files are being watched\n      return\n    }\n\n    // vars\n    const srcfiles = Object.keys(esbuildMeta.inputs) // {[filename:string]:{<info>}} => string[]\n        , outfiles = esbuildMeta.outputs || {} // {[filename:string]:{<info>}}\n\n    if (srcfiles.length == 0) {\n      // esbuild failed -- don't change what files are being watched\n      return\n    }\n\n    // path substrings for filtering out nodejs files\n    const nodeModulesPathPrefix = \"node_modules\" + filepath.sep\n    const nodeModulesPathSubstr = filepath.sep + nodeModulesPathPrefix\n    const isNodeModuleFile = (fn :string) => {\n      return fn.startsWith(nodeModulesPathPrefix) || fn.includes(nodeModulesPathSubstr)\n    }\n\n    // log\n    if (log.level >= log.DEBUG) {\n      const xs = srcfiles.filter(fn => !isNodeModuleFile(fn)).slice(0,10)\n      log.debug(\n        `fswatch updating source files: esbuild reported` +\n        ` ${srcfiles.length} inputs:` +\n        xs.map(fn => `\\n  ${fn}`).join(\"\") +\n        (xs.length < srcfiles.length ? `\\n  ... ${srcfiles.length-xs.length} more` : \"\")\n      )\n    }\n\n    // append output files to self-originating mod log\n    for (let fn of Object.keys(outfiles)) {\n      file.fileModificationLogAppend(fn)\n    }\n\n    // create list of source files\n    const sourceFiles = []\n    for (let fn of srcfiles) {\n      // exclude output files to avoid a loop\n      if (fn in outfiles) {\n        continue\n      }\n\n      // exclude files from libraries. Some projects may include hundreds or thousands of library\n      // files which would slow things down unncessarily.\n      if (srcfiles.length > 100 && isNodeModuleFile(fn)) {  // \"/node_modules/\"\n        continue\n      }\n      sourceFiles.push(fn)\n    }\n    fswatcher!.setFiles(sourceFiles)\n  }\n\n  refreshFiles()\n\n  return fswatcher.promise\n}\n\n\n// watch is a utility function exported in the estrella API\nexport function watch(\n  path :string|ReadonlyArray<string>,\n  cb   :WatchCallback,\n) :CancellablePromise<void>\n\nexport function watch(\n  path    :string|ReadonlyArray<string>,\n  options :WatchOptions|null|undefined,\n  cb      :WatchCallback,\n) :CancellablePromise<void>\n\nexport function watch(\n  path    :string|ReadonlyArray<string>,\n  options :WatchOptions|null|undefined | WatchCallback,\n  cb?     :WatchCallback,\n) :CancellablePromise<void> {\n  if (!cb) { // call form: watch(path, cb)\n    cb = options as WatchCallback\n    options = {}\n  }\n\n  const w = new FSWatcher(makeFSWatcherOptions({\n    // Defaults\n    persistent: true,\n    ignoreInitial: true,\n    ignored: /(^|[\\/\\\\])\\../, // ignore dotfiles\n    disableGlobbing: true,\n    followSymlinks: false,\n\n    // user override\n    ...(options || {})\n  }))\n  w.basedir = process.cwd()\n  w.onChange = cb!\n  w.setFiles(typeof path == \"string\" ? [path] : path)\n\n  return w.promise\n}\n","import { Console } from \"console\"\nimport { stdoutStyle, stderrStyle } from \"./termstyle\"\nimport { memoize } from \"./memoize\"\nimport { prog } from \"./cli\"\nimport { captureStackTrace } from \"./error\"\n\nimport { Log as LogAPI } from \"../estrella\"\n\ndeclare const DEBUG :boolean\n\nexport interface Env {\n  log :typeof log\n}\n\nexport enum LogLevel {\n  Silent = -1,// log nothing\n  Error = 0,  // only log errors\n  Warn,       // log errors and warnings\n  Info,       // log errors, warnings and info\n  Debug,      // log everything\n}\n\nlet log_console = console\nlet log_colorMode :boolean|undefined = undefined\n\nexport const log = new class Log implements LogAPI {\n  readonly SILENT = LogLevel.Silent // = -1\n  readonly ERROR  = LogLevel.Error  // = 0\n  readonly WARN   = LogLevel.Warn   // = 1\n  readonly INFO   = LogLevel.Info   // = 2\n  readonly DEBUG  = LogLevel.Debug  // = 3\n\n  level = LogLevel.Info\n\n  error(...v :any[]) :void {\n    if (log.level >= LogLevel.Error) {\n      evalFunctionInArgs(v)\n      log_console.error(stderrStyle.red(`${prog}:`), ...v)\n    }\n  }\n  warn(...v :any[]) :void {\n    if (log.level >= LogLevel.Warn) {\n      evalFunctionInArgs(v)\n      log_console.error(stderrStyle.magenta(`${prog}:`), ...v)\n    }\n  }\n  info(...v :any[]) :void {\n    if (log.level >= LogLevel.Info) {\n      evalFunctionInArgs(v)\n      log_console.log(...v)\n    }\n  }\n\n  // DEPRECATED in Estrella 1.2.2\n  readonly infoOnce = this.info\n\n  readonly debug = log_debug\n\n  get colorMode() :boolean|undefined {\n    return log_colorMode\n  }\n  set colorMode(colorMode :boolean|undefined) {\n    if (log_colorMode === colorMode) {\n      return\n    }\n    log_colorMode = colorMode\n    if (colorMode === undefined) { // auto\n      log_console = console\n    } else {\n      log_console = new Console({\n        stdout: process.stdout,\n        stderr: process.stderr,\n        colorMode\n      })\n    }\n  }\n}\n\nexport default log\n\nfunction evalFunctionInArgs(args :any[]) {\n  // evaluate first function argument\n  if (typeof args[0] == \"function\") {\n    args[0] = args[0]()\n  }\n}\n\nfunction log_debug(...v :any[]) {\n  if (log.level >= LogLevel.Debug) {\n    let meta = \"\"\n\n    if (DEBUG) {\n      // stack traces are only useful in debug builds (not mangled)\n      const stack = captureStackTrace(log_debug)\n      const frames = stack.split(\"\\n\", 5)\n      const f = frames[1]  // stack frame\n      let m = f && /at (\\w+)/.exec(f)\n      if (m) {\n        meta = \" \" + m[1]\n      } else if (!m && frames[2]) {\n        if (m = frames[2] && /at (\\w+)/.exec(frames[2])) {\n          meta = ` ${m[1]}  ${stdoutStyle.italic(\"f\")}`\n        }\n      }\n    }\n\n    evalFunctionInArgs(v)\n\n    if (v.length == 0 || (v.length == 1 && (v[0] === \"\" || v[0] === undefined))) {\n      // Nothing to be logged.\n      // This is sometimes useful when logging something complex conditionally, for example:\n      //   log.debug(() => {\n      //     if (expensiveComputation()) {\n      //       return \"redirecting foobar to fuzlol\"\n      //     }\n      //   })\n      return\n    }\n\n    log_console.log(stdoutStyle.bold(stdoutStyle.blue(`[DEBUG${meta}]`)), ...v)\n  }\n}\n","import {\n  TermStyle as TermStyleAPI,\n  TermStyleFun,\n  TTYStream,\n  NoTTYStream,\n} from \"../estrella\"\n\n\nexport interface TermStyle extends TermStyleAPI {\n  _hint :boolean|undefined  // original hint\n\n  // Like calling termStyle but instead of returning a new TermStyle object,\n  // the receiver (this) is updated/mutated.\n  reconfigure(w :TTYStream|NoTTYStream, hint? :boolean) :TermStyle\n}\n\n\nfunction numColors(w :TTYStream|NoTTYStream, hint? :boolean) {\n  let ncolors = 0\n  if (hint === true) {\n    // use colors regardless of TTY or not\n    let t = process.env.TERM || \"\"\n    ncolors = (\n      t && ['xterm','screen','vt100'].some(s => t.indexOf(s) != -1) ? (\n        t.indexOf('256color') != -1 ? 8 : 4\n      ) : 2\n    )\n  } else if (hint !== false && w.isTTY) {\n    // unless hint is explicitly false, use colors if stdout is a TTY\n    ncolors = w.getColorDepth()\n  }\n  return ncolors\n}\n\ntype TermStyleFunCons = (open16 :string, open256 :string, close :string) => TermStyleFun\n\n\nexport function termStyle(w :TTYStream|NoTTYStream, hint? :boolean) :TermStyle {\n  return createTermStyle(numColors(w, hint), hint)\n}\n\n\nexport function createTermStyle(ncolors :number, hint? :boolean) :TermStyle {\n  const CODE = (s :string) => `\\x1b[${s}m`\n\n  const effect :(open :string, close :string)=>TermStyleFun = (\n    ncolors > 0 || hint ? (open, close) => {\n      const a = CODE(open), b = CODE(close)\n      return s => a + s + b\n    } :\n    (_) => s => s\n  )\n\n  const color :TermStyleFunCons = (\n\n    // 256 colors support\n    ncolors >= 8 ? (_open16, open256, close) => {\n      // const open = CODE(code), close = CODE('2' + code)\n      let a = '\\x1b[' + open256 + 'm', b = '\\x1b[' + close + 'm'\n      return s => a + s + b\n    } :\n\n    // 16 colors support\n    ncolors > 0 ? (open16, _open256, close) => {\n      let a = '\\x1b[' + open16 + 'm', b = '\\x1b[' + close + 'm'\n      return s => a + s + b\n    } :\n\n    // no colors\n    (_open16, _open256, _close) => s => s\n  )\n\n  return {\n    _hint: hint,\n    ncolors,\n\n    reset     : hint || ncolors > 0 ? \"\\e[0m\" : \"\",\n\n    bold      : effect('1', '22'),\n    italic    : effect('3', '23'),\n    underline : effect('4', '24'),\n    inverse   : effect('7', '27'),\n\n    // name           16c    256c                 close\n    white       : color('37',  '38;2;255;255;255',  '39'),\n    grey        : color('90',  '38;5;244',          '39'),\n    black       : color('30',  '38;5;16',           '39'),\n    blue        : color('34',  '38;5;75',           '39'),\n    cyan        : color('36',  '38;5;87',           '39'),\n    green       : color('32',  '38;5;84',           '39'),\n    magenta     : color('35',  '38;5;213',          '39'),\n    purple      : color('35',  '38;5;141',          '39'),\n    pink        : color('35',  '38;5;211',          '39'),\n    red         : color('31',  '38;2;255;110;80',   '39'),\n    yellow      : color('33',  '38;5;227',          '39'),\n    lightyellow : color('93',  '38;5;229',          '39'),\n    orange      : color('33',  '38;5;215',          '39'),\n\n    reconfigure(w :TTYStream|NoTTYStream, hint? :boolean) :TermStyle {\n      const ncolors = numColors(w, hint)\n      if (ncolors != this.ncolors && hint != this._hint) {\n        Object.assign(this, createTermStyle(ncolors, hint))\n      }\n      return this\n    },\n\n  }\n}\n\nexport const stdoutStyle = termStyle(process.stdout)\nexport const stderrStyle = termStyle(process.stderr)\n","import * as Path from \"path\"\nimport { json } from \"./util\"\n\n\n// parse CLI program name (as invoked)\nexport const prog = (() :string => {\n  const $_ = process.env[\"_\"]\n  const scriptfile = process.argv[1]\n  if (!scriptfile) {\n    // unlikely\n    return $_ || process.argv[0]\n  }\n  if ($_ && !Path.isAbsolute($_)) {\n    // accurate in some shells (like bash, but not in zsh)\n    return $_\n  }\n  let prefix = \"\"\n  if ($_) {\n    const nodeExecName = Path.basename(process.execPath)\n    if ($_.endsWith(Path.sep + nodeExecName)) {\n      // the script was invoked by explicitly calling node.\n      // e.g. \"node build.js\"\n      prefix = nodeExecName + \" \"\n    }\n  }\n  if (scriptfile.startsWith(process.cwd())) {\n    let rel = Path.relative(process.cwd(), scriptfile)\n    if (!rel.startsWith(\"node_modules\"+Path.sep) &&\n        rel.indexOf(Path.sep+\"node_modules\"+Path.sep) == -1\n    ) {\n      if (Path.sep == \"/\") {\n        // on posix systems, this is needed to avoid PATH resolution\n        rel = \"./\" + rel\n      }\n      return rel\n    }\n  }\n  return prefix + Path.basename(scriptfile)\n})()\n\n\nexport function printUsageAndExit(usage :string, errmsg? :string|null) {\n  const msg = usage.trim().replace(/\\$0\\b/g, prog)\n  if (errmsg) {\n    console.error(`${prog}: ${errmsg}\\n` + msg)\n    process.exit(1)\n  } else {\n    console.log(msg)\n    process.exit(0)\n  }\n}\n\n// parseopt types\nexport interface Doc {\n  usage?   :Usage|null\n  flags    :Flags[]\n  trailer? :string\n\n  // if true, treat an unknown flag as an argument (no error)\n  unknownFlagAsArg? :boolean\n\n  // help is a function which is invoked INSTEAD OF printing help and exiting the process.\n  // The function receives three values:\n  //   flags   -- available flags\n  //   options -- flag values parsed so far\n  //   args    -- remaining, unprocessed input arguments\n  // options and args are the same values returned by parseopt()\n  //\n  help? :( (flags: FlagInfo[], options :Options, args :string[]) => void ) | null\n}\nexport type Usage = string | (()=>string)\nexport type Flags = (Flag | null | undefined | false)[]  // falsy elements are ignored\nexport type Flag  = string | [ string|string[] , string?, string? ]\nexport interface FlagInfo {\n  names        :string[]\n  description? :string\n  valueName?   :string\n  valueType?   :string\n  valueParser? :(v:string)=>any\n}\nexport type Options = { [k :string] :any }\n\n// parseopt parses command-line arguments.\n// Returns options and unparsed remaining arguments.\n//\n// flag format:\n//\n//   flag      = flagname | flagspec\n//   flagname  = \"-\"* <text>\n//   flagnames = Array< flagname+ >\n//   flagspec  = Tuple< flagnames | flagname >\n//\n// flag format examples:\n//\n//   \"verbose\"\n//   Simple boolean flag that can be set with -verbose or --verbose.\n//\n//   [ \"v\", \"Show version\" ]\n//   Boolean flag \"v\" with description text shown in program usage.\n//\n//   [ \"v, version\", \"Show version\" ]\n//   [ [\"v\", \"version\"], \"Show version\" ]\n//   Boolean flag \"v\" with alternate name \"version\" with description.\n//\n//   [ [\"v\", \"version\"] ]\n//   Boolean flag \"v\" with alternate name \"version\" without description.\n//\n//   [ \"o\", \"Output file\", \"<path>\" ]\n//   Value flag with description. Value type defaults to string.\n//   Can be invoked as -o=path, --o=path, -o path, and --o path.\n//\n//   [ \"o\", \"\", \"<path>\" ]\n//   Value flag without description.\n//\n//   [ \"limit\", \"Show no more than <limit> items\", \"<limit:number>\" ]\n//   Value flag with type constraint. Passing a value that is not a JS number\n//   causes an error message.\n//\n//   [ \"with-openssl\", \"\", \"enable:bool\" ]\n//   Boolean flag\n//\nexport function parseopt(argv :string[], doc :Doc) :[Options, string[]] {\n  let [flagmap, opts] = parseFlags(doc.flags.filter(f => f) as Flag[])\n  let options :Options = {}\n  let help = false\n  let args :string[] = []\n  let i = 0\n\n  const eatArg = () => {\n    args.push(argv.splice(i, 1)[0])\n    i--\n  }\n\n  for (; i < argv.length; i++) {\n    // read argument\n    let arg = argv[i]\n    if (arg == '--') {\n      i++\n      break\n    }\n    if (arg[0] != '-' || arg == '-') {\n      eatArg()\n      continue\n    }\n    arg = arg.replace(/^\\-+/, '')\n    let eqp = arg.indexOf('=')\n    let argval :string|undefined = undefined\n    if (eqp != -1) {\n      // e.g. -name=value\n      argval = arg.substr(eqp + 1)\n      arg = arg.substr(0, eqp)\n    }\n\n    // lookup flag\n    let opt = flagmap.get(arg)\n    if (!opt) {\n      if (arg == \"h\" || arg == \"help\") {\n        help = true\n        if (!doc.help) {\n          console.log(fmtUsage(opts, doc.usage, doc.trailer))\n          process.exit(0)\n        }\n      } else if (doc.unknownFlagAsArg) {\n        eatArg()\n        continue\n      } else {\n        printUnknownOptionsAndExit([argv[i]])\n      }\n      break\n    }\n\n    // save option\n    let value :any = true\n    if (opt.valueName) {\n      if (argval === undefined) {\n        // -k v\n        argval = argv[i + 1]\n        if (argval !== undefined && argval[0] != \"-\") {\n          i++\n        // } else if (opt.valueType == \"boolean\") {\n        //   argval = \"true\"\n        } else {\n          console.error(`missing value for option -${arg} (see ${prog} -help)`)\n          process.exit(1)\n          break\n        }\n      } // else -k=v\n      try {\n        value = opt.valueParser ? opt.valueParser(argval) : argval\n      } catch (err) {\n        console.error(`invalid value for option -${arg} (${err.message})`)\n      }\n    } else if (argval !== undefined) {\n      console.error(`unexpected value provided for flag -${arg}`)\n      process.exit(1)\n    } // else: e.g. -k\n\n    options[arg] = value\n\n    // alias spread\n    for (let alias of opt.names) {\n      if (alias == arg) {\n        continue\n      }\n      options[alias] = value\n    }\n\n  } // for (; i < argv.length; i++)\n\n  if (i < argv.length) {\n    args = args.concat(argv.slice(i))\n  }\n\n  if (help && doc.help) {\n    doc.help(opts, options, args)\n  }\n\n  return [options, args]\n}\n\n\nexport function printUnknownOptionsAndExit(args :string[]) {\n  console.error(\n    `unknown option${args.length > 1 ? \"s\" : \"\"} ${args.join(\", \")} (see ${prog} -help)`)\n  process.exit(1)\n}\n\n\n// parseFlags parses falgs and returns normalized structured options.\n// Returns:\n//   [0] Mapping of argument name (e.g. \"help\") to options.\n//   [1] Unique set of options (e.g. {flags:[\"h\",\"help\"],...}).\n//\nexport function parseFlags(flags :Flag[]) :[ Map<string,FlagInfo>, FlagInfo[] ] {\n  let fimap = new Map<string,FlagInfo>()\n  let fiv :FlagInfo[] = []\n  for (let f of flags) {\n    let fi = parseFlag(f)\n    fiv.push(fi)\n    for (let k of fi.names) {\n      if (fimap.has(k)) {\n        throw new Error(`duplicate CLI flag ${json(k)} in definition ${json(f)}`)\n      }\n      fimap.set(k, fi)\n    }\n  }\n  return [fimap, fiv]\n}\n\n\nfunction parseFlag(f :Flag) :FlagInfo {\n  const cleanFlag = (s :string) => s.replace(/(?:^|[\\s,])\\-+/g, '')\n  const splitComma = (s :string) => s.split(/\\s*,\\s*/)\n\n  if (typeof f == \"string\") {\n    return { names: splitComma(cleanFlag(f)) }\n  }\n\n  let o :FlagInfo = {\n    names: (\n      typeof f[0] == \"string\" ? splitComma(cleanFlag(f[0])) :\n      f[0].map(cleanFlag)\n    ),\n    description: f[1] || undefined\n  }\n\n  if (f[2]) {\n    let [name, type] = f[2].replace(/^[<>]+|[<>]+$/g, '').split(/:/, 2)\n    if (type) {\n      switch (type.toLowerCase()) {\n\n        case 'string':\n        case 'str':\n          type = 'string'\n          break\n\n        case 'bool':\n        case 'boolean':\n          type = 'boolean'\n          o.valueParser = s => {\n            s = s.toLowerCase()\n            return s != \"false\" && s != \"0\" && s != \"no\" && s != \"off\"\n          }\n          break\n\n        case 'number':\n        case 'num':\n        case 'float':\n        case 'int':\n          type = 'number'\n          o.valueParser = s => {\n            let n = Number(s)\n            if (isNaN(n)) {\n              throw new Error(`${json(s)} is not a number`)\n            }\n            return n\n          }\n          break\n\n        default:\n          throw new Error(`invalid argument type \"${type}\"`)\n      }\n    } else {\n      type = \"string\"\n    }\n    o.valueName = name || type\n    o.valueType = type\n  }\n  return o\n}\n\n\nexport function fmtUsage(opts :FlagInfo[], usage? :Usage|null, trailer? :string) :string {\n  // s/$name/value/\n  let vars :{[k:string]:any} = {\n    prog: prog,\n    \"0\": prog,\n  }\n  const subvars = (s :string) :string => s.replace(/\\$(\\w+)/g, (_, v) => {\n    let sub = vars[v]\n    if (!sub) {\n      throw new Error(`unknown variable $${v} (to print a dollar sign, use '\\\\$')`)\n    }\n    return sub\n  })\n\n  // start with usage\n  let s = subvars(\n    usage ?\n      typeof usage == 'function' ? usage() :\n                                   String(usage) :\n    opts.length > 0 ?\n      `Usage: $prog [options]` :\n      `Usage: $prog`\n  )\n\n  if (opts.length > 0) {\n    s += '\\noptions:\\n'\n    let longestFlagName = 0\n    let flagNames :string[] = []\n\n    for (let f of opts) {\n      let flagName = \"  -\" + (\n        // -f=,-file=<file>\n        f.valueName ?\n          f.names.join(\"=,-\") + \"=\" + (\n            f.valueType == \"boolean\" ? 'on|off' :\n                                       '<' + f.valueName + '>'\n          ) :\n        // -f, -file\n        f.names.join(\", -\")\n      )\n      longestFlagName = Math.max(longestFlagName, flagName.length)\n      flagNames.push(flagName)\n    }\n\n    for (let i = 0; i < opts.length; i++) {\n      let f = opts[i]\n      let names = flagNames[i]\n      let descr = f.description\n      if (!f.description) {\n        // default to \"Set flagname\" (\"Enable flagname\" for bool flags)\n        descr = f.valueType ? \"Set \" : \"Enable \" + f.names.reduce(\n          (a,s) => (s.length > a.length ? s : a), // pick longest name\n          \"\"\n        )\n      }\n      s += `${names.padEnd(longestFlagName, \" \")}  ${descr}`\n      if (i + 1 < opts.length) {\n        s += \"\\n\"\n      }\n    }\n  }\n\n  // end with trailer\n  if (trailer) {\n    s += \"\\n\" + subvars(trailer.replace(/[\\n\\s]+$/, \"\"))\n  }\n\n  return s\n}\n\n","import * as Path from \"path\"\n\nimport { runtimeRequire } from \"./util\"\nimport { log, LogLevel } from \"./log\"\nimport * as file from \"./file\"\nimport * as debugModule from \"./debug/debug\"\nimport * as watchModule from \"./watch/watch\"\n\nexport type DebugModule = typeof debugModule\nexport type WatchModule = typeof watchModule\n\ntype FileModule = typeof file\n\ninterface AuxModule {\n  initModule(logLevel :LogLevel, file :FileModule) :void\n}\n\n// used by tests\nlet estrellaDir = __dirname\nexport function setEstrellaDir(dir :string) {\n  estrellaDir = dir\n}\n\n\nfunction createLazyModuleAccessor<T extends AuxModule>(filename :string) :()=>T {\n  let m : T | null = null\n  return function getLazyModule() :T {\n    if (!m) {\n      log.debug(`loading ${filename} module`)\n      m = runtimeRequire(Path.join(estrellaDir, filename))\n      m!.initModule(log.level, file)\n    }\n    return m!\n  }\n}\n\nexport const debug = createLazyModuleAccessor<DebugModule>(DEBUG ? \"debug.g.js\" : \"debug.js\")\nexport const watch = createLazyModuleAccessor<WatchModule>(DEBUG ? \"watch.g.js\" : \"watch.js\")\n","import * as fs from \"fs\"\nimport { PathLike } from \"fs\"\nimport * as Path from \"path\"\nimport * as crypto from \"crypto\"\nimport { chmodp, Modifier as ChModModifier, editFileMode } from \"./chmod\"\nimport { clock, tildePath } from \"./util\"\nimport { stdoutStyle } from \"./termstyle\"\nimport log from \"./log\"\nimport { UserError } from \"./error\"\n\nimport { WatchOptions, file as filedecl, FileWriteOptions } from \"../estrella.d\"\n\n\nconst fsp = fs.promises\n\n// fileModificationLog contains a list of [filename,Date.now()] of files that where\n// modified through the API. This data is used by watch.\nexport const fileModificationLog :{[filename:string]:number} = {}\n\nexport function fileModificationLogAppend(filename :PathLike) {\n  // TODO figure out a way to make it not grow unbounded with variable file names\n  fileModificationLog[Path.resolve(String(filename))] = clock()\n}\n\nexport function fileWasModifiedRecentlyByUser(filename :string) {\n  const ageThreshold = 30000\n  const time = fileModificationLog[Path.resolve(filename)]\n  return time !== undefined && clock() - time <= ageThreshold\n}\n\n// trick to make TypeScript type check our definitions here against those in estrella.d.ts\nexport const _ts_check_file :typeof filedecl = file\n\n\n// file() reads all contents of a file (same as file.read)\nexport function file(filename :PathLike, options :{encoding:string,flag?:string}|string) :Promise<string>\nexport function file(filename :PathLike, options :{encoding?:null,flag?:string}) :Promise<Buffer>\nexport function file(filename :PathLike) :Promise<Buffer>\nexport function file(\n  filename: PathLike,\n  options? :{encoding?:string|null,flag?:string}|string,\n) :Promise<string|Buffer> {\n  return fsp.readFile(filename, options as any)\n}\n\nfile.editMode = editFileMode\n\n\nfile.chmod = (filename :PathLike, modifier :ChModModifier) => {\n  fileModificationLogAppend(filename)\n  return chmodp(filename, modifier)\n}\n\n\ntype ReadOptions = fs.BaseEncodingOptions & { flag?: string | number; }\n                 | BufferEncoding\n                 | null\n\nfunction read(\n  filename :PathLike,\n  options :{encoding:BufferEncoding, flag?:fs.OpenMode} | BufferEncoding\n) :Promise<string>\nfunction read(filename :PathLike,\n  options :{encoding?:null, flag?:fs.OpenMode} | null\n) :Promise<Buffer>\nfunction read(filename :PathLike) :Promise<Buffer>\nfunction read(filename :PathLike, options? :ReadOptions) :Promise<string|Buffer> {\n  return fsp.readFile(filename, options)\n}\nfile.read = read\n\n\nfunction readSync(\n  filename :PathLike,\n  options :{encoding:BufferEncoding,flag?:fs.OpenMode} | BufferEncoding\n) :string\nfunction readSync(filename :PathLike, options :{encoding?:null,flag?:fs.OpenMode} | null) :Buffer\nfunction readSync(filename :PathLike) :Buffer\nfunction readSync(filename :PathLike, options? :ReadOptions) :string|Buffer {\n  // Note: typecast of options since fs type defs for node12 are incorrect: type of flags\n  // do not list number, even though the official nodejs documentation does.\n  // https://nodejs.org/docs/latest-v12.x/api/fs.html#fs_file_system_flags\n  return fs.readFileSync(filename, options as ReadOptions&{flag?: string})\n}\nfile.readSync = readSync\n\n\nfile.stat = fsp.stat\n\n\nfunction mtime(filename :PathLike) :Promise<number|null>\nfunction mtime(...filenames :PathLike[]) :Promise<(number|null)[]>\nfunction mtime(...filenames :PathLike[]) :Promise<number|null|(number|null)[]> {\n  return Promise.all(filenames.map(filename =>\n    fsp.stat(filename).then(st => st.mtimeMs).catch(_ => null)\n  )).then(r => r.length == 1 ? r[0] : r)\n}\nfile.mtime = mtime\n\nfile.readall = (...filenames :PathLike[]) =>\n  Promise.all(filenames.map(fn => fsp.readFile(fn)))\n\nfile.readallText = (encoding :string|null|undefined, ...filenames :PathLike[]) =>\n  Promise.all(filenames.map(fn => fsp.readFile(fn, {\n    encoding: (encoding||\"utf8\") as BufferEncoding\n  })))\n\nfile.write = async (filename :PathLike, data :string|Uint8Array, options? :FileWriteOptions) => {\n  fileModificationLogAppend(filename)\n  const opt = options && typeof options == \"object\" ? options : {}\n  try {\n    await fsp.writeFile(filename, data, options)\n  } catch (err) {\n    if (!opt.mkdirOff && err.code == \"ENOENT\") {\n      await file.mkdirs(Path.dirname(String(filename)), opt.mkdirMode)\n      await fsp.writeFile(filename, data, options)\n    } else {\n      throw err\n    }\n  }\n  if (opt.log) {\n    let relpath = Path.relative(process.cwd(), String(filename))\n    if (relpath.startsWith(\"..\" + Path.sep)) {\n      relpath = tildePath(filename)\n    }\n    log.info(stdoutStyle.green(`Wrote ${relpath}`))\n  }\n}\n\nfile.writeSync = (filename :PathLike, data :string|Uint8Array, options? :FileWriteOptions) => {\n  // See note in readSync regarding the typecast\n  fileModificationLogAppend(filename)\n  fs.writeFileSync(filename, data, options as fs.WriteFileOptions)\n}\n\nfunction sha1(filename :PathLike) :Promise<Buffer>\nfunction sha1(filename :PathLike, outputEncoding :crypto.BinaryToTextEncoding) :Promise<string>\n\nfunction sha1(\n  filename :PathLike,\n  outputEncoding? :crypto.BinaryToTextEncoding,\n) :Promise<Buffer|string> {\n  return new Promise<Buffer|string>((resolve, reject) => {\n    const reader = fs.createReadStream(filename)\n    const h = crypto.createHash('sha1')\n    reader.on('error', reject)\n    reader.on('end', () => {\n      h.end()\n      resolve(outputEncoding ? h.digest(outputEncoding) : h.digest())\n    })\n    reader.pipe(h)\n  })\n}\n\nfile.sha1 = sha1\n\nfile.copy = (srcfile :PathLike, dstfile :PathLike, failIfExist? :boolean) => {\n  let mode = fs.constants.COPYFILE_FICLONE  // copy-on-write (only used if OS supports it)\n  if (failIfExist) {\n    mode |= fs.constants.COPYFILE_EXCL\n  }\n  fileModificationLogAppend(dstfile)\n  return fsp.copyFile(srcfile, dstfile, mode)\n}\n\nfile.move = (oldfile :PathLike, newfile :PathLike) => {\n  fileModificationLogAppend(newfile)\n  return fsp.rename(oldfile, newfile)\n}\n\nfile.mkdirs = (dir :PathLike, mode? :fs.Mode) :Promise<boolean> => {\n  return fsp.mkdir(dir, {recursive:true, mode}).then(s => !!s && s.length > 0)\n}\n\n\ntype LegacyWatchOptions = {\n  recursive? :boolean\n}\n\n\nexport async function scandir(\n  dir      :string|string[],\n  filter?  :RegExp|null,\n  options? :(WatchOptions & LegacyWatchOptions)|null,\n) :Promise<string[]> {\n  if (!options) { options = {} }\n  if (!fs.promises || !fs.promises.opendir) {\n    // opendir was added in node 12.12.0\n    throw new Error(`scandir not implemented for nodejs <12.12.0`) // TODO\n  }\n  const files :string[] = []\n  const visited = new Set<String>()\n\n  const maxdepth = (\n    options.recursive !== undefined ? // legacy option from estrella <=1.1\n      options.recursive ? Infinity : 0 :\n    options.depth !== undefined ? options.depth :\n    Infinity\n  )\n\n  async function visit(dir :string, reldir :string, depth :number) {\n    if (visited.has(dir)) {\n      // cycle\n      return\n    }\n    visited.add(dir)\n    const d = await fs.promises.opendir(dir)\n    // Note: d.close() is called implicitly by the iterator/generator\n    for await (const ent of d) {\n      let name = ent.name\n      if (ent.isDirectory()) {\n        if (maxdepth < depth) {\n          await visit(Path.join(dir, name), Path.join(reldir, name), depth + 1)\n        }\n      } else if (ent.isFile() || ent.isSymbolicLink()) {\n        if (filter && filter.test(name)) {\n          files.push(Path.join(reldir, name))\n        }\n      }\n    }\n  }\n\n  const dirs = Array.isArray(dir) ? dir : [dir]\n\n  return Promise.all(dirs.map(dir =>\n    visit(Path.resolve(dir), \".\", 0)\n  )).then(() => files.sort())\n}\n","import * as fs from \"fs\"\nimport { json } from \"./util\"\n\nconst chr = String.fromCharCode\nconst ord = (s :string, offs :number) => s.charCodeAt(offs || 0)\n\n\nexport type Modifier = number\n                     | string\n                     | string[]\n\n// chmod edits mode of a file (synchronous)\n// If m is a number, the mode is simply set to m.\n// If m is a string or list of strings, the mode is updated using editFileMode.\n// Returns the new mode set on file.\nexport function chmod(file :fs.PathLike, modifier :Modifier) :number {\n  if (typeof modifier == \"number\") {\n    fs.chmodSync(file, modifier)\n    return modifier\n  }\n  let mode = fs.statSync(file).mode\n  let newMode = editFileMode(mode, modifier)\n  if (mode != newMode) {\n    fs.chmodSync(file, newMode)\n  }\n  return newMode\n}\n\n// async version of chmod\nexport function chmodp(file :fs.PathLike, modifier :Modifier) :Promise<number> {\n  return new Promise<number>((resolve, reject) => {\n    if (typeof modifier == \"number\") {\n      return fs.chmod(file, modifier, err => {\n        err ? reject(err) : resolve(modifier)\n      })\n    }\n    fs.stat(file, (err, st) => {\n      if (err) return reject(err)\n      let newMode = editFileMode(st.mode, modifier)\n      if (st.mode == newMode) {\n        return resolve(newMode)\n      }\n      fs.chmod(file, newMode, err => {\n        err ? reject(err) : resolve(newMode)\n      })\n    })\n  })\n}\n\n\n// editFileMode takes a file mode (e.g. 0o764), applies modifiers and returns the resulting mode.\n// It accepts the same format as the Posix chmod program.\n// If multiple modifiers are provided, they are applied to mode in order.\n//\n// Grammar of modifier format:\n//\n//   mode   := clause [, clause ...]\n//   clause := [who ...] [action ...] action\n//   action := op [perm ...]\n//   who    := a | u | g | o\n//   op     := + | - | =\n//   perm   := r | w | x\n//\n// Examples:\n//\n//   // Set execute bit for user and group\n//   newMode = editFileMode(0o444, \"ug+x\") // => 0o554\n//\n//   // Set execute bit for user, write bit for group and remove all access for others\n//   newMode = editFileMode(0o444, \"+x,g+w,o-\") // => 0o560\n//\nexport function editFileMode(mode :number, modifier :string|string[]) :number {\n  const expectedFormat = `Expected format: [ugoa]*[+-=][rwx]+`\n\n  const err = (msg :string, m :any) =>\n    new Error(`${msg} in modifier ${json(m)}. ${expectedFormat}`)\n\n  let mods :string[] = []\n  for (let m of Array.isArray(modifier) ? modifier : [ modifier ]) {\n    mods = mods.concat(m.trim().split(/\\s*,+\\s*/))\n  }\n\n  for (let m of mods) {\n    let who :number[] = []\n    let all = false\n    let op = 0\n    let perm = 0\n\n    for (let i = 0; i < m.length; i++) {\n      let c = ord(m, i)\n      if (op == 0) {\n        switch (c) {\n          case 0x75: // u\n          case 0x67: // g\n          case 0x6F: // o\n            if (!all) {\n              who.push(c)\n            }\n            break\n          case 0x61: // a\n            who = [ 0x75, 0x67, 0x6F ]\n            all = true\n            break\n          case 0x2B: // +\n          case 0x2D: // -\n          case 0x3D: // =\n            op = c\n            break\n          default:\n            if (op == 0) {\n              throw err(`Invalid target or operation ${json(chr(c))}`, m)\n            }\n            break\n        }\n      } else {\n        switch (c) {\n          case 0x72: perm |= 0o4 ; break // r\n          case 0x77: perm |= 0o2 ; break // w\n          case 0x78: perm |= 0o1 ; break // x\n          default: throw err(`Invalid permission ${json(chr(c))}`, m)\n        }\n      }\n    }\n    if (op == 0) {\n      throw err(`Missing operation`, m)\n    }\n    if (who.length == 0) {\n      who = [ 0x75 ] // u\n    }\n    if (perm == 0) {\n      perm = 0o4 | 0o2 | 0o1\n    }\n\n    let mode2 = 0\n    for (let w of who) {\n      switch (w) {\n        case 0x75: mode2 |= (perm << 6) ; break  // u\n        case 0x67: mode2 |= (perm << 3) ; break  // g\n        case 0x6F: mode2 |= perm        ; break  // o\n      }\n    }\n    switch (op) {\n      case 0x2B: mode |= mode2 ; break  // +\n      case 0x2D: mode &= ~mode2 ; break // -\n      case 0x3D: mode = mode2 ; break   // =\n    }\n    // For debugging:\n    // console.log({\n    //   who: who.map(n => '0o' + n.toString(8)),\n    //   op: String.fromCharCode(op),\n    //   perm: '0o' + perm.toString(8),\n    // })\n  } // for each m in modifier\n  return mode\n}\n\n\ndeclare const DEBUG :boolean\n\n// lil' unit test for editFileMode\nif (DEBUG) {\n  const asserteq = require(\"assert\").strictEqual\n  const oct = (v :number) => \"0o\" + v.toString(8).padStart(3, '0')\n  //  input, modifiers, expected\n  const samples :\n    [ number, string[], number ][] = [\n    [ 0o444, [\"u+r\"],   0o444 ],\n    [ 0o444, [\"u+x\"],   0o544 ],\n    [ 0o444, [\"u+w\"],   0o644 ],\n    [ 0o444, [\"u+wx\"],  0o744 ],\n    [ 0o444, [\"u+rwx\"], 0o744 ],\n    [ 0o444, [\"u+r,u+w,u+x\"],    0o744 ],\n    [ 0o444, [\"u+r\", \"u+w,u+x\"], 0o744 ],\n    [ 0o444, [\"u+\"],    0o744 ], // no perm spec = all\n\n    [ 0o777, [\"u-r\"],   0o377 ],\n    [ 0o777, [\"u-wx\"],  0o477 ],\n    [ 0o777, [\"u-w\"],   0o577 ],\n    [ 0o777, [\"u-x\"],   0o677 ],\n    [ 0o777, [\"u-\"],    0o077 ],\n    [ 0o777, [\"u-rwx\"], 0o077 ],\n\n    [ 0o444, [\"g+r\"],   0o444 ],\n    [ 0o444, [\"g+x\"],   0o454 ],\n    [ 0o444, [\"g+w\"],   0o464 ],\n    [ 0o444, [\"g+wx\"],  0o474 ],\n    [ 0o444, [\"g+rwx\"], 0o474 ],\n    [ 0o444, [\"g+\"],    0o474 ],\n\n    [ 0o777, [\"g-r\"],   0o737 ],\n    [ 0o777, [\"g-wx\"],  0o747 ],\n    [ 0o777, [\"g-w\"],   0o757 ],\n    [ 0o777, [\"g-x\"],   0o767 ],\n    [ 0o777, [\"g-\"],    0o707 ],\n    [ 0o777, [\"g-rwx\"], 0o707 ],\n\n    [ 0o444, [\"o+r\"],   0o444 ],\n    [ 0o444, [\"o+x\"],   0o445 ],\n    [ 0o444, [\"o+w\"],   0o446 ],\n    [ 0o444, [\"o+wx\"],  0o447 ],\n    [ 0o444, [\"o+rwx\"], 0o447 ],\n    [ 0o444, [\"o+\"],    0o447 ],\n\n    [ 0o777, [\"o-r\"],   0o773 ],\n    [ 0o777, [\"o-wx\"],  0o774 ],\n    [ 0o777, [\"o-w\"],   0o775 ],\n    [ 0o777, [\"o-x\"],   0o776 ],\n    [ 0o777, [\"o-\"],    0o770 ],\n    [ 0o777, [\"o-rwx\"], 0o770 ],\n\n\n    [ 0o444, [\"ug+r\"],   0o444 ],\n    [ 0o444, [\"ug+x\"],   0o554 ],\n    [ 0o444, [\"ug+w\"],   0o664 ],\n    [ 0o444, [\"ug+wx\"],  0o774 ],\n    [ 0o444, [\"ug+rwx\"], 0o774 ],\n    [ 0o444, [\"ug+\"],    0o774 ],\n\n    [ 0o444, [\"ugo+r\"],   0o444 ],  [ 0o444, [\"a+r\"],   0o444 ],\n    [ 0o444, [\"ugo+x\"],   0o555 ],  [ 0o444, [\"a+x\"],   0o555 ],\n    [ 0o444, [\"ugo+w\"],   0o666 ],  [ 0o444, [\"a+w\"],   0o666 ],\n    [ 0o444, [\"ugo+wx\"],  0o777 ],  [ 0o444, [\"a+wx\"],  0o777 ],\n    [ 0o444, [\"ugo+rwx\"], 0o777 ],  [ 0o444, [\"a+rwx\"], 0o777 ],\n    [ 0o444, [\"ugo+\"],    0o777 ],  [ 0o444, [\"a+\"],    0o777 ],\n\n    [ 0o777, [\"ug-r\"],   0o337 ],\n    [ 0o777, [\"ug-wx\"],  0o447 ],\n    [ 0o777, [\"ug-w\"],   0o557 ],\n    [ 0o777, [\"ug-x\"],   0o667 ],\n    [ 0o777, [\"ug-\"],    0o007 ],\n    [ 0o777, [\"ug-rwx\"], 0o007 ],\n\n    [ 0o777, [\"ugo-r\"],   0o333 ],  [ 0o777, [\"a-r\"],   0o333 ],\n    [ 0o777, [\"ugo-wx\"],  0o444 ],  [ 0o777, [\"a-wx\"],  0o444 ],\n    [ 0o777, [\"ugo-w\"],   0o555 ],  [ 0o777, [\"a-w\"],   0o555 ],\n    [ 0o777, [\"ugo-x\"],   0o666 ],  [ 0o777, [\"a-x\"],   0o666 ],\n    [ 0o777, [\"ugo-\"],    0o000 ],  [ 0o777, [\"a-\"],    0o000 ],\n    [ 0o777, [\"ugo-rwx\"], 0o000 ],  [ 0o777, [\"a-rwx\"], 0o000 ],\n  ] // samples\n\n  samples.map(([input, mods, expect]) => {\n    let actual = editFileMode(input, mods)\n    asserteq(actual, expect,\n      `editFileMode(${oct(input)}, ${json(mods)}) => ` +\n      `${oct(actual)} != expected ${oct(expect)}`\n    )\n  })\n} // end of editFileMode tests\n","import * as extra from \"./extra\"\nimport { stderrStyle } from \"./termstyle\"\nimport { getModulePackageJSON } from \"./util\"\nimport * as typeinfo from \"./typeinfo\"\n\n\nexport class UserError extends Error {\n  constructor(msg :string) {\n    super(msg)\n    this.name = \"UserError\"\n  }\n}\n\n\n// captureStackTrace captures a stack trace, returning the formatted stack.\n// If sourcemap is true, then translate locations via source map (loads debug module.)\nexport function captureStackTrace(cons? :Function, sourcemap? :boolean) :string {\n  const Error_prepareStackTrace = Error.prepareStackTrace\n  if (!sourcemap) {\n    Error.prepareStackTrace = undefined\n  }\n  let stack = \"\"\n  try {\n    const e :any = {}\n    Error.captureStackTrace(e, cons)\n    // note: accessing e.stack invokes Error.prepareStackTrace so this must be done\n    // before restoring Error.prepareStackTrace\n    stack = e.stack as string\n  } finally {\n    Error.prepareStackTrace = Error_prepareStackTrace\n  }\n  return stack\n}\n\n\nexport function bugReportMessage(mode :\"confident\"|\"guess\", reportContextField? :string) {\n  return extra.debug().bugReportMessage(mode, reportContextField)\n}\n\n\nexport function printErrorAndExit(err :any, origin? :string) {\n  return extra.debug().printErrorAndExit(err, origin)\n}\n\n\n// attempt to install source-map-support just-in-time when an error occurs to avoid\n// taking the startup cost of 10-20ms for loading the source-map-support module.\nfunction Error_prepareStackTrace(error: Error, stack: NodeJS.CallSite[]) {\n  Error.prepareStackTrace = undefined\n  try {\n    extra.debug().installSourceMapSupport()\n    if (Error.prepareStackTrace !== Error_prepareStackTrace) {\n      return Error.prepareStackTrace!(error, stack)\n    }\n  } catch(_) {}\n  return error.stack || String(error)\n}\n\n\n// install process-level exception and rejection handlers\nError.prepareStackTrace = Error_prepareStackTrace\nprocess.on(\"uncaughtException\", printErrorAndExit)\nprocess.on(\"unhandledRejection\", (reason :{} | null | undefined, _promise :Promise<any>) => {\n  printErrorAndExit(reason||\"PromiseRejection\", \"unhandledRejection\")\n})\n","import * as Path from \"path\"\nimport * as chokidar from \"chokidar\"\n\nimport { WatchOptions, WatchCallback, FileEvent, FileEvent1, FileEvent2 } from \"../../estrella.d\"\n\nimport { repr, clock, fmtDuration } from \"../util\"\nimport log from \"../log\"\n\ntype ChangeEvent = 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir'\ntype CancellablePromise<T> = Promise<T>&{ cancel(reason?:any):void }\n\nexport interface FSWatcherOptions extends WatchOptions {\n  isChangeSelfOriginating(filename :string) :boolean\n}\n\n\nexport class FSWatcher {\n  options :FSWatcherOptions\n  promise :CancellablePromise<void>\n  basedir :string = \"\"\n\n  onStart? :()=>{}\n  onChange? :WatchCallback\n\n  _resolve = (_?:void|PromiseLike<void>|undefined, _rejectReason?:any)=>{}\n  _cancelled :boolean = false\n  _watcher :chokidar.FSWatcher | null = null\n  _fileset = new Set<string>()   // observed files\n\n\n  constructor(options :FSWatcherOptions) {\n    this.options = options\n    this.promise = new Promise<void>(r => {\n      this._resolve = r\n    }) as CancellablePromise<void>\n    this.promise.cancel = () => {\n      this._cancelled = true\n    }\n  }\n\n\n  setFiles(files :Iterable<string>) {\n    const newfileset = new Set(files)\n\n    if (!this._watcher) {\n      this._fileset = newfileset\n      this._start()\n      return\n    }\n\n    // find files being added and removed\n    let gonefiles :string[] = []\n    for (let f of this._fileset) {\n      if (!newfileset.has(f)) {\n        gonefiles.push(f)\n      }\n    }\n    let addfiles :string[] = []\n    for (let f of newfileset) {\n      if (!this._fileset.has(f)) {\n        addfiles.push(f)\n      }\n    }\n\n    this._fileset = newfileset\n\n    if (gonefiles.length > 0) {\n      log.debug(()=> `fswatch stop watching files ${this._relnames(gonefiles)}`)\n      this._watcher.unwatch(gonefiles)\n    }\n\n    if (addfiles.length > 0) {\n      log.debug(()=> `fswatch start watching files ${this._relnames(addfiles)}`)\n      this._watcher.add(addfiles)\n    }\n  }\n\n\n  close() :Promise<void> {\n    if (!this._watcher) {\n      return Promise.resolve()\n    }\n    log.debug(()=> `fswatch closing`)\n    this._watcher.close()\n      .then(() => this._resolve())\n      .catch(err => this._resolve(undefined, err))\n    this._watcher = null\n    return this.promise\n  }\n\n\n  _relnames(filenames :string[]) :string {\n    if (filenames.length == 1) {\n      return this._relname(filenames[0])\n    }\n    return filenames.map(fn => \"\\n  \" + this._relname(fn)).join(\"\")\n  }\n\n\n  _relname(fn :string) :string {\n    if (this.basedir && fn.startsWith(this.basedir)) {\n      return Path.relative(this.basedir, fn)\n    }\n    return Path.relative(process.cwd(), fn)\n  }\n\n\n  _start() {\n    if (this._cancelled) {\n      return\n    }\n\n    const initialFiles = Array.from(this._fileset)\n    if (initialFiles.length == 0) {\n      // chokidar has some odd behavior (bug?) where starting a watcher in \"persistent\" mode\n      // without initial files to watch causes it to not prevent the program runloop from ending.\n      return\n    }\n\n    if (this.basedir) {\n      this.basedir = Path.resolve(this.basedir)\n    }\n\n    let flushLatency = 50\n    let filter :RegExp|null = null\n\n    // copy user options and extract non-chokidar options\n    const options :WatchOptions = {...this.options}\n    if (typeof options.latency == \"number\") {\n      flushLatency = options.latency\n      delete options.latency\n    }\n    if (options.filter) {\n      filter = options.filter\n      delete options.filter\n    }\n\n    // build chokidar options from default options + user options + required options\n    const chokidarOptions :chokidar.WatchOptions = {\n      disableGlobbing: true,\n      followSymlinks: false,\n\n      // ups the reliability of change events\n      awaitWriteFinish: {\n        stabilityThreshold: 20,\n        pollInterval: 100,\n      },\n\n      // user options may override any options listed above\n      ...options,\n\n      // required options; for guaranteeing the promised semantics of FSWatcher\n      persistent: true,\n      ignoreInitial: true,\n    }\n\n    let changedFiles = new Map<string,FileEvent>() // changed files (to be flushed to callback)\n    let timer :any = null\n\n    const flush = () => {\n      timer = null\n      const p = this.onChange ? this.onChange(Array.from(changedFiles.values())) : null\n      changedFiles.clear()\n      if (p instanceof Promise) {\n        // pause dispatch (just enqueue) until resolved\n        p.then(() => {\n          timer = null\n          if (changedFiles.size > 0) {\n            // changes recorded while waiting for promise; flush again\n            flush()\n          }\n        }).catch(err => {\n          this.promise.cancel(err)\n        })\n        timer = 1 // this prevents flushing\n      }\n    }\n\n    const scheduleFlush = () => {\n      if (timer === null) {\n        timer = setTimeout(flush, flushLatency)\n      }\n    }\n\n    const maybeFilter = (file :string) => {\n      if (filter && !filter.test(file)) {\n        log.debug(()=>`fswatch ignoring ${file} (filter)`)\n        return true\n      }\n      return false\n    }\n\n    // macOS issues two consecutive \"move\" events when a file is renamed\n    // This contains state of a previous move event\n    const renameState = {\n      time: 0 as number, // clock() when oldname event was recorded\n      oldname: \"\",\n      newname: \"INIT\",\n    }\n\n    const onchange = (ev :ChangeEvent, file :string) => {\n      if (this.options.isChangeSelfOriginating(file)) {\n        log.debug(()=> `fswatch ignoring self-originating event ${ev} ${file}`)\n        return\n      }\n      if (maybeFilter(file)) {\n        return\n      }\n      log.debug(()=> `fsevent ${repr(ev)} ${repr(file)}`)\n      const evmap :{[k:string]:FileEvent[\"type\"]} = { // map chokidar event name to our event names\n        'addDir':\"add\",\n        'unlink':\"delete\",\n        'unlinkDir':\"delete\",\n      }\n      if (ev != \"unlink\" || !changedFiles.has(file) || changedFiles.get(file)!.type != \"move\") {\n        changedFiles.set(file, {\n          type: evmap[ev] || ev,\n          name: file,\n        } as FileEvent1)\n      }\n      scheduleFlush()\n    }\n\n    const onRawEvent = (ev: string, file: string, details: any) => {\n      if (ev != \"moved\") {\n        // note: we only care about \"moved\" here; other events are handled by onchange\n        return\n      }\n      file = this._relname(file)\n      log.debug(()=> `fsevent (raw) ${repr(ev)} ${repr(file)} ${repr(details)}`)\n      if (maybeFilter(file)) {\n        return\n      }\n      const time = clock()\n      const timeWindow = 100 // ms\n      if (renameState.newname != \"\") {\n        // start of a new pair of \"moved\" events\n        renameState.oldname = file\n        renameState.newname = \"\"\n        renameState.time = time\n      } else {\n        // end of a pair of \"moved\" events\n        renameState.newname = file\n        renameState.time = time\n        if (time - renameState.time <= timeWindow) {\n          // this is the second of two move events\n          log.debug(`fsevent (derived) move ${renameState.oldname} -> ${file}`)\n          if (this._watcher) {\n            this._watcher.add(file)\n            this._fileset.add(file)\n            this._watcher.unwatch(renameState.oldname)\n            this._fileset.delete(renameState.oldname)\n          }\n          changedFiles.delete(renameState.oldname)\n          changedFiles.set(renameState.oldname, {\n            type: \"move\",\n            name: renameState.oldname,\n            newname: file,\n          } as FileEvent2)\n          scheduleFlush()\n        }\n      }\n    }\n\n    this.promise.cancel = (reason? :any) => {\n      log.debug(`fswatcher is being cancelled`)\n      clearTimeout(timer)\n      if (!this._cancelled) {\n        this._cancelled = true\n        this.close()\n      }\n      if (reason) {\n        this._resolve(undefined, reason)\n      }\n    }\n\n    const time = clock()\n\n    this._watcher = chokidar.watch(initialFiles, chokidarOptions)\n      .on('all', onchange)\n      .on('raw', onRawEvent)\n      .on('error', error => log.warn(`fswatch ${error}`))\n      .on('ready', () => {\n        log.debug(()=>`fswatch initial scan complete (${fmtDuration(clock() - time)})`)\n        this.onStart && this.onStart()\n      })\n  }\n}\n"],"mappings":"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","names":[]}