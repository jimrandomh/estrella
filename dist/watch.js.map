{
  "version": 3,
  "sources": ["../src/util.js", "../node_modules/picomatch/lib/constants.js", "../node_modules/picomatch/lib/utils.js", "../node_modules/picomatch/lib/scan.js", "../node_modules/picomatch/lib/parse.js", "../node_modules/picomatch/lib/picomatch.js", "../node_modules/picomatch/index.js", "../node_modules/readdirp/index.js", "../node_modules/normalize-path/index.js", "../node_modules/anymatch/index.js", "../node_modules/is-extglob/index.js", "../node_modules/is-glob/index.js", "../node_modules/glob-parent/index.js", "../node_modules/braces/lib/utils.js", "../node_modules/braces/lib/stringify.js", "../node_modules/is-number/index.js", "../node_modules/to-regex-range/index.js", "../node_modules/fill-range/index.js", "../node_modules/braces/lib/compile.js", "../node_modules/braces/lib/expand.js", "../node_modules/braces/lib/constants.js", "../node_modules/braces/lib/parse.js", "../node_modules/braces/index.js", "../node_modules/binary-extensions/index.js", "../node_modules/is-binary-path/index.js", "../node_modules/chokidar/lib/constants.js", "../node_modules/chokidar/lib/nodefs-handler.js", "../node_modules/chokidar/lib/fsevents-handler.js", "../node_modules/chokidar/index.js", "../src/watch/watch.ts", "../src/log.ts", "../src/termstyle.ts", "../src/cli.ts", "../src/extra.ts", "../src/file.ts", "../src/chmod.ts", "../src/error.ts", "../src/watch/fswatch.ts"],
  "sourcesContent": ["import * as fs from \"fs\"\nimport * as Path from \"path\"\nimport * as os from \"os\"\nimport { performance } from \"perf_hooks\"\nimport { stdoutStyle } from \"./termstyle\"\nimport { inspect } from \"util\"\n\nexport const json = (val, pretty, showHidden) => JSON.stringify(val, showHidden, pretty)\nexport const clock = () => performance.now()\n\n// running on Windows?\nexport const isWindows = process.platform.startsWith(\"win\")\n\n// generic symbols\nexport const TYPE = Symbol(\"TYPE\")\n\n// runtimeRequire(id :string) :any\nexport function runtimeRequire(id) {\n  // _runtimeRequire is defined at compile time by build.js (== require)\n  try { return _runtimeRequire(id) } catch { return null }\n}\nruntimeRequire.resolve = id => {\n  try { return _runtimeRequire.resolve(id) } catch { return \"\" }\n}\n\n// isCLI is true if estrella is invoked directly and not imported as a module\nexport const isCLI = module.id == \".\" || process.mainModule.filename == __filename\n\n\nexport function repr(val, prettyOrOptions) {\n  let options = {\n    colors: stdoutStyle.ncolors > 0,\n  }\n  if (typeof prettyOrOptions == \"object\") {\n    options = { ...prettyOrOptions }\n  } else if (prettyOrOptions !== undefined) {\n    options.compact = !prettyOrOptions\n  }\n  return inspect(val, options)\n}\n\n\nexport function resolveModulePackageFile(moduleSpec) {\n  const mainfile = runtimeRequire.resolve(moduleSpec)\n  let dir = Path.dirname(Path.resolve(mainfile))\n  let lastdir = Path.sep // lastdir approach to support Windows (not just check for \"/\")\n  while (dir != lastdir) {\n    let pfile = Path.join(dir, \"package.json\")\n    if (fs.existsSync(pfile)) {\n      return pfile\n    }\n    dir = Path.dirname(dir)\n  }\n  throw new Error(`package.json not found for module ${moduleSpec}`)\n}\n\n\nexport function getModulePackageJSON(moduleSpec) {\n  const pfile = resolveModulePackageFile(moduleSpec)\n  return jsonparseFile(pfile)\n}\n\n\nlet _tmpdir = \"\"\n\nexport function tmpdir() {\n  if (!_tmpdir) {\n    // Some systems return paths with symlinks.\n    // esbuild does \"realpath\" on some pathnames and thus reporting with esbuild's metafile\n    // may be incorrect if this is not canonical.\n    _tmpdir = fs.realpathSync.native(os.tmpdir())\n  }\n  return _tmpdir\n}\n\n\nexport function fmtDuration(ms) {\n  return (\n    ms >= 59500 ? (ms/60000).toFixed(0) + \"min\" :\n    ms >= 999.5 ? (ms/1000).toFixed(1) + \"s\" :\n    ms.toFixed(2) + \"ms\"\n  )\n}\n\nexport function fmtByteSize(bytes) {\n  return (\n    bytes >= 1024*1000 ? (bytes/(1024*1000)).toFixed(1) + \"MB\" :\n    bytes >= 1000 ? (bytes/1024).toFixed(1) + \"kB\" :\n    bytes + \"B\"\n  )\n}\n\nexport function findInPATH(executableName) {\n  const exeFileMode = isWindows ? 0xFFFFFFFF : fs.constants.X_OK\n  const PATH = new Set((process.env.PATH || \"\").split(Path.delimiter))\n\n  for (let dir of PATH) {\n    let path = Path.join(Path.resolve(dir), executableName)\n    if (isWindows) {\n      path += \".cmd\"\n    }\n    while (true) {\n      try {\n        let st = fs.statSync(path)\n        if (st.isSymbolicLink()) {\n          path = fs.realpathSync.native(path)\n          continue // try again\n        } else if (st.isFile() && (st.mode & exeFileMode)) {\n          return path\n        }\n      } catch (_) {\n        if (isWindows && path.endsWith(\".cmd\")) {\n          path = Path.join(Path.resolve(dir), executableName) + \".exe\"\n          continue // try with .exe extension\n        }\n      }\n      break\n    }\n  }\n  return null\n}\n\n\n// jsonparse parses \"relaxed\" JSON which can be in JavaScript format\nexport function jsonparse(jsonText, filename /*optional*/) {\n  try {\n    return JSON.parse(json)\n  } catch (err) {\n    return require(\"vm\").runInNewContext(\n      '(' + jsonText + ')',\n      { /* sandbox */ },\n      { filename, displayErrors: true }\n    )\n  }\n}\n\nexport function jsonparseFile(filename) {\n  const json = fs.readFileSync(filename, \"utf8\")\n  try {\n    return jsonparse(json)\n  } catch (err) {\n    throw new Error(`failed to parse ${filename}: ${err.message || err}`)\n  }\n}\n\n\n// ~/hello => /home/user/hello\nexport function expandTildePath(path) {\n  const homedir = os.homedir()\n  if (path == \"~\") {\n    return homedir\n  }\n  if (path.startsWith(\"~\" + Path.sep)) {\n    return homedir + path.substr(1)\n  }\n  return path\n}\n\n// /home/user/hello => ~/hello\nexport function tildePath(path) {\n  const s = Path.resolve(path)\n  const homedir = os.homedir()\n  if (s.startsWith(homedir)) {\n    return \"~\" + s.substr(homedir.length)\n  }\n  return s\n}\n", "'use strict';\n\nconst path = require('path');\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  SEP: path.sep,\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n", "'use strict';\n\nconst path = require('path');\nconst win32 = process.platform === 'win32';\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = require('./constants');\n\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.supportsLookbehinds = () => {\n  const segs = process.version.slice(1).split('.').map(Number);\n  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {\n    return true;\n  }\n  return false;\n};\n\nexports.isWindows = options => {\n  if (options && typeof options.windows === 'boolean') {\n    return options.windows;\n  }\n  return win32 === true || path.sep === '\\\\';\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n", "'use strict';\n\nconst utils = require('./utils');\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = require('./constants');\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = { value: '', depth: 0, isGlob: false };\n\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = { value: '', depth: 0, isGlob: false };\n\n      if (finished === true) continue;\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS\n        || code === CHAR_AT\n        || code === CHAR_ASTERISK\n        || code === CHAR_QUESTION_MARK\n        || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n          break;\n        }\n      }\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nmodule.exports = scan;\n", "'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = (opts) => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index];\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.prev.type === 'bos' && eos()) {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance() || '';\n      } else {\n        value += advance() || '';\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = (opts) => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n", "'use strict';\n\nconst path = require('path');\nconst scan = require('./scan');\nconst parse = require('./parse');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.compileRe = (parsed, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return parsed.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${parsed.output})${append}`;\n  if (parsed && parsed.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = parsed;\n  }\n\n  return regex;\n};\n\npicomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  const opts = options || {};\n  let parsed = { negated: false, fastpaths: true };\n  let prefix = '';\n  let output;\n\n  if (input.startsWith('./')) {\n    input = input.slice(2);\n    prefix = parsed.prefix = './';\n  }\n\n  if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    output = parse.fastpaths(input, options);\n  }\n\n  if (output === undefined) {\n    parsed = parse(input, options);\n    parsed.prefix = prefix + (parsed.prefix || '');\n  } else {\n    parsed.output = output;\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n", "'use strict';\n\nmodule.exports = require('./lib/picomatch');\n", "'use strict';\n\nconst fs = require('fs');\nconst { Readable } = require('stream');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst picomatch = require('picomatch');\n\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG = '!';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP']);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry =>\n          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n      return entry => !negative.some(f => f(entry.basename));\n    }\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      /* eslint-disable no-unused-vars */\n      fileFilter: (path) => true,\n      directoryFilter: (path) => true,\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions, ...options };\n    const { root, type } = opts;\n\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n\n    const statMethod = opts.lstat ? lstat : stat;\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\n    if (process.platform === 'win32' && stat.length === 3) {\n      this._stat = path => statMethod(path, { bigint: true });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath.resolve(root);\n    this._isDirent = ('Dirent' in fs) && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\n\n    // Launch stream with one parent, the root dir.\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const { path, depth, files = [] } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n\n            const entryType = await this._getEntryType(entry);\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n    try {\n      files = await readdir(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n    return {files, depth, path};\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath.resolve(sysPath.join(path, basename));\n      entry = {path: sysPath.relative(this._root, fullPath), fullPath, basename};\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    if (!stats) {\n      return;\n    }\n    if (stats.isFile()) {\n      return 'file';\n    }\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n    if (stats && stats.isSymbolicLink()) {\n      const full = entry.fullPath;\n      try {\n        const entryRealPath = await realpath(full);\n        const entryRealPathStats = await lstat(entryRealPath);\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n        if (entryRealPathStats.isDirectory()) {\n          const len = entryRealPath.length;\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {\n            return this._onError(new Error(\n              `Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`\n            ));\n          }\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options)\n      .on('data', entry => files.push(entry))\n      .on('end', () => resolve(files))\n      .on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\n\nmodule.exports = readdirp;\n", "/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nmodule.exports = function(path, stripTrailing) {\n  if (typeof path !== 'string') {\n    throw new TypeError('expected path to be a string');\n  }\n\n  if (path === '\\\\' || path === '/') return '/';\n\n  var len = path.length;\n  if (len <= 1) return path;\n\n  // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n  var prefix = '';\n  if (len > 4 && path[3] === '\\\\') {\n    var ch = path[2];\n    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n      path = path.slice(2);\n      prefix = '//';\n    }\n  }\n\n  var segs = path.split(/[/\\\\]+/);\n  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n    segs.pop();\n  }\n  return prefix + segs.join('/');\n};\n", "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nconst picomatch = require('picomatch');\nconst normalizePath = require('normalize-path');\n\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\nconst BANG = '!';\nconst DEFAULT_OPTIONS = {returnIndex: false};\nconst arrify = (item) => Array.isArray(item) ? item : [item];\n\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return (string) => matcher === string || glob(string);\n  }\n  if (matcher instanceof RegExp) {\n    return (string) => matcher.test(string);\n  }\n  return (string) => false;\n};\n\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n  const _path = isList ? args[0] : args;\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' +\n      Object.prototype.toString.call(_path))\n  }\n  const path = normalizePath(_path);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\nconst anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;\n  const returnIndex = opts.returnIndex || false;\n\n  // Early cache for matchers.\n  const mtchers = arrify(matchers);\n  const negatedGlobs = mtchers\n    .filter(item => typeof item === 'string' && item.charAt(0) === BANG)\n    .map(item => item.slice(1))\n    .map(item => picomatch(item, opts));\n  const patterns = mtchers.map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    }\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch.default = anymatch;\nmodule.exports = anymatch;\n", "/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nmodule.exports = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n  while ((match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str))) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n", "/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isExtglob = require('is-extglob');\nvar chars = { '{': '}', '(': ')', '[': ']'};\nvar strictRegex = /\\\\(.)|(^!|\\*|[\\].+)]\\?|\\[[^\\\\\\]]+\\]|\\{[^\\\\}]+\\}|\\(\\?[:!=][^\\\\)]+\\)|\\([^|]+\\|[^\\\\)]+\\))/;\nvar relaxedRegex = /\\\\(.)|(^!|[*?{}()[\\]]|\\(\\?)/;\n\nmodule.exports = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var regex = strictRegex;\n  var match;\n\n  // optionally relax regex\n  if (options && options.strict === false) {\n    regex = relaxedRegex;\n  }\n\n  while ((match = regex.exec(str))) {\n    if (match[2]) return true;\n    var idx = match.index + match[0].length;\n\n    // if an open bracket/brace/paren is escaped,\n    // set the index to the next closing character\n    var open = match[1];\n    var close = open ? chars[open] : null;\n    if (open && close) {\n      var n = str.indexOf(close, idx);\n      if (n !== -1) {\n        idx = n + 1;\n      }\n    }\n\n    str = str.slice(idx);\n  }\n  return false;\n};\n", "'use strict';\n\nvar isGlob = require('is-glob');\nvar pathPosixDirname = require('path').posix.dirname;\nvar isWin32 = require('os').platform() === 'win32';\n\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n * @returns {string}\n */\nmodule.exports = function globParent(str, opts) {\n  var options = Object.assign({ flipBackslashes: true }, opts);\n\n  // flip windows path separators\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  }\n\n  // special case for strings ending in enclosure containing path separator\n  if (enclosure.test(str)) {\n    str += slash;\n  }\n\n  // preserves full path in case of trailing path separator\n  str += 'a';\n\n  // remove path parts that are globby\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob(str) || globby.test(str));\n\n  // remove escape chars and return result\n  return str.replace(escaped, '$1');\n};\n", "'use strict';\n\nexports.isInteger = num => {\n  if (typeof num === 'number') {\n    return Number.isInteger(num);\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isInteger(Number(num));\n  }\n  return false;\n};\n\n/**\n * Find a node of the given type\n */\n\nexports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n/**\n * Find a node of the given type\n */\n\nexports.exceedsLimit = (min, max, step = 1, limit) => {\n  if (limit === false) return false;\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n  return ((Number(max) - Number(min)) / Number(step)) >= limit;\n};\n\n/**\n * Escape the given node with '\\\\' before node.value\n */\n\nexports.escapeNode = (block, n = 0, type) => {\n  let node = block.nodes[n];\n  if (!node) return;\n\n  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n    if (node.escaped !== true) {\n      node.value = '\\\\' + node.value;\n      node.escaped = true;\n    }\n  }\n};\n\n/**\n * Returns true if the given brace node should be enclosed in literal braces\n */\n\nexports.encloseBrace = node => {\n  if (node.type !== 'brace') return false;\n  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n    node.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a brace node is invalid.\n */\n\nexports.isInvalidBrace = block => {\n  if (block.type !== 'brace') return false;\n  if (block.invalid === true || block.dollar) return true;\n  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n    block.invalid = true;\n    return true;\n  }\n  if (block.open !== true || block.close !== true) {\n    block.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a node is an open or close node\n */\n\nexports.isOpenOrClose = node => {\n  if (node.type === 'open' || node.type === 'close') {\n    return true;\n  }\n  return node.open === true || node.close === true;\n};\n\n/**\n * Reduce an array of text nodes.\n */\n\nexports.reduce = nodes => nodes.reduce((acc, node) => {\n  if (node.type === 'text') acc.push(node.value);\n  if (node.type === 'range') node.type = 'text';\n  return acc;\n}, []);\n\n/**\n * Flatten an array\n */\n\nexports.flatten = (...args) => {\n  const result = [];\n  const flat = arr => {\n    for (let i = 0; i < arr.length; i++) {\n      let ele = arr[i];\n      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\n    }\n    return result;\n  };\n  flat(args);\n  return result;\n};\n", "'use strict';\n\nconst utils = require('./utils');\n\nmodule.exports = (ast, options = {}) => {\n  let stringify = (node, parent = {}) => {\n    let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n    return output;\n  };\n\n  return stringify(ast);\n};\n\n", "/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function(num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n  return false;\n};\n", "/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst isNumber = require('is-number');\n\nconst toRegexRange = (min, max, options) => {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = { relaxZeros: true, ...options };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = { min, max, a, b };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives, opts);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return { pattern: start, count: [], digits: 0 };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit, options);\n\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let { string } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default: {\n      return relax ? `0{0,${diff}}` : `0{${diff}}`;\n    }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange.cache = {};\ntoRegexRange.clearCache = () => (toRegexRange.cache = {});\n\n/**\n * Expose `toRegexRange`\n */\n\nmodule.exports = toRegexRange;\n", "/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nconst util = require('util');\nconst toRegexRange = require('to-regex-range');\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\n\nconst stringify = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? ('-' + input) : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, { wrap: false, ...options });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = { negatives: [], positives: [] };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1\n      ? toSequence(parts, options)\n      : toRegex(range, null, { wrap: false, ...options });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {\n    return invalidRange(start, end, options);\n  }\n\n\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, { wrap: false, options });\n  }\n\n  return range;\n};\n\nconst fill = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill(start, end, 1, { transform: step });\n  }\n\n  if (isObject(step)) {\n    return fill(start, end, 0, step);\n  }\n\n  let opts = { ...options };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nmodule.exports = fill;\n", "'use strict';\n\nconst fill = require('fill-range');\nconst utils = require('./utils');\n\nconst compile = (ast, options = {}) => {\n  let walk = (node, parent = {}) => {\n    let invalidBlock = utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? (prefix + node.value) : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? (prefix + node.value) : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n      let range = fill(...args, { ...options, wrap: false, toRegex: true });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n    return output;\n  };\n\n  return walk(ast);\n};\n\nmodule.exports = compile;\n", "'use strict';\n\nconst fill = require('fill-range');\nconst stringify = require('./stringify');\nconst utils = require('./utils');\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  let result = [];\n\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));\n      }\n    }\n  }\n  return utils.flatten(result);\n};\n\nconst expand = (ast, options = {}) => {\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  let walk = (node, parent = {}) => {\n    node.queue = [];\n\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nmodule.exports = expand;\n", "'use strict';\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n\n  // Digits\n  CHAR_0: '0', /* 0 */\n  CHAR_9: '9', /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A', /* A */\n  CHAR_LOWERCASE_A: 'a', /* a */\n  CHAR_UPPERCASE_Z: 'Z', /* Z */\n  CHAR_LOWERCASE_Z: 'z', /* z */\n\n  CHAR_LEFT_PARENTHESES: '(', /* ( */\n  CHAR_RIGHT_PARENTHESES: ')', /* ) */\n\n  CHAR_ASTERISK: '*', /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&', /* & */\n  CHAR_AT: '@', /* @ */\n  CHAR_BACKSLASH: '\\\\', /* \\ */\n  CHAR_BACKTICK: '`', /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r', /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */\n  CHAR_COLON: ':', /* : */\n  CHAR_COMMA: ',', /* , */\n  CHAR_DOLLAR: '$', /* . */\n  CHAR_DOT: '.', /* . */\n  CHAR_DOUBLE_QUOTE: '\"', /* \" */\n  CHAR_EQUAL: '=', /* = */\n  CHAR_EXCLAMATION_MARK: '!', /* ! */\n  CHAR_FORM_FEED: '\\f', /* \\f */\n  CHAR_FORWARD_SLASH: '/', /* / */\n  CHAR_HASH: '#', /* # */\n  CHAR_HYPHEN_MINUS: '-', /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */\n  CHAR_LEFT_CURLY_BRACE: '{', /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */\n  CHAR_LINE_FEED: '\\n', /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0', /* \\u00A0 */\n  CHAR_PERCENT: '%', /* % */\n  CHAR_PLUS: '+', /* + */\n  CHAR_QUESTION_MARK: '?', /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}', /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */\n  CHAR_SEMICOLON: ';', /* ; */\n  CHAR_SINGLE_QUOTE: '\\'', /* ' */\n  CHAR_SPACE: ' ', /*   */\n  CHAR_TAB: '\\t', /* \\t */\n  CHAR_UNDERSCORE: '_', /* _ */\n  CHAR_VERTICAL_LINE: '|', /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n", "'use strict';\n\nconst stringify = require('./stringify');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH, /* \\ */\n  CHAR_BACKTICK, /* ` */\n  CHAR_COMMA, /* , */\n  CHAR_DOT, /* . */\n  CHAR_LEFT_PARENTHESES, /* ( */\n  CHAR_RIGHT_PARENTHESES, /* ) */\n  CHAR_LEFT_CURLY_BRACE, /* { */\n  CHAR_RIGHT_CURLY_BRACE, /* } */\n  CHAR_LEFT_SQUARE_BRACKET, /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\n  CHAR_DOUBLE_QUOTE, /* \" */\n  CHAR_SINGLE_QUOTE, /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = require('./constants');\n\n/**\n * parse\n */\n\nconst parse = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = { type: 'root', input, nodes: [] };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n  let memo = {};\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({ type: 'bos' });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({ type: 'text', value: '\\\\' + value });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n\n      let closed = true;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({ type: 'paren', nodes: [] });\n      stack.push(block);\n      push({ type: 'text', value });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({ type: 'text', value });\n        continue;\n      }\n      block = stack.pop();\n      push({ type: 'text', value });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n\n      block = push(brace);\n      stack.push(block);\n      push({ type: 'open', value });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n\n      push({ type, value });\n      depth--;\n\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, { type: 'text', value: stringify(block) }];\n      }\n\n      push({ type: 'comma', value });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({ type: 'dot', value });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({ type: 'text', value });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({ type: 'eos' });\n  return ast;\n};\n\nmodule.exports = parse;\n", "'use strict';\n\nconst stringify = require('./lib/stringify');\nconst compile = require('./lib/compile');\nconst expand = require('./lib/expand');\nconst parse = require('./lib/parse');\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces.create(pattern, options);\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces.parse = (input, options = {}) => parse(input, options);\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n  return compile(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n\n  let result = expand(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n return options.expand !== true\n    ? braces.compile(input, options)\n    : braces.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nmodule.exports = braces;\n", "module.exports = require('./binary-extensions.json');\n", "'use strict';\nconst path = require('path');\nconst binaryExtensions = require('binary-extensions');\n\nconst extensions = new Set(binaryExtensions);\n\nmodule.exports = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());\n", "'use strict';\n\nconst {sep} = require('path');\nconst {platform} = process;\n\nexports.EV_ALL = 'all';\nexports.EV_READY = 'ready';\nexports.EV_ADD = 'add';\nexports.EV_CHANGE = 'change';\nexports.EV_ADD_DIR = 'addDir';\nexports.EV_UNLINK = 'unlink';\nexports.EV_UNLINK_DIR = 'unlinkDir';\nexports.EV_RAW = 'raw';\nexports.EV_ERROR = 'error';\n\nexports.STR_DATA = 'data';\nexports.STR_END = 'end';\nexports.STR_CLOSE = 'close';\n\nexports.FSEVENT_CREATED = 'created';\nexports.FSEVENT_MODIFIED = 'modified';\nexports.FSEVENT_DELETED = 'deleted';\nexports.FSEVENT_MOVED = 'moved';\nexports.FSEVENT_CLONED = 'cloned';\nexports.FSEVENT_UNKNOWN = 'unknown';\nexports.FSEVENT_TYPE_FILE = 'file';\nexports.FSEVENT_TYPE_DIRECTORY = 'directory';\nexports.FSEVENT_TYPE_SYMLINK = 'symlink';\n\nexports.KEY_LISTENERS = 'listeners';\nexports.KEY_ERR = 'errHandlers';\nexports.KEY_RAW = 'rawEmitters';\nexports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n\nexports.DOT_SLASH = `.${sep}`;\n\nexports.BACK_SLASH_RE = /\\\\/g;\nexports.DOUBLE_SLASH_RE = /\\/\\//;\nexports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\nexports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\nexports.REPLACER_RE = /^\\.[/\\\\]/;\n\nexports.SLASH = '/';\nexports.SLASH_SLASH = '//';\nexports.BRACE_START = '{';\nexports.BANG = '!';\nexports.ONE_DOT = '.';\nexports.TWO_DOTS = '..';\nexports.STAR = '*';\nexports.GLOBSTAR = '**';\nexports.ROOT_GLOBSTAR = '/**/*';\nexports.SLASH_GLOBSTAR = '/**';\nexports.DIR_SUFFIX = 'Dir';\nexports.ANYMATCH_OPTS = {dot: true};\nexports.STRING_TYPE = 'string';\nexports.FUNCTION_TYPE = 'function';\nexports.EMPTY_STR = '';\nexports.EMPTY_FN = () => {};\nexports.IDENTITY_FN = val => val;\n\nexports.isWindows = platform === 'win32';\nexports.isMacos = platform === 'darwin';\nexports.isLinux = platform === 'linux';\n", "'use strict';\n\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst isBinaryPath = require('is-binary-path');\nconst {\n  isWindows,\n  isLinux,\n  EMPTY_FN,\n  EMPTY_STR,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE,\n  EV_ADD,\n  EV_ADD_DIR,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  BRACE_START,\n  STAR\n} = require('./constants');\n\nconst THROTTLE_MODE_WATCH = 'watch';\n\nconst open = promisify(fs.open);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst close = promisify(fs.close);\nconst fsrealpath = promisify(fs.realpath);\n\nconst statMethods = { lstat, stat };\n\n// TODO: emit errors properly. Example: EMFILE on Macos.\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\n\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n  container.add(item);\n};\n\nconst clearItem = cont => key => {\n  const set = cont[key];\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\n\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\n\nconst isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;\n\n/**\n * @typedef {String} Path\n */\n\n// fs_watch helpers\n\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\nconst FsWatchInstances = new Map();\n\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {watchedPath: path});\n\n    // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(\n        sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath)\n      );\n    }\n  };\n  try {\n    return fs.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], (listener) => {\n    listener(val1, val2, val3);\n  });\n};\n\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {listener, errHandler, rawEmitter} = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n\n  /** @type {fs.FSWatcher=} */\n  let watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(\n      path, options, listener, errHandler, rawEmitter\n    );\n    return watcher.close.bind(watcher);\n  }\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(\n      path,\n      options,\n      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),\n      errHandler, // no need to use broadcast here\n      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)\n    );\n    if (!watcher) return;\n    watcher.on(EV_ERROR, async (error) => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (isWindows && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close();\n      // }\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n// fs_watchFile helpers\n\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nconst FsWatchFileInstances = new Map();\n\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {listener, rawEmitter} = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n\n  /* eslint-disable no-unused-vars, prefer-destructuring */\n  let listeners = new Set();\n  let rawEmitters = new Set();\n\n  const copts = cont && cont.options;\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    // \"Upgrade\" the watcher to persistence or a quicker interval.\n    // This creates some unlikely edge case issues if the user mixes\n    // settings in a very weird way, but solving for those cases\n    // doesn't seem worthwhile for the added complexity.\n    listeners = cont.listeners;\n    rawEmitters = cont.rawEmitters;\n    fs.unwatchFile(fullPath);\n    cont = undefined;\n  }\n\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, (rawEmitter) => {\n          rawEmitter(EV_CHANGE, fullPath, {curr, prev});\n        });\n        const currmtime = curr.mtimeMs;\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, (listener) => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n/**\n * @mixin\n */\nclass NodeFsHandler {\n\n/**\n * @param {import(\"../index\").FSWatcher} fsW\n */\nconstructor(fsW) {\n  this.fsw = fsW;\n  this._boundHandleError = (error) => fsW._handleError(error);\n}\n\n/**\n * Watch file for changes with fs_watchFile or fs_watch.\n * @param {String} path to file or dir\n * @param {Function} listener on fs change\n * @returns {Function} closer for the watcher instance\n */\n_watchWithNodeFs(path, listener) {\n  const opts = this.fsw.options;\n  const directory = sysPath.dirname(path);\n  const basename = sysPath.basename(path);\n  const parent = this.fsw._getWatchedDir(directory);\n  parent.add(basename);\n  const absolutePath = sysPath.resolve(path);\n  const options = {persistent: opts.persistent};\n  if (!listener) listener = EMPTY_FN;\n\n  let closer;\n  if (opts.usePolling) {\n    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?\n      opts.binaryInterval : opts.interval;\n    closer = setFsWatchFileListener(path, absolutePath, options, {\n      listener,\n      rawEmitter: this.fsw._emitRaw\n    });\n  } else {\n    closer = setFsWatchListener(path, absolutePath, options, {\n      listener,\n      errHandler: this._boundHandleError,\n      rawEmitter: this.fsw._emitRaw\n    });\n  }\n  return closer;\n}\n\n/**\n * Watch a file and emit add event if warranted.\n * @param {Path} file Path\n * @param {fs.Stats} stats result of fs_stat\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @returns {Function} closer for the watcher instance\n */\n_handleFile(file, stats, initialAdd) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const dirname = sysPath.dirname(file);\n  const basename = sysPath.basename(file);\n  const parent = this.fsw._getWatchedDir(dirname);\n  // stats is always present\n  let prevStats = stats;\n\n  // if the file is already being watched, do nothing\n  if (parent.has(basename)) return;\n\n  const listener = async (path, newStats) => {\n    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n    if (!newStats || newStats.mtimeMs === 0) {\n      try {\n        const newStats = await stat(file);\n        if (this.fsw.closed) return;\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE, file, newStats);\n        }\n        if (isLinux && prevStats.ino !== newStats.ino) {\n          this.fsw._closeFile(path)\n          prevStats = newStats;\n          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n        } else {\n          prevStats = newStats;\n        }\n      } catch (error) {\n        // Fix issues where mtime is null but file is still present\n        this.fsw._remove(dirname, basename);\n      }\n      // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      // Check that change event was not fired because of changed only accessTime.\n      const at = newStats.atimeMs;\n      const mt = newStats.mtimeMs;\n      if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n        this.fsw._emit(EV_CHANGE, file, newStats);\n      }\n      prevStats = newStats;\n    }\n  }\n  // kick off the watcher\n  const closer = this._watchWithNodeFs(file, listener);\n\n  // emit an add event if we're supposed to\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n    if (!this.fsw._throttle(EV_ADD, file, 0)) return;\n    this.fsw._emit(EV_ADD, file, stats);\n  }\n\n  return closer;\n}\n\n/**\n * Handle symlinks encountered while reading a dir.\n * @param {Object} entry returned by readdirp\n * @param {String} directory path of dir being read\n * @param {String} path of this item\n * @param {String} item basename of this item\n * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n */\nasync _handleSymlink(entry, directory, path, item) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const full = entry.fullPath;\n  const dir = this.fsw._getWatchedDir(directory);\n\n  if (!this.fsw.options.followSymlinks) {\n    // watch symlink directly (don't follow) and detect changes\n    this.fsw._incrReadyCount();\n    const linkPath = await fsrealpath(path);\n    if (this.fsw.closed) return;\n    if (dir.has(item)) {\n      if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n        this.fsw._symlinkPaths.set(full, linkPath);\n        this.fsw._emit(EV_CHANGE, path, entry.stats);\n      }\n    } else {\n      dir.add(item);\n      this.fsw._symlinkPaths.set(full, linkPath);\n      this.fsw._emit(EV_ADD, path, entry.stats);\n    }\n    this.fsw._emitReady();\n    return true;\n  }\n\n  // don't follow the same symlink more than once\n  if (this.fsw._symlinkPaths.has(full)) {\n    return true;\n  }\n\n  this.fsw._symlinkPaths.set(full, true);\n}\n\n_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n  // Normalize the directory name on Windows\n  directory = sysPath.join(directory, EMPTY_STR);\n\n  if (!wh.hasGlob) {\n    throttler = this.fsw._throttle('readdir', directory, 1000);\n    if (!throttler) return;\n  }\n\n  const previous = this.fsw._getWatchedDir(wh.path);\n  const current = new Set();\n\n  let stream = this.fsw._readdirp(directory, {\n    fileFilter: entry => wh.filterPath(entry),\n    directoryFilter: entry => wh.filterDir(entry),\n    depth: 0\n  }).on(STR_DATA, async (entry) => {\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    const item = entry.path;\n    let path = sysPath.join(directory, item);\n    current.add(item);\n\n    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {\n      return;\n    }\n\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    // Files that present in current directory snapshot\n    // but absent in previous are added to watch list and\n    // emit `add` event.\n    if (item === target || !target && !previous.has(item)) {\n      this.fsw._incrReadyCount();\n\n      // ensure relativeness of path is preserved in case of watcher reuse\n      path = sysPath.join(dir, sysPath.relative(dir, path));\n\n      this._addToNodeFs(path, initialAdd, wh, depth + 1);\n    }\n  }).on(EV_ERROR, this._boundHandleError);\n\n  return new Promise(resolve =>\n    stream.once(STR_END, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      const wasThrottled = throttler ? throttler.clear() : false;\n\n      resolve();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.getChildren().filter((item) => {\n        return item !== directory &&\n          !current.has(item) &&\n          // in case of intersecting globs;\n          // a path may have been filtered out of this readdir, but\n          // shouldn't be removed because it matches a different glob\n          (!wh.hasGlob || wh.filterPath({\n            fullPath: sysPath.resolve(directory, item)\n          }));\n      }).forEach((item) => {\n        this.fsw._remove(directory, item);\n      });\n\n      stream = undefined;\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    })\n  );\n}\n\n/**\n * Read directory to add / remove files from `@watched` list and re-read it on change.\n * @param {String} dir fs path\n * @param {fs.Stats} stats\n * @param {Boolean} initialAdd\n * @param {Number} depth relative to user-supplied path\n * @param {String} target child path targeted for watch\n * @param {Object} wh Common watch helpers for this path\n * @param {String} realpath\n * @returns {Promise<Function>} closer for the watcher instance.\n */\nasync _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n  const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));\n  const tracked = parentDir.has(sysPath.basename(dir));\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);\n  }\n\n  // ensure dir is tracked (harmless if redundant)\n  parentDir.add(sysPath.basename(dir));\n  this.fsw._getWatchedDir(dir);\n  let throttler;\n  let closer;\n\n  const oDepth = this.fsw.options.depth;\n  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n    if (!target) {\n      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n      if (this.fsw.closed) return;\n    }\n\n    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n      // if current directory is removed, do nothing\n      if (stats && stats.mtimeMs === 0) return;\n\n      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n    });\n  }\n  return closer;\n}\n\n/**\n * Handle added file, directory, or glob pattern.\n * Delegates call to _handleFile / _handleDir after checks.\n * @param {String} path to file or ir\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @param {Object} priorWh depth relative to user-supplied path\n * @param {Number} depth Child path actually targeted for watch\n * @param {String=} target Child path actually targeted for watch\n * @returns {Promise}\n */\nasync _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n  const ready = this.fsw._emitReady;\n  if (this.fsw._isIgnored(path) || this.fsw.closed) {\n    ready();\n    return false;\n  }\n\n  const wh = this.fsw._getWatchHelpers(path, depth);\n  if (!wh.hasGlob && priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = entry => priorWh.filterPath(entry);\n    wh.filterDir = entry => priorWh.filterDir(entry);\n  }\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return false;\n    }\n\n    const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);\n    let closer;\n    if (stats.isDirectory()) {\n      const absPath = sysPath.resolve(path);\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n      if (this.fsw.closed) return;\n      // preserve this symlink's target path\n      if (absPath !== targetPath && targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(absPath, targetPath);\n      }\n    } else if (stats.isSymbolicLink()) {\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      const parent = sysPath.dirname(wh.watchPath);\n      this.fsw._getWatchedDir(parent).add(wh.watchPath);\n      this.fsw._emit(EV_ADD, wh.watchPath, stats);\n      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n      if (this.fsw.closed) return;\n\n      // preserve this symlink's target path\n      if (targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);\n      }\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd);\n    }\n    ready();\n\n    this.fsw._addPathCloser(path, closer);\n    return false;\n\n  } catch (error) {\n    if (this.fsw._handleError(error)) {\n      ready();\n      return path;\n    }\n  }\n}\n\n}\n\nmodule.exports = NodeFsHandler;\n", "'use strict';\n\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\n\nlet fsevents;\ntry {\n  fsevents = require('fsevents');\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst {\n  EV_ADD,\n  EV_CHANGE,\n  EV_ADD_DIR,\n  EV_UNLINK,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE,\n  EMPTY_FN,\n  IDENTITY_FN\n} = require('./constants');\n\nconst Depth = (value) => isNaN(value) ? {} : {depth: value};\n\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\nconst statMethods = { stat, lstat };\n\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n\n// fsevents instance helper functions\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\nconst FSEventsWatchers = new Map();\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nconst consolidateThreshhold = 10;\n\nconst wrongEventFlags = new Set([\n  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\n]);\n\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {stop};\n};\n\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;\n  const parentPath = sysPath.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = sysPath.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (\n      fullPath === resolvedPath ||\n      !fullPath.indexOf(resolvedPath + sysPath.sep)\n    ) listener(fullPath, flags, info);\n  };\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  let watchedParent = false;\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  }\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return () => {\n    const lst = cont.listeners;\n\n    lst.delete(filteredListener);\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nconst couldConsolidate = (path) => {\n  let count = 0;\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// returns boolean indicating whether fsevents can be used\nconst canUse = () => fsevents && FSEventsWatchers.size < 128;\n\n// determines subdirectory traversal levels from root to path\nconst calcDepth = (path, root) => {\n  let i = 0;\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\n  return i;\n};\n\n// returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\nconst sameTypes = (info, stats) => (\n  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||\n  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||\n  info.type === FSEVENT_TYPE_FILE && stats.isFile()\n)\n\n/**\n * @mixin\n */\nclass FsEventsHandler {\n\n/**\n * @param {import('../index').FSWatcher} fsw\n */\nconstructor(fsw) {\n  this.fsw = fsw;\n}\ncheckIgnored(path, stats) {\n  const ipaths = this.fsw._ignoredPaths;\n  if (this.fsw._isIgnored(path, stats)) {\n    ipaths.add(path);\n    if (stats && stats.isDirectory()) {\n      ipaths.add(path + ROOT_GLOBSTAR);\n    }\n    return true;\n  }\n\n  ipaths.delete(path);\n  ipaths.delete(path + ROOT_GLOBSTAR);\n}\n\naddOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;\n  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n}\n\nasync checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  try {\n    const stats = await stat(path)\n    if (this.fsw.closed) return;\n    if (sameTypes(info, stats)) {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  } catch (error) {\n    if (error.code === 'EACCES') {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  }\n}\n\nhandleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  if (this.fsw.closed || this.checkIgnored(path)) return;\n\n  if (event === EV_UNLINK) {\n    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY\n    // suppress unlink events on never before seen files\n    if (isDirectory || watchedDir.has(item)) {\n      this.fsw._remove(parent, item, isDirectory);\n    }\n  } else {\n    if (event === EV_ADD) {\n      // track new directories\n      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n        // push symlinks back to the top of the stack to get handled\n        const curDepth = opts.depth === undefined ?\n          undefined : calcDepth(fullPath, realPath) + 1;\n        return this._addToFsEvents(path, false, true, curDepth);\n      }\n\n      // track new paths\n      // (other than symlinks being followed, which will be tracked soon)\n      this.fsw._getWatchedDir(parent).add(item);\n    }\n    /**\n     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n     */\n    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n    this.fsw._emit(eventName, path);\n    if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);\n  }\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} watchPath  - file/dir path to be watched with fsevents\n * @param {String} realPath   - real path (in case of symlinks)\n * @param {Function} transform  - path transformer\n * @param {Function} globFilter - path filter in case a glob pattern was provided\n * @returns {Function} closer for the watcher instance\n*/\n_watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n  if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\n  const opts = this.fsw.options;\n  const watchCallback = async (fullPath, flags, info) => {\n    if (this.fsw.closed) return;\n    if (\n      opts.depth !== undefined &&\n      calcDepth(fullPath, realPath) > opts.depth\n    ) return;\n    const path = transform(sysPath.join(\n      watchPath, sysPath.relative(watchPath, fullPath)\n    ));\n    if (globFilter && !globFilter(path)) return;\n    // ensure directories are tracked\n    const parent = sysPath.dirname(path);\n    const item = sysPath.basename(path);\n    const watchedDir = this.fsw._getWatchedDir(\n      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent\n    );\n\n    // correct for wrong events emitted\n    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n      if (typeof opts.ignored === FUNCTION_TYPE) {\n        let stats;\n        try {\n          stats = await stat(path);\n        } catch (error) {}\n        if (this.fsw.closed) return;\n        if (this.checkIgnored(path, stats)) return;\n        if (sameTypes(info, stats)) {\n          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        } else {\n          this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } else {\n      switch (info.event) {\n      case FSEVENT_CREATED:\n      case FSEVENT_MODIFIED:\n        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      case FSEVENT_DELETED:\n      case FSEVENT_MOVED:\n        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  };\n\n  const closer = setFSEventsListener(\n    watchPath,\n    realPath,\n    watchCallback,\n    this.fsw._emitRaw\n  );\n\n  this.fsw._emitReady();\n  return closer;\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} linkPath path to symlink\n * @param {String} fullPath absolute path to the symlink\n * @param {Function} transform pre-existing path transformer\n * @param {Number} curDepth level of subdirectories traversed to where symlink is\n * @returns {Promise<void>}\n */\nasync _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n  // don't follow the same symlink more than once\n  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n  this.fsw._symlinkPaths.set(fullPath, true);\n  this.fsw._incrReadyCount();\n\n  try {\n    const linkTarget = await realpath(linkPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(linkTarget)) {\n      return this.fsw._emitReady();\n    }\n\n    this.fsw._incrReadyCount();\n\n    // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link's path\n    this._addToFsEvents(linkTarget || linkPath, (path) => {\n      let aliasedPath = linkPath;\n      if (linkTarget && linkTarget !== DOT_SLASH) {\n        aliasedPath = path.replace(linkTarget, linkPath);\n      } else if (path !== DOT_SLASH) {\n        aliasedPath = sysPath.join(linkPath, path);\n      }\n      return transform(aliasedPath);\n    }, false, curDepth);\n  } catch(error) {\n    if (this.fsw._handleError(error)) {\n      return this.fsw._emitReady();\n    }\n  }\n}\n\n/**\n *\n * @param {Path} newPath\n * @param {fs.Stats} stats\n */\nemitAdd(newPath, stats, processPath, opts, forceAdd) {\n  const pp = processPath(newPath);\n  const isDir = stats.isDirectory();\n  const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));\n  const base = sysPath.basename(pp);\n\n  // ensure empty dirs get tracked\n  if (isDir) this.fsw._getWatchedDir(pp);\n  if (dirObj.has(base)) return;\n  dirObj.add(base);\n\n  if (!opts.ignoreInitial || forceAdd === true) {\n    this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);\n  }\n}\n\ninitWatch(realPath, path, wh, processPath) {\n  if (this.fsw.closed) return;\n  const closer = this._watchWithFsEvents(\n    wh.watchPath,\n    sysPath.resolve(realPath || wh.watchPath),\n    processPath,\n    wh.globFilter\n  );\n  this.fsw._addPathCloser(path, closer);\n}\n\n/**\n * Handle added path with fsevents\n * @param {String} path file/dir path or glob pattern\n * @param {Function|Boolean=} transform converts working path to what the user expects\n * @param {Boolean=} forceAdd ensure add is emitted\n * @param {Number=} priorDepth Level of subdirectories already traversed.\n * @returns {Promise<void>}\n */\nasync _addToFsEvents(path, transform, forceAdd, priorDepth) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const opts = this.fsw.options;\n  const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\n\n  const wh = this.fsw._getWatchHelpers(path);\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      throw null;\n    }\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\n\n      // don't recurse further if it would exceed depth setting\n      if (priorDepth && priorDepth > opts.depth) return;\n\n      // scan the contents of the dir\n      this.fsw._readdirp(wh.watchPath, {\n        fileFilter: entry => wh.filterPath(entry),\n        directoryFilter: entry => wh.filterDir(entry),\n        ...Depth(opts.depth - (priorDepth || 0))\n      }).on(STR_DATA, (entry) => {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (this.fsw.closed) {\n          return;\n        }\n        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n\n        const joinedPath = sysPath.join(wh.watchPath, entry.path);\n        const {fullPath} = entry;\n\n        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n          // preserve the current depth here since it can't be derived from\n          // real paths past the symlink\n          const curDepth = opts.depth === undefined ?\n            undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n        }\n      }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {\n        this.fsw._emitReady();\n      });\n    } else {\n      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n      this.fsw._emitReady();\n    }\n  } catch (error) {\n    if (!error || this.fsw._handleError(error)) {\n      // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n      this.fsw._emitReady();\n      this.fsw._emitReady();\n    }\n  }\n\n  if (opts.persistent && forceAdd !== true) {\n    if (typeof transform === FUNCTION_TYPE) {\n      // realpath has already been resolved\n      this.initWatch(undefined, path, wh, processPath);\n    } else {\n      let realPath;\n      try {\n        realPath = await realpath(wh.watchPath);\n      } catch (e) {}\n      this.initWatch(realPath, path, wh, processPath);\n    }\n  }\n}\n\n}\n\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;\n", "'use strict';\n\nconst { EventEmitter } = require('events');\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst readdirp = require('readdirp');\nconst anymatch = require('anymatch').default;\nconst globParent = require('glob-parent');\nconst isGlob = require('is-glob');\nconst braces = require('braces');\nconst normalizePath = require('normalize-path');\n\nconst NodeFsHandler = require('./lib/nodefs-handler');\nconst FsEventsHandler = require('./lib/fsevents-handler');\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n\n  STR_CLOSE,\n  STR_END,\n\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n\n  isWindows,\n  isMacos\n} = require('./lib/constants');\n\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = (value = []) => Array.isArray(value) ? value : [value];\nconst flatten = (list, result = []) => {\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = (paths_) => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n  return paths.map(normalizePathToUnix);\n};\n\n// If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\nconst toUnix = (string) => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n  if (prepend) {\n    str = SLASH + str;\n  }\n  return str;\n};\n\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));\n\nconst normalizeIgnored = (cwd = EMPTY_STR) => (path) => {\n  if (typeof path !== STRING_TYPE) return path;\n  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n};\n\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n  return sysPath.join(cwd, path);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {items} = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {items} = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n\n    const dir = this.path;\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {items} = this;\n    if (!items) return;\n    return items.has(item);\n  }\n\n  /**\n   * @returns {Array<String>}\n   */\n  getChildren() {\n    const {items} = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach((parts) => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?\n        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return sysPath.join(this.watchPath,\n      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))\n    );\n  }\n\n  filterPath(entry) {\n    const {stats} = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?\n      this.globFilter(resolvedPath) : true;\n    return matchesGlob &&\n      this.fsw._isntIgnored(resolvedPath, stats) &&\n      this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach((path) => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some((parts) => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n}\n\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nclass FSWatcher extends EventEmitter {\n// Not indenting methods for history sake; for now.\nconstructor(_opts) {\n  super();\n\n  const opts = {};\n  if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n  /** @type {Map<String, DirEntry>} */\n  this._watched = new Map();\n  /** @type {Map<String, Array>} */\n  this._closers = new Map();\n  /** @type {Set<String>} */\n  this._ignoredPaths = new Set();\n\n  /** @type {Map<ThrottleType, Map>} */\n  this._throttled = new Map();\n\n  /** @type {Map<Path, String|Boolean>} */\n  this._symlinkPaths = new Map();\n\n  this._streams = new Set();\n  this.closed = false;\n\n  // Set up default options.\n  if (undef(opts, 'persistent')) opts.persistent = true;\n  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n  if (undef(opts, 'interval')) opts.interval = 100;\n  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n  // Enable fsevents on OS X when polling isn't explicitly enabled.\n  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n  // If we can't use fsevents, ensure the options reflect it's disabled.\n  const canUseFsEvents = FsEventsHandler.canUse();\n  if (!canUseFsEvents) opts.useFsEvents = false;\n\n  // Use polling on Mac if not using fsevents.\n  // Other platforms use non-polling fs_watch.\n  if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n    opts.usePolling = isMacos;\n  }\n\n  // Global override (useful for end-developers that need to force polling for all\n  // instances of chokidar, regardless of usage/dependency depth)\n  const envPoll = process.env.CHOKIDAR_USEPOLLING;\n  if (envPoll !== undefined) {\n    const envLower = envPoll.toLowerCase();\n\n    if (envLower === 'false' || envLower === '0') {\n      opts.usePolling = false;\n    } else if (envLower === 'true' || envLower === '1') {\n      opts.usePolling = true;\n    } else {\n      opts.usePolling = !!envLower;\n    }\n  }\n  const envInterval = process.env.CHOKIDAR_INTERVAL;\n  if (envInterval) {\n    opts.interval = Number.parseInt(envInterval, 10);\n  }\n\n  // Editor atomic write normalization enabled by default with fs.watch\n  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n  if (opts.atomic) this._pendingUnlinks = new Map();\n\n  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n\n  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n  const awf = opts.awaitWriteFinish;\n  if (awf) {\n    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n    if (!awf.pollInterval) awf.pollInterval = 100;\n    this._pendingWrites = new Map();\n  }\n  if (opts.ignored) opts.ignored = arrify(opts.ignored);\n\n  let readyCalls = 0;\n  this._emitReady = () => {\n    readyCalls++;\n    if (readyCalls >= this._readyCount) {\n      this._emitReady = EMPTY_FN;\n      this._readyEmitted = true;\n      // use process.nextTick to allow time for listener to be bound\n      process.nextTick(() => this.emit(EV_READY));\n    }\n  };\n  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n  this._readyEmitted = false;\n  this.options = opts;\n\n  // Initialize with proper watcher.\n  if (opts.useFsEvents) {\n    this._fsEventsHandler = new FsEventsHandler(this);\n  } else {\n    this._nodeFsHandler = new NodeFsHandler(this);\n  }\n\n  // You\u2019re frozen when your heart\u2019s not open.\n  Object.freeze(opts);\n}\n\n// Public methods\n\n/**\n * Adds paths to be watched on an existing FSWatcher instance\n * @param {Path|Array<Path>} paths_\n * @param {String=} _origAdd private; for handling non-existent paths to be watched\n * @param {Boolean=} _internal private; indicates a non-user add\n * @returns {FSWatcher} for chaining\n */\nadd(paths_, _origAdd, _internal) {\n  const {cwd, disableGlobbing} = this.options;\n  this.closed = false;\n  let paths = unifyPaths(paths_);\n  if (cwd) {\n    paths = paths.map((path) => {\n      const absPath = getAbsolutePath(path, cwd);\n\n      // Check `path` instead of `absPath` because the cwd portion can't be a glob\n      if (disableGlobbing || !isGlob(path)) {\n        return absPath;\n      }\n      return normalizePath(absPath);\n    });\n  }\n\n  // set aside negated glob strings\n  paths = paths.filter((path) => {\n    if (path.startsWith(BANG)) {\n      this._ignoredPaths.add(path.slice(1));\n      return false;\n    }\n\n    // if a path is being added that was previously ignored, stop ignoring it\n    this._ignoredPaths.delete(path);\n    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n\n    return true;\n  });\n\n  if (this.options.useFsEvents && this._fsEventsHandler) {\n    if (!this._readyCount) this._readyCount = paths.length;\n    if (this.options.persistent) this._readyCount *= 2;\n    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));\n  } else {\n    if (!this._readyCount) this._readyCount = 0;\n    this._readyCount += paths.length;\n    Promise.all(\n      paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })\n    ).then(results => {\n      if (this.closed) return;\n      results.filter(item => item).forEach(item => {\n        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n      });\n    });\n  }\n\n  return this;\n}\n\n/**\n * Close watchers or start ignoring events from specified paths.\n * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n * @returns {FSWatcher} for chaining\n*/\nunwatch(paths_) {\n  if (this.closed) return this;\n  const paths = unifyPaths(paths_);\n  const {cwd} = this.options;\n\n  paths.forEach((path) => {\n    // convert to absolute path unless relative path already matches\n    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n      if (cwd) path = sysPath.join(cwd, path);\n      path = sysPath.resolve(path);\n    }\n\n    this._closePath(path);\n\n    this._ignoredPaths.add(path);\n    if (this._watched.has(path)) {\n      this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n    }\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n  });\n\n  return this;\n}\n\n/**\n * Close watchers and remove all listeners from watched paths.\n * @returns {Promise<void>}.\n*/\nclose() {\n  if (this.closed) return this._closePromise;\n  this.closed = true;\n\n  // Memory management.\n  this.removeAllListeners();\n  const closers = [];\n  this._closers.forEach(closerList => closerList.forEach(closer => {\n    const promise = closer();\n    if (promise instanceof Promise) closers.push(promise);\n  }));\n  this._streams.forEach(stream => stream.destroy());\n  this._userIgnored = undefined;\n  this._readyCount = 0;\n  this._readyEmitted = false;\n  this._watched.forEach(dirent => dirent.dispose());\n  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n    this[`_${key}`].clear();\n  });\n\n  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n  return this._closePromise;\n}\n\n/**\n * Expose list of watched paths\n * @returns {Object} for chaining\n*/\ngetWatched() {\n  const watchList = {};\n  this._watched.forEach((entry, dir) => {\n    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n    watchList[key || ONE_DOT] = entry.getChildren().sort();\n  });\n  return watchList;\n}\n\nemitWithAll(event, args) {\n  this.emit(...args);\n  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n}\n\n// Common helpers\n// --------------\n\n/**\n * Normalize and emit events.\n * Calling _emit DOES NOT MEAN emit() would be called!\n * @param {EventName} event Type of event\n * @param {Path} path File or directory path\n * @param {*=} val1 arguments to be passed with event\n * @param {*=} val2\n * @param {*=} val3\n * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\nasync _emit(event, path, val1, val2, val3) {\n  if (this.closed) return;\n\n  const opts = this.options;\n  if (isWindows) path = sysPath.normalize(path);\n  if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n  /** @type Array<any> */\n  const args = [event, path];\n  if (val3 !== undefined) args.push(val1, val2, val3);\n  else if (val2 !== undefined) args.push(val1, val2);\n  else if (val1 !== undefined) args.push(val1);\n\n  const awf = opts.awaitWriteFinish;\n  let pw;\n  if (awf && (pw = this._pendingWrites.get(path))) {\n    pw.lastChange = new Date();\n    return this;\n  }\n\n  if (opts.atomic) {\n    if (event === EV_UNLINK) {\n      this._pendingUnlinks.set(path, args);\n      setTimeout(() => {\n        this._pendingUnlinks.forEach((entry, path) => {\n          this.emit(...entry);\n          this.emit(EV_ALL, ...entry);\n          this._pendingUnlinks.delete(path);\n        });\n      }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n      return this;\n    }\n    if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n      event = args[0] = EV_CHANGE;\n      this._pendingUnlinks.delete(path);\n    }\n  }\n\n  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n    const awfEmit = (err, stats) => {\n      if (err) {\n        event = args[0] = EV_ERROR;\n        args[1] = err;\n        this.emitWithAll(event, args);\n      } else if (stats) {\n        // if stats doesn't exist the file must have been deleted\n        if (args.length > 2) {\n          args[2] = stats;\n        } else {\n          args.push(stats);\n        }\n        this.emitWithAll(event, args);\n      }\n    };\n\n    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n    return this;\n  }\n\n  if (event === EV_CHANGE) {\n    const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n    if (isThrottled) return this;\n  }\n\n  if (opts.alwaysStat && val1 === undefined &&\n    (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)\n  ) {\n    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n    let stats;\n    try {\n      stats = await stat(fullPath);\n    } catch (err) {}\n    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n    if (!stats || this.closed) return;\n    args.push(stats);\n  }\n  this.emitWithAll(event, args);\n\n  return this;\n}\n\n/**\n * Common handler for errors\n * @param {Error} error\n * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\n_handleError(error) {\n  const code = error && error.code;\n  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&\n    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))\n  ) {\n    this.emit(EV_ERROR, error);\n  }\n  return error || this.closed;\n}\n\n/**\n * Helper utility for throttling\n * @param {ThrottleType} actionType type being throttled\n * @param {Path} path being acted upon\n * @param {Number} timeout duration of time to suppress duplicate actions\n * @returns {Object|false} tracking object or false if action should be suppressed\n */\n_throttle(actionType, path, timeout) {\n  if (!this._throttled.has(actionType)) {\n    this._throttled.set(actionType, new Map());\n  }\n\n  /** @type {Map<Path, Object>} */\n  const action = this._throttled.get(actionType);\n  /** @type {Object} */\n  const actionPath = action.get(path);\n\n  if (actionPath) {\n    actionPath.count++;\n    return false;\n  }\n\n  let timeoutObject;\n  const clear = () => {\n    const item = action.get(path);\n    const count = item ? item.count : 0;\n    action.delete(path);\n    clearTimeout(timeoutObject);\n    if (item) clearTimeout(item.timeoutObject);\n    return count;\n  };\n  timeoutObject = setTimeout(clear, timeout);\n  const thr = {timeoutObject, clear, count: 0};\n  action.set(path, thr);\n  return thr;\n}\n\n_incrReadyCount() {\n  return this._readyCount++;\n}\n\n/**\n * Awaits write operation to finish.\n * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n * @param {Path} path being acted upon\n * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n * @param {EventName} event\n * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n */\n_awaitWriteFinish(path, threshold, event, awfEmit) {\n  let timeoutHandler;\n\n  let fullPath = path;\n  if (this.options.cwd && !sysPath.isAbsolute(path)) {\n    fullPath = sysPath.join(this.options.cwd, path);\n  }\n\n  const now = new Date();\n\n  const awaitWriteFinish = (prevStat) => {\n    fs.stat(fullPath, (err, curStat) => {\n      if (err || !this._pendingWrites.has(path)) {\n        if (err && err.code !== 'ENOENT') awfEmit(err);\n        return;\n      }\n\n      const now = Number(new Date());\n\n      if (prevStat && curStat.size !== prevStat.size) {\n        this._pendingWrites.get(path).lastChange = now;\n      }\n      const pw = this._pendingWrites.get(path);\n      const df = now - pw.lastChange;\n\n      if (df >= threshold) {\n        this._pendingWrites.delete(path);\n        awfEmit(undefined, curStat);\n      } else {\n        timeoutHandler = setTimeout(\n          awaitWriteFinish,\n          this.options.awaitWriteFinish.pollInterval,\n          curStat\n        );\n      }\n    });\n  };\n\n  if (!this._pendingWrites.has(path)) {\n    this._pendingWrites.set(path, {\n      lastChange: now,\n      cancelWait: () => {\n        this._pendingWrites.delete(path);\n        clearTimeout(timeoutHandler);\n        return event;\n      }\n    });\n    timeoutHandler = setTimeout(\n      awaitWriteFinish,\n      this.options.awaitWriteFinish.pollInterval\n    );\n  }\n}\n\n_getGlobIgnored() {\n  return [...this._ignoredPaths.values()];\n}\n\n/**\n * Determines whether user has asked to ignore this path.\n * @param {Path} path filepath or dir\n * @param {fs.Stats=} stats result of fs.stat\n * @returns {Boolean}\n */\n_isIgnored(path, stats) {\n  if (this.options.atomic && DOT_RE.test(path)) return true;\n  if (!this._userIgnored) {\n    const {cwd} = this.options;\n    const ign = this.options.ignored;\n\n    const ignored = ign && ign.map(normalizeIgnored(cwd));\n    const paths = arrify(ignored)\n      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))\n      .map((path) => path + SLASH_GLOBSTAR);\n    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n  }\n\n  return this._userIgnored([path, stats]);\n}\n\n_isntIgnored(path, stat) {\n  return !this._isIgnored(path, stat);\n}\n\n/**\n * Provides a set of common helpers and properties relating to symlink and glob handling.\n * @param {Path} path file, directory, or glob pattern being watched\n * @param {Number=} depth at any depth > 0, this isn't a glob\n * @returns {WatchHelper} object containing helpers for this path\n */\n_getWatchHelpers(path, depth) {\n  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n  const follow = this.options.followSymlinks;\n\n  return new WatchHelper(path, watchPath, follow, this);\n}\n\n// Directory helpers\n// -----------------\n\n/**\n * Provides directory tracking objects\n * @param {String} directory path of the directory\n * @returns {DirEntry} the directory's tracking object\n */\n_getWatchedDir(directory) {\n  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n  const dir = sysPath.resolve(directory);\n  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n  return this._watched.get(dir);\n}\n\n// File helpers\n// ------------\n\n/**\n * Check for read permissions.\n * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n * @param {fs.Stats} stats - object, result of fs_stat\n * @returns {Boolean} indicates whether the file can be read\n*/\n_hasReadPermissions(stats) {\n  if (this.options.ignorePermissionErrors) return true;\n\n  // stats.mode may be bigint\n  const md = stats && Number.parseInt(stats.mode, 10);\n  const st = md & 0o777;\n  const it = Number.parseInt(st.toString(8)[0], 10);\n  return Boolean(4 & it);\n}\n\n/**\n * Handles emitting unlink events for\n * files and directories, and via recursion, for\n * files and directories within directories that are unlinked\n * @param {String} directory within which the following item is located\n * @param {String} item      base path of item/directory\n * @returns {void}\n*/\n_remove(directory, item, isDirectory) {\n  // if what is being deleted is a directory, get that directory's paths\n  // for recursive deleting and cleaning of watched object\n  // if it is not a directory, nestedDirectoryChildren will be empty array\n  const path = sysPath.join(directory, item);\n  const fullPath = sysPath.resolve(path);\n  isDirectory = isDirectory != null\n    ? isDirectory\n    : this._watched.has(path) || this._watched.has(fullPath);\n\n  // prevent duplicate handling in case of arriving here nearly simultaneously\n  // via multiple paths (such as _handleFile and _handleDir)\n  if (!this._throttle('remove', path, 100)) return;\n\n  // if the only watched file is removed, watch for its return\n  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n    this.add(directory, item, true);\n  }\n\n  // This will create a new entry in the watched object in either case\n  // so we got to do the directory check beforehand\n  const wp = this._getWatchedDir(path);\n  const nestedDirectoryChildren = wp.getChildren();\n\n  // Recursively remove children directories / files.\n  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\n\n  // Check if item was on the watched list and remove it\n  const parent = this._getWatchedDir(directory);\n  const wasTracked = parent.has(item);\n  parent.remove(item);\n\n  // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n  // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n  // but never removed from the map in case the path was deleted.\n  // This leads to an incorrect state if the path was recreated:\n  // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n  if (this._symlinkPaths.has(fullPath)) {\n    this._symlinkPaths.delete(fullPath);\n  }\n\n  // If we wait for this file to be fully written, cancel the wait.\n  let relPath = path;\n  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n    const event = this._pendingWrites.get(relPath).cancelWait();\n    if (event === EV_ADD) return;\n  }\n\n  // The Entry will either be a directory that just got removed\n  // or a bogus entry to a file, in either case we have to remove it\n  this._watched.delete(path);\n  this._watched.delete(fullPath);\n  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\n\n  // Avoid conflicts if we later create another file with the same name\n  if (!this.options.useFsEvents) {\n    this._closePath(path);\n  }\n}\n\n/**\n * Closes all watchers for a path\n * @param {Path} path\n */\n_closePath(path) {\n  this._closeFile(path)\n  const dir = sysPath.dirname(path);\n  this._getWatchedDir(dir).remove(sysPath.basename(path));\n}\n\n/**\n * Closes only file-specific watchers\n * @param {Path} path\n */\n_closeFile(path) {\n  const closers = this._closers.get(path);\n  if (!closers) return;\n  closers.forEach(closer => closer());\n  this._closers.delete(path);\n}\n\n/**\n *\n * @param {Path} path\n * @param {Function} closer\n */\n_addPathCloser(path, closer) {\n  if (!closer) return;\n  let list = this._closers.get(path);\n  if (!list) {\n    list = [];\n    this._closers.set(path, list);\n  }\n  list.push(closer);\n}\n\n_readdirp(root, opts) {\n  if (this.closed) return;\n  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};\n  let stream = readdirp(root, options);\n  this._streams.add(stream);\n  stream.once(STR_CLOSE, () => {\n    stream = undefined;\n  });\n  stream.once(STR_END, () => {\n    if (stream) {\n      this._streams.delete(stream);\n      stream = undefined;\n    }\n  });\n  return stream;\n}\n\n}\n\n// Export FSWatcher class\nexports.FSWatcher = FSWatcher;\n\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nexports.watch = watch;\n", "import * as filepath from \"path\"\nimport { Metafile as ESBuildMetafile } from \"esbuild\"\nimport { WatchOptions, WatchCallback, CancellablePromise, FileEvent } from \"../../estrella.d\"\nimport { BuildConfig, BuildContext } from \"../config\"\nimport * as _file from \"../file\"\nimport { log, LogLevel } from \"../log\"\nimport { repr } from \"../util\"\n\nimport { FSWatcher, FSWatcherOptions } from \"./fswatch\"\n\n\ntype FileModule = typeof _file\nlet file :FileModule\n\n\nexport function initModule(logLevel :LogLevel, filem :FileModule) {\n  log.level = logLevel\n  file = filem\n}\n\nfunction makeFSWatcherOptions(options :WatchOptions) :FSWatcherOptions {\n  return {\n    ...options,\n    isChangeSelfOriginating(filename :string) :boolean {\n      return file.fileWasModifiedRecentlyByUser(filename)\n    },\n  }\n}\n\n\nlet fswatcherMap = new Map<string,FSWatcher>() // projectID => FSWatcher\n\n\n// used by estrella itself, when config.watch is enabled\nexport async function watchFiles(\n  config         :BuildConfig,\n  getESBuildMeta :()=>ESBuildMetafile|null,\n  ctx            :BuildContext,\n  callback       :(changes :FileEvent[]) => Promise<void>,\n) :Promise<void> {\n  const projectID = config.projectID\n  let fswatcher = fswatcherMap.get(projectID)\n\n  if (!fswatcher) {\n    const watchOptions = config.watch && typeof config.watch == \"object\" ? config.watch : {}\n    fswatcher = new FSWatcher(makeFSWatcherOptions(watchOptions))\n    fswatcherMap.set(projectID, fswatcher)\n    fswatcher.basedir = config.cwd || process.cwd()\n    fswatcher.onChange = (changes) => {\n      // invoke the callback, which in turn rebuilds the project and writes a fresh\n      // esbuild metafile which we then read in refreshFiles.\n      callback(changes).then(refreshFiles)\n    }\n    ctx.addCancelCallback(() => {\n      fswatcher!.promise.cancel()\n    })\n    log.debug(`fswatch started for project#${projectID}`)\n  }\n\n  function refreshFiles() {\n    // Read metadata produced by esbuild, describing source files and product files.\n    // The metadata may be null or have a missing inputs prop in case esbuild failed.\n    const esbuildMeta = getESBuildMeta()\n    log.debug(\"fswatch refreshFiles with esbuildMeta\", esbuildMeta)\n    if (!esbuildMeta || !esbuildMeta.inputs) {\n      // esbuild failed -- don't change what files are being watched\n      return\n    }\n\n    // vars\n    const srcfiles = Object.keys(esbuildMeta.inputs) // {[filename:string]:{<info>}} => string[]\n        , outfiles = esbuildMeta.outputs || {} // {[filename:string]:{<info>}}\n\n    if (srcfiles.length == 0) {\n      // esbuild failed -- don't change what files are being watched\n      return\n    }\n\n    // path substrings for filtering out nodejs files\n    const nodeModulesPathPrefix = \"node_modules\" + filepath.sep\n    const nodeModulesPathSubstr = filepath.sep + nodeModulesPathPrefix\n    const isNodeModuleFile = (fn :string) => {\n      return fn.startsWith(nodeModulesPathPrefix) || fn.includes(nodeModulesPathSubstr)\n    }\n\n    // log\n    if (log.level >= log.DEBUG) {\n      const xs = srcfiles.filter(fn => !isNodeModuleFile(fn)).slice(0,10)\n      log.debug(\n        `fswatch updating source files: esbuild reported` +\n        ` ${srcfiles.length} inputs:` +\n        xs.map(fn => `\\n  ${fn}`).join(\"\") +\n        (xs.length < srcfiles.length ? `\\n  ... ${srcfiles.length-xs.length} more` : \"\")\n      )\n    }\n\n    // append output files to self-originating mod log\n    for (let fn of Object.keys(outfiles)) {\n      file.fileModificationLogAppend(fn)\n    }\n\n    // create list of source files\n    const sourceFiles = []\n    for (let fn of srcfiles) {\n      // exclude output files to avoid a loop\n      if (fn in outfiles) {\n        continue\n      }\n\n      // exclude files from libraries. Some projects may include hundreds or thousands of library\n      // files which would slow things down unncessarily.\n      if (srcfiles.length > 100 && isNodeModuleFile(fn)) {  // \"/node_modules/\"\n        continue\n      }\n      sourceFiles.push(fn)\n    }\n    fswatcher!.setFiles(sourceFiles)\n  }\n\n  refreshFiles()\n\n  return fswatcher.promise\n}\n\n\n// watch is a utility function exported in the estrella API\nexport function watch(\n  path :string|ReadonlyArray<string>,\n  cb   :WatchCallback,\n) :CancellablePromise<void>\n\nexport function watch(\n  path    :string|ReadonlyArray<string>,\n  options :WatchOptions|null|undefined,\n  cb      :WatchCallback,\n) :CancellablePromise<void>\n\nexport function watch(\n  path    :string|ReadonlyArray<string>,\n  options :WatchOptions|null|undefined | WatchCallback,\n  cb?     :WatchCallback,\n) :CancellablePromise<void> {\n  if (!cb) { // call form: watch(path, cb)\n    cb = options as WatchCallback\n    options = {}\n  }\n\n  const w = new FSWatcher(makeFSWatcherOptions({\n    // Defaults\n    persistent: true,\n    ignoreInitial: true,\n    ignored: /(^|[\\/\\\\])\\../, // ignore dotfiles\n    disableGlobbing: true,\n    followSymlinks: false,\n\n    // user override\n    ...(options || {})\n  }))\n  w.basedir = process.cwd()\n  w.onChange = cb!\n  w.setFiles(typeof path == \"string\" ? [path] : path)\n\n  return w.promise\n}\n", "import { Console } from \"console\"\nimport { stdoutStyle, stderrStyle } from \"./termstyle\"\nimport { memoize } from \"./memoize\"\nimport { prog } from \"./cli\"\nimport { captureStackTrace } from \"./error\"\n\nimport { Log as LogAPI } from \"../estrella\"\n\ndeclare const DEBUG :boolean\n\nexport interface Env {\n  log :typeof log\n}\n\nexport enum LogLevel {\n  Silent = -1,// log nothing\n  Error = 0,  // only log errors\n  Warn,       // log errors and warnings\n  Info,       // log errors, warnings and info\n  Debug,      // log everything\n}\n\nlet log_console = console\nlet log_colorMode :boolean|undefined = undefined\n\nexport const log = new class Log implements LogAPI {\n  readonly SILENT = LogLevel.Silent // = -1\n  readonly ERROR  = LogLevel.Error  // = 0\n  readonly WARN   = LogLevel.Warn   // = 1\n  readonly INFO   = LogLevel.Info   // = 2\n  readonly DEBUG  = LogLevel.Debug  // = 3\n\n  level = LogLevel.Info\n\n  error(...v :any[]) :void {\n    if (log.level >= LogLevel.Error) {\n      evalFunctionInArgs(v)\n      log_console.error(stderrStyle.red(`${prog}:`), ...v)\n    }\n  }\n  warn(...v :any[]) :void {\n    if (log.level >= LogLevel.Warn) {\n      evalFunctionInArgs(v)\n      log_console.error(stderrStyle.magenta(`${prog}:`), ...v)\n    }\n  }\n  info(...v :any[]) :void {\n    if (log.level >= LogLevel.Info) {\n      evalFunctionInArgs(v)\n      log_console.log(...v)\n    }\n  }\n\n  // DEPRECATED in Estrella 1.2.2\n  readonly infoOnce = this.info\n\n  readonly debug = log_debug\n\n  get colorMode() :boolean|undefined {\n    return log_colorMode\n  }\n  set colorMode(colorMode :boolean|undefined) {\n    if (log_colorMode === colorMode) {\n      return\n    }\n    log_colorMode = colorMode\n    if (colorMode === undefined) { // auto\n      log_console = console\n    } else {\n      log_console = new Console({\n        stdout: process.stdout,\n        stderr: process.stderr,\n        colorMode\n      })\n    }\n  }\n}\n\nexport default log\n\nfunction evalFunctionInArgs(args :any[]) {\n  // evaluate first function argument\n  if (typeof args[0] == \"function\") {\n    args[0] = args[0]()\n  }\n}\n\nfunction log_debug(...v :any[]) {\n  if (log.level >= LogLevel.Debug) {\n    let meta = \"\"\n\n    if (DEBUG) {\n      // stack traces are only useful in debug builds (not mangled)\n      const stack = captureStackTrace(log_debug)\n      const frames = stack.split(\"\\n\", 5)\n      const f = frames[1]  // stack frame\n      let m = f && /at (\\w+)/.exec(f)\n      if (m) {\n        meta = \" \" + m[1]\n      } else if (!m && frames[2]) {\n        if (m = frames[2] && /at (\\w+)/.exec(frames[2])) {\n          meta = ` ${m[1]} \u2192 ${stdoutStyle.italic(\"f\")}`\n        }\n      }\n    }\n\n    evalFunctionInArgs(v)\n\n    if (v.length == 0 || (v.length == 1 && (v[0] === \"\" || v[0] === undefined))) {\n      // Nothing to be logged.\n      // This is sometimes useful when logging something complex conditionally, for example:\n      //   log.debug(() => {\n      //     if (expensiveComputation()) {\n      //       return \"redirecting foobar to fuzlol\"\n      //     }\n      //   })\n      return\n    }\n\n    log_console.log(stdoutStyle.bold(stdoutStyle.blue(`[DEBUG${meta}]`)), ...v)\n  }\n}\n", "import {\n  TermStyle as TermStyleAPI,\n  TermStyleFun,\n  TTYStream,\n  NoTTYStream,\n} from \"../estrella\"\n\n\nexport interface TermStyle extends TermStyleAPI {\n  _hint :boolean|undefined  // original hint\n\n  // Like calling termStyle but instead of returning a new TermStyle object,\n  // the receiver (this) is updated/mutated.\n  reconfigure(w :TTYStream|NoTTYStream, hint? :boolean) :TermStyle\n}\n\n\nfunction numColors(w :TTYStream|NoTTYStream, hint? :boolean) {\n  let ncolors = 0\n  if (hint === true) {\n    // use colors regardless of TTY or not\n    let t = process.env.TERM || \"\"\n    ncolors = (\n      t && ['xterm','screen','vt100'].some(s => t.indexOf(s) != -1) ? (\n        t.indexOf('256color') != -1 ? 8 : 4\n      ) : 2\n    )\n  } else if (hint !== false && w.isTTY) {\n    // unless hint is explicitly false, use colors if stdout is a TTY\n    ncolors = w.getColorDepth()\n  }\n  return ncolors\n}\n\ntype TermStyleFunCons = (open16 :string, open256 :string, close :string) => TermStyleFun\n\n\nexport function termStyle(w :TTYStream|NoTTYStream, hint? :boolean) :TermStyle {\n  return createTermStyle(numColors(w, hint), hint)\n}\n\n\nexport function createTermStyle(ncolors :number, hint? :boolean) :TermStyle {\n  const CODE = (s :string) => `\\x1b[${s}m`\n\n  const effect :(open :string, close :string)=>TermStyleFun = (\n    ncolors > 0 || hint ? (open, close) => {\n      const a = CODE(open), b = CODE(close)\n      return s => a + s + b\n    } :\n    (_) => s => s\n  )\n\n  const color :TermStyleFunCons = (\n\n    // 256 colors support\n    ncolors >= 8 ? (_open16, open256, close) => {\n      // const open = CODE(code), close = CODE('2' + code)\n      let a = '\\x1b[' + open256 + 'm', b = '\\x1b[' + close + 'm'\n      return s => a + s + b\n    } :\n\n    // 16 colors support\n    ncolors > 0 ? (open16, _open256, close) => {\n      let a = '\\x1b[' + open16 + 'm', b = '\\x1b[' + close + 'm'\n      return s => a + s + b\n    } :\n\n    // no colors\n    (_open16, _open256, _close) => s => s\n  )\n\n  return {\n    _hint: hint,\n    ncolors,\n\n    reset     : hint || ncolors > 0 ? \"\\e[0m\" : \"\",\n\n    bold      : effect('1', '22'),\n    italic    : effect('3', '23'),\n    underline : effect('4', '24'),\n    inverse   : effect('7', '27'),\n\n    // name           16c    256c                 close\n    white       : color('37',  '38;2;255;255;255',  '39'),\n    grey        : color('90',  '38;5;244',          '39'),\n    black       : color('30',  '38;5;16',           '39'),\n    blue        : color('34',  '38;5;75',           '39'),\n    cyan        : color('36',  '38;5;87',           '39'),\n    green       : color('32',  '38;5;84',           '39'),\n    magenta     : color('35',  '38;5;213',          '39'),\n    purple      : color('35',  '38;5;141',          '39'),\n    pink        : color('35',  '38;5;211',          '39'),\n    red         : color('31',  '38;2;255;110;80',   '39'),\n    yellow      : color('33',  '38;5;227',          '39'),\n    lightyellow : color('93',  '38;5;229',          '39'),\n    orange      : color('33',  '38;5;215',          '39'),\n\n    reconfigure(w :TTYStream|NoTTYStream, hint? :boolean) :TermStyle {\n      const ncolors = numColors(w, hint)\n      if (ncolors != this.ncolors && hint != this._hint) {\n        Object.assign(this, createTermStyle(ncolors, hint))\n      }\n      return this\n    },\n\n  }\n}\n\nexport const stdoutStyle = termStyle(process.stdout)\nexport const stderrStyle = termStyle(process.stderr)\n", "import * as Path from \"path\"\nimport { json } from \"./util\"\n\n\n// parse CLI program name (as invoked)\nexport const prog = (() :string => {\n  const $_ = process.env[\"_\"]\n  const scriptfile = process.argv[1]\n  if (!scriptfile) {\n    // unlikely\n    return $_ || process.argv[0]\n  }\n  if ($_ && !Path.isAbsolute($_)) {\n    // accurate in some shells (like bash, but not in zsh)\n    return $_\n  }\n  let prefix = \"\"\n  if ($_) {\n    const nodeExecName = Path.basename(process.execPath)\n    if ($_.endsWith(Path.sep + nodeExecName)) {\n      // the script was invoked by explicitly calling node.\n      // e.g. \"node build.js\"\n      prefix = nodeExecName + \" \"\n    }\n  }\n  if (scriptfile.startsWith(process.cwd())) {\n    let rel = Path.relative(process.cwd(), scriptfile)\n    if (!rel.startsWith(\"node_modules\"+Path.sep) &&\n        rel.indexOf(Path.sep+\"node_modules\"+Path.sep) == -1\n    ) {\n      if (Path.sep == \"/\") {\n        // on posix systems, this is needed to avoid PATH resolution\n        rel = \"./\" + rel\n      }\n      return rel\n    }\n  }\n  return prefix + Path.basename(scriptfile)\n})()\n\n\nexport function printUsageAndExit(usage :string, errmsg? :string|null) {\n  const msg = usage.trim().replace(/\\$0\\b/g, prog)\n  if (errmsg) {\n    console.error(`${prog}: ${errmsg}\\n` + msg)\n    process.exit(1)\n  } else {\n    console.log(msg)\n    process.exit(0)\n  }\n}\n\n// parseopt types\nexport interface Doc {\n  usage?   :Usage|null\n  flags    :Flags[]\n  trailer? :string\n\n  // if true, treat an unknown flag as an argument (no error)\n  unknownFlagAsArg? :boolean\n\n  // help is a function which is invoked INSTEAD OF printing help and exiting the process.\n  // The function receives three values:\n  //   flags   -- available flags\n  //   options -- flag values parsed so far\n  //   args    -- remaining, unprocessed input arguments\n  // options and args are the same values returned by parseopt()\n  //\n  help? :( (flags: FlagInfo[], options :Options, args :string[]) => void ) | null\n}\nexport type Usage = string | (()=>string)\nexport type Flags = (Flag | null | undefined | false)[]  // falsy elements are ignored\nexport type Flag  = string | [ string|string[] , string?, string? ]\nexport interface FlagInfo {\n  names        :string[]\n  description? :string\n  valueName?   :string\n  valueType?   :string\n  valueParser? :(v:string)=>any\n}\nexport type Options = { [k :string] :any }\n\n// parseopt parses command-line arguments.\n// Returns options and unparsed remaining arguments.\n//\n// flag format:\n//\n//   flag      = flagname | flagspec\n//   flagname  = \"-\"* <text>\n//   flagnames = Array< flagname+ >\n//   flagspec  = Tuple< flagnames | flagname >\n//\n// flag format examples:\n//\n//   \"verbose\"\n//   Simple boolean flag that can be set with -verbose or --verbose.\n//\n//   [ \"v\", \"Show version\" ]\n//   Boolean flag \"v\" with description text shown in program usage.\n//\n//   [ \"v, version\", \"Show version\" ]\n//   [ [\"v\", \"version\"], \"Show version\" ]\n//   Boolean flag \"v\" with alternate name \"version\" with description.\n//\n//   [ [\"v\", \"version\"] ]\n//   Boolean flag \"v\" with alternate name \"version\" without description.\n//\n//   [ \"o\", \"Output file\", \"<path>\" ]\n//   Value flag with description. Value type defaults to string.\n//   Can be invoked as -o=path, --o=path, -o path, and --o path.\n//\n//   [ \"o\", \"\", \"<path>\" ]\n//   Value flag without description.\n//\n//   [ \"limit\", \"Show no more than <limit> items\", \"<limit:number>\" ]\n//   Value flag with type constraint. Passing a value that is not a JS number\n//   causes an error message.\n//\n//   [ \"with-openssl\", \"\", \"enable:bool\" ]\n//   Boolean flag\n//\nexport function parseopt(argv :string[], doc :Doc) :[Options, string[]] {\n  let [flagmap, opts] = parseFlags(doc.flags.filter(f => f) as Flag[])\n  let options :Options = {}\n  let help = false\n  let args :string[] = []\n  let i = 0\n\n  const eatArg = () => {\n    args.push(argv.splice(i, 1)[0])\n    i--\n  }\n\n  for (; i < argv.length; i++) {\n    // read argument\n    let arg = argv[i]\n    if (arg == '--') {\n      i++\n      break\n    }\n    if (arg[0] != '-' || arg == '-') {\n      eatArg()\n      continue\n    }\n    arg = arg.replace(/^\\-+/, '')\n    let eqp = arg.indexOf('=')\n    let argval :string|undefined = undefined\n    if (eqp != -1) {\n      // e.g. -name=value\n      argval = arg.substr(eqp + 1)\n      arg = arg.substr(0, eqp)\n    }\n\n    // lookup flag\n    let opt = flagmap.get(arg)\n    if (!opt) {\n      if (arg == \"h\" || arg == \"help\") {\n        help = true\n        if (!doc.help) {\n          console.log(fmtUsage(opts, doc.usage, doc.trailer))\n          process.exit(0)\n        }\n      } else if (doc.unknownFlagAsArg) {\n        eatArg()\n        continue\n      } else {\n        printUnknownOptionsAndExit([argv[i]])\n      }\n      break\n    }\n\n    // save option\n    let value :any = true\n    if (opt.valueName) {\n      if (argval === undefined) {\n        // -k v\n        argval = argv[i + 1]\n        if (argval !== undefined && argval[0] != \"-\") {\n          i++\n        // } else if (opt.valueType == \"boolean\") {\n        //   argval = \"true\"\n        } else {\n          console.error(`missing value for option -${arg} (see ${prog} -help)`)\n          process.exit(1)\n          break\n        }\n      } // else -k=v\n      try {\n        value = opt.valueParser ? opt.valueParser(argval) : argval\n      } catch (err) {\n        console.error(`invalid value for option -${arg} (${err.message})`)\n      }\n    } else if (argval !== undefined) {\n      console.error(`unexpected value provided for flag -${arg}`)\n      process.exit(1)\n    } // else: e.g. -k\n\n    options[arg] = value\n\n    // alias spread\n    for (let alias of opt.names) {\n      if (alias == arg) {\n        continue\n      }\n      options[alias] = value\n    }\n\n  } // for (; i < argv.length; i++)\n\n  if (i < argv.length) {\n    args = args.concat(argv.slice(i))\n  }\n\n  if (help && doc.help) {\n    doc.help(opts, options, args)\n  }\n\n  return [options, args]\n}\n\n\nexport function printUnknownOptionsAndExit(args :string[]) {\n  console.error(\n    `unknown option${args.length > 1 ? \"s\" : \"\"} ${args.join(\", \")} (see ${prog} -help)`)\n  process.exit(1)\n}\n\n\n// parseFlags parses falgs and returns normalized structured options.\n// Returns:\n//   [0] Mapping of argument name (e.g. \"help\") to options.\n//   [1] Unique set of options (e.g. {flags:[\"h\",\"help\"],...}).\n//\nexport function parseFlags(flags :Flag[]) :[ Map<string,FlagInfo>, FlagInfo[] ] {\n  let fimap = new Map<string,FlagInfo>()\n  let fiv :FlagInfo[] = []\n  for (let f of flags) {\n    let fi = parseFlag(f)\n    fiv.push(fi)\n    for (let k of fi.names) {\n      if (fimap.has(k)) {\n        throw new Error(`duplicate CLI flag ${json(k)} in definition ${json(f)}`)\n      }\n      fimap.set(k, fi)\n    }\n  }\n  return [fimap, fiv]\n}\n\n\nfunction parseFlag(f :Flag) :FlagInfo {\n  const cleanFlag = (s :string) => s.replace(/(?:^|[\\s,])\\-+/g, '')\n  const splitComma = (s :string) => s.split(/\\s*,\\s*/)\n\n  if (typeof f == \"string\") {\n    return { names: splitComma(cleanFlag(f)) }\n  }\n\n  let o :FlagInfo = {\n    names: (\n      typeof f[0] == \"string\" ? splitComma(cleanFlag(f[0])) :\n      f[0].map(cleanFlag)\n    ),\n    description: f[1] || undefined\n  }\n\n  if (f[2]) {\n    let [name, type] = f[2].replace(/^[<>]+|[<>]+$/g, '').split(/:/, 2)\n    if (type) {\n      switch (type.toLowerCase()) {\n\n        case 'string':\n        case 'str':\n          type = 'string'\n          break\n\n        case 'bool':\n        case 'boolean':\n          type = 'boolean'\n          o.valueParser = s => {\n            s = s.toLowerCase()\n            return s != \"false\" && s != \"0\" && s != \"no\" && s != \"off\"\n          }\n          break\n\n        case 'number':\n        case 'num':\n        case 'float':\n        case 'int':\n          type = 'number'\n          o.valueParser = s => {\n            let n = Number(s)\n            if (isNaN(n)) {\n              throw new Error(`${json(s)} is not a number`)\n            }\n            return n\n          }\n          break\n\n        default:\n          throw new Error(`invalid argument type \"${type}\"`)\n      }\n    } else {\n      type = \"string\"\n    }\n    o.valueName = name || type\n    o.valueType = type\n  }\n  return o\n}\n\n\nexport function fmtUsage(opts :FlagInfo[], usage? :Usage|null, trailer? :string) :string {\n  // s/$name/value/\n  let vars :{[k:string]:any} = {\n    prog: prog,\n    \"0\": prog,\n  }\n  const subvars = (s :string) :string => s.replace(/\\$(\\w+)/g, (_, v) => {\n    let sub = vars[v]\n    if (!sub) {\n      throw new Error(`unknown variable $${v} (to print a dollar sign, use '\\\\$')`)\n    }\n    return sub\n  })\n\n  // start with usage\n  let s = subvars(\n    usage ?\n      typeof usage == 'function' ? usage() :\n                                   String(usage) :\n    opts.length > 0 ?\n      `Usage: $prog [options]` :\n      `Usage: $prog`\n  )\n\n  if (opts.length > 0) {\n    s += '\\noptions:\\n'\n    let longestFlagName = 0\n    let flagNames :string[] = []\n\n    for (let f of opts) {\n      let flagName = \"  -\" + (\n        // -f=,-file=<file>\n        f.valueName ?\n          f.names.join(\"=,-\") + \"=\" + (\n            f.valueType == \"boolean\" ? 'on|off' :\n                                       '<' + f.valueName + '>'\n          ) :\n        // -f, -file\n        f.names.join(\", -\")\n      )\n      longestFlagName = Math.max(longestFlagName, flagName.length)\n      flagNames.push(flagName)\n    }\n\n    for (let i = 0; i < opts.length; i++) {\n      let f = opts[i]\n      let names = flagNames[i]\n      let descr = f.description\n      if (!f.description) {\n        // default to \"Set flagname\" (\"Enable flagname\" for bool flags)\n        descr = f.valueType ? \"Set \" : \"Enable \" + f.names.reduce(\n          (a,s) => (s.length > a.length ? s : a), // pick longest name\n          \"\"\n        )\n      }\n      s += `${names.padEnd(longestFlagName, \" \")}  ${descr}`\n      if (i + 1 < opts.length) {\n        s += \"\\n\"\n      }\n    }\n  }\n\n  // end with trailer\n  if (trailer) {\n    s += \"\\n\" + subvars(trailer.replace(/[\\n\\s]+$/, \"\"))\n  }\n\n  return s\n}\n\n", "import * as Path from \"path\"\n\nimport { runtimeRequire } from \"./util\"\nimport { log, LogLevel } from \"./log\"\nimport * as file from \"./file\"\nimport * as debugModule from \"./debug/debug\"\nimport * as watchModule from \"./watch/watch\"\n\nexport type DebugModule = typeof debugModule\nexport type WatchModule = typeof watchModule\n\ntype FileModule = typeof file\n\ninterface AuxModule {\n  initModule(logLevel :LogLevel, file :FileModule) :void\n}\n\n// used by tests\nlet estrellaDir = __dirname\nexport function setEstrellaDir(dir :string) {\n  estrellaDir = dir\n}\n\n\nfunction createLazyModuleAccessor<T extends AuxModule>(filename :string) :()=>T {\n  let m : T | null = null\n  return function getLazyModule() :T {\n    if (!m) {\n      log.debug(`loading ${filename} module`)\n      m = runtimeRequire(Path.join(estrellaDir, filename))\n      m!.initModule(log.level, file)\n    }\n    return m!\n  }\n}\n\nexport const debug = createLazyModuleAccessor<DebugModule>(DEBUG ? \"debug.g.js\" : \"debug.js\")\nexport const watch = createLazyModuleAccessor<WatchModule>(DEBUG ? \"watch.g.js\" : \"watch.js\")\n", "import * as fs from \"fs\"\nimport { PathLike } from \"fs\"\nimport * as Path from \"path\"\nimport * as crypto from \"crypto\"\nimport { chmodp, Modifier as ChModModifier, editFileMode } from \"./chmod\"\nimport { clock, tildePath } from \"./util\"\nimport { stdoutStyle } from \"./termstyle\"\nimport log from \"./log\"\nimport { UserError } from \"./error\"\n\nimport { WatchOptions, file as filedecl, FileWriteOptions } from \"../estrella.d\"\n\n\nconst fsp = fs.promises\n\n// fileModificationLog contains a list of [filename,Date.now()] of files that where\n// modified through the API. This data is used by watch.\nexport const fileModificationLog :{[filename:string]:number} = {}\n\nexport function fileModificationLogAppend(filename :PathLike) {\n  // TODO figure out a way to make it not grow unbounded with variable file names\n  fileModificationLog[Path.resolve(String(filename))] = clock()\n}\n\nexport function fileWasModifiedRecentlyByUser(filename :string) {\n  const ageThreshold = 30000\n  const time = fileModificationLog[Path.resolve(filename)]\n  return time !== undefined && clock() - time <= ageThreshold\n}\n\n// trick to make TypeScript type check our definitions here against those in estrella.d.ts\nexport const _ts_check_file :typeof filedecl = file\n\n\n// file() reads all contents of a file (same as file.read)\nexport function file(filename :PathLike, options :{encoding:string,flag?:string}|string) :Promise<string>\nexport function file(filename :PathLike, options :{encoding?:null,flag?:string}) :Promise<Buffer>\nexport function file(filename :PathLike) :Promise<Buffer>\nexport function file(\n  filename: PathLike,\n  options? :{encoding?:string|null,flag?:string}|string,\n) :Promise<string|Buffer> {\n  return fsp.readFile(filename, options as any)\n}\n\nfile.editMode = editFileMode\n\n\nfile.chmod = (filename :PathLike, modifier :ChModModifier) => {\n  fileModificationLogAppend(filename)\n  return chmodp(filename, modifier)\n}\n\n\ntype ReadOptions = fs.BaseEncodingOptions & { flag?: string | number; }\n                 | BufferEncoding\n                 | null\n\nfunction read(\n  filename :PathLike,\n  options :{encoding:BufferEncoding, flag?:fs.OpenMode} | BufferEncoding\n) :Promise<string>\nfunction read(filename :PathLike,\n  options :{encoding?:null, flag?:fs.OpenMode} | null\n) :Promise<Buffer>\nfunction read(filename :PathLike) :Promise<Buffer>\nfunction read(filename :PathLike, options? :ReadOptions) :Promise<string|Buffer> {\n  return fsp.readFile(filename, options)\n}\nfile.read = read\n\n\nfunction readSync(\n  filename :PathLike,\n  options :{encoding:BufferEncoding,flag?:fs.OpenMode} | BufferEncoding\n) :string\nfunction readSync(filename :PathLike, options :{encoding?:null,flag?:fs.OpenMode} | null) :Buffer\nfunction readSync(filename :PathLike) :Buffer\nfunction readSync(filename :PathLike, options? :ReadOptions) :string|Buffer {\n  // Note: typecast of options since fs type defs for node12 are incorrect: type of flags\n  // do not list number, even though the official nodejs documentation does.\n  // https://nodejs.org/docs/latest-v12.x/api/fs.html#fs_file_system_flags\n  return fs.readFileSync(filename, options as ReadOptions&{flag?: string})\n}\nfile.readSync = readSync\n\n\nfile.stat = fsp.stat\n\n\nfunction mtime(filename :PathLike) :Promise<number|null>\nfunction mtime(...filenames :PathLike[]) :Promise<(number|null)[]>\nfunction mtime(...filenames :PathLike[]) :Promise<number|null|(number|null)[]> {\n  return Promise.all(filenames.map(filename =>\n    fsp.stat(filename).then(st => st.mtimeMs).catch(_ => null)\n  )).then(r => r.length == 1 ? r[0] : r)\n}\nfile.mtime = mtime\n\nfile.readall = (...filenames :PathLike[]) =>\n  Promise.all(filenames.map(fn => fsp.readFile(fn)))\n\nfile.readallText = (encoding :string|null|undefined, ...filenames :PathLike[]) =>\n  Promise.all(filenames.map(fn => fsp.readFile(fn, {\n    encoding: (encoding||\"utf8\") as BufferEncoding\n  })))\n\nfile.write = async (filename :PathLike, data :string|Uint8Array, options? :FileWriteOptions) => {\n  fileModificationLogAppend(filename)\n  const opt = options && typeof options == \"object\" ? options : {}\n  try {\n    await fsp.writeFile(filename, data, options)\n  } catch (err) {\n    if (!opt.mkdirOff && err.code == \"ENOENT\") {\n      await file.mkdirs(Path.dirname(String(filename)), opt.mkdirMode)\n      await fsp.writeFile(filename, data, options)\n    } else {\n      throw err\n    }\n  }\n  if (opt.log) {\n    let relpath = Path.relative(process.cwd(), String(filename))\n    if (relpath.startsWith(\"..\" + Path.sep)) {\n      relpath = tildePath(filename)\n    }\n    log.info(stdoutStyle.green(`Wrote ${relpath}`))\n  }\n}\n\nfile.writeSync = (filename :PathLike, data :string|Uint8Array, options? :FileWriteOptions) => {\n  // See note in readSync regarding the typecast\n  fileModificationLogAppend(filename)\n  fs.writeFileSync(filename, data, options as fs.WriteFileOptions)\n}\n\nfunction sha1(filename :PathLike) :Promise<Buffer>\nfunction sha1(filename :PathLike, outputEncoding :crypto.BinaryToTextEncoding) :Promise<string>\n\nfunction sha1(\n  filename :PathLike,\n  outputEncoding? :crypto.BinaryToTextEncoding,\n) :Promise<Buffer|string> {\n  return new Promise<Buffer|string>((resolve, reject) => {\n    const reader = fs.createReadStream(filename)\n    const h = crypto.createHash('sha1')\n    reader.on('error', reject)\n    reader.on('end', () => {\n      h.end()\n      resolve(outputEncoding ? h.digest(outputEncoding) : h.digest())\n    })\n    reader.pipe(h)\n  })\n}\n\nfile.sha1 = sha1\n\nfile.copy = (srcfile :PathLike, dstfile :PathLike, failIfExist? :boolean) => {\n  let mode = fs.constants.COPYFILE_FICLONE  // copy-on-write (only used if OS supports it)\n  if (failIfExist) {\n    mode |= fs.constants.COPYFILE_EXCL\n  }\n  fileModificationLogAppend(dstfile)\n  return fsp.copyFile(srcfile, dstfile, mode)\n}\n\nfile.move = (oldfile :PathLike, newfile :PathLike) => {\n  fileModificationLogAppend(newfile)\n  return fsp.rename(oldfile, newfile)\n}\n\nfile.mkdirs = (dir :PathLike, mode? :fs.Mode) :Promise<boolean> => {\n  return fsp.mkdir(dir, {recursive:true, mode}).then(s => !!s && s.length > 0)\n}\n\n\ntype LegacyWatchOptions = {\n  recursive? :boolean\n}\n\n\nexport async function scandir(\n  dir      :string|string[],\n  filter?  :RegExp|null,\n  options? :(WatchOptions & LegacyWatchOptions)|null,\n) :Promise<string[]> {\n  if (!options) { options = {} }\n  if (!fs.promises || !fs.promises.opendir) {\n    // opendir was added in node 12.12.0\n    throw new Error(`scandir not implemented for nodejs <12.12.0`) // TODO\n  }\n  const files :string[] = []\n  const visited = new Set<String>()\n\n  const maxdepth = (\n    options.recursive !== undefined ? // legacy option from estrella <=1.1\n      options.recursive ? Infinity : 0 :\n    options.depth !== undefined ? options.depth :\n    Infinity\n  )\n\n  async function visit(dir :string, reldir :string, depth :number) {\n    if (visited.has(dir)) {\n      // cycle\n      return\n    }\n    visited.add(dir)\n    const d = await fs.promises.opendir(dir)\n    // Note: d.close() is called implicitly by the iterator/generator\n    for await (const ent of d) {\n      let name = ent.name\n      if (ent.isDirectory()) {\n        if (maxdepth < depth) {\n          await visit(Path.join(dir, name), Path.join(reldir, name), depth + 1)\n        }\n      } else if (ent.isFile() || ent.isSymbolicLink()) {\n        if (filter && filter.test(name)) {\n          files.push(Path.join(reldir, name))\n        }\n      }\n    }\n  }\n\n  const dirs = Array.isArray(dir) ? dir : [dir]\n\n  return Promise.all(dirs.map(dir =>\n    visit(Path.resolve(dir), \".\", 0)\n  )).then(() => files.sort())\n}\n", "import * as fs from \"fs\"\nimport { json } from \"./util\"\n\nconst chr = String.fromCharCode\nconst ord = (s :string, offs :number) => s.charCodeAt(offs || 0)\n\n\nexport type Modifier = number\n                     | string\n                     | string[]\n\n// chmod edits mode of a file (synchronous)\n// If m is a number, the mode is simply set to m.\n// If m is a string or list of strings, the mode is updated using editFileMode.\n// Returns the new mode set on file.\nexport function chmod(file :fs.PathLike, modifier :Modifier) :number {\n  if (typeof modifier == \"number\") {\n    fs.chmodSync(file, modifier)\n    return modifier\n  }\n  let mode = fs.statSync(file).mode\n  let newMode = editFileMode(mode, modifier)\n  if (mode != newMode) {\n    fs.chmodSync(file, newMode)\n  }\n  return newMode\n}\n\n// async version of chmod\nexport function chmodp(file :fs.PathLike, modifier :Modifier) :Promise<number> {\n  return new Promise<number>((resolve, reject) => {\n    if (typeof modifier == \"number\") {\n      return fs.chmod(file, modifier, err => {\n        err ? reject(err) : resolve(modifier)\n      })\n    }\n    fs.stat(file, (err, st) => {\n      if (err) return reject(err)\n      let newMode = editFileMode(st.mode, modifier)\n      if (st.mode == newMode) {\n        return resolve(newMode)\n      }\n      fs.chmod(file, newMode, err => {\n        err ? reject(err) : resolve(newMode)\n      })\n    })\n  })\n}\n\n\n// editFileMode takes a file mode (e.g. 0o764), applies modifiers and returns the resulting mode.\n// It accepts the same format as the Posix chmod program.\n// If multiple modifiers are provided, they are applied to mode in order.\n//\n// Grammar of modifier format:\n//\n//   mode   := clause [, clause ...]\n//   clause := [who ...] [action ...] action\n//   action := op [perm ...]\n//   who    := a | u | g | o\n//   op     := + | - | =\n//   perm   := r | w | x\n//\n// Examples:\n//\n//   // Set execute bit for user and group\n//   newMode = editFileMode(0o444, \"ug+x\") // => 0o554\n//\n//   // Set execute bit for user, write bit for group and remove all access for others\n//   newMode = editFileMode(0o444, \"+x,g+w,o-\") // => 0o560\n//\nexport function editFileMode(mode :number, modifier :string|string[]) :number {\n  const expectedFormat = `Expected format: [ugoa]*[+-=][rwx]+`\n\n  const err = (msg :string, m :any) =>\n    new Error(`${msg} in modifier ${json(m)}. ${expectedFormat}`)\n\n  let mods :string[] = []\n  for (let m of Array.isArray(modifier) ? modifier : [ modifier ]) {\n    mods = mods.concat(m.trim().split(/\\s*,+\\s*/))\n  }\n\n  for (let m of mods) {\n    let who :number[] = []\n    let all = false\n    let op = 0\n    let perm = 0\n\n    for (let i = 0; i < m.length; i++) {\n      let c = ord(m, i)\n      if (op == 0) {\n        switch (c) {\n          case 0x75: // u\n          case 0x67: // g\n          case 0x6F: // o\n            if (!all) {\n              who.push(c)\n            }\n            break\n          case 0x61: // a\n            who = [ 0x75, 0x67, 0x6F ]\n            all = true\n            break\n          case 0x2B: // +\n          case 0x2D: // -\n          case 0x3D: // =\n            op = c\n            break\n          default:\n            if (op == 0) {\n              throw err(`Invalid target or operation ${json(chr(c))}`, m)\n            }\n            break\n        }\n      } else {\n        switch (c) {\n          case 0x72: perm |= 0o4 ; break // r\n          case 0x77: perm |= 0o2 ; break // w\n          case 0x78: perm |= 0o1 ; break // x\n          default: throw err(`Invalid permission ${json(chr(c))}`, m)\n        }\n      }\n    }\n    if (op == 0) {\n      throw err(`Missing operation`, m)\n    }\n    if (who.length == 0) {\n      who = [ 0x75 ] // u\n    }\n    if (perm == 0) {\n      perm = 0o4 | 0o2 | 0o1\n    }\n\n    let mode2 = 0\n    for (let w of who) {\n      switch (w) {\n        case 0x75: mode2 |= (perm << 6) ; break  // u\n        case 0x67: mode2 |= (perm << 3) ; break  // g\n        case 0x6F: mode2 |= perm        ; break  // o\n      }\n    }\n    switch (op) {\n      case 0x2B: mode |= mode2 ; break  // +\n      case 0x2D: mode &= ~mode2 ; break // -\n      case 0x3D: mode = mode2 ; break   // =\n    }\n    // For debugging:\n    // console.log({\n    //   who: who.map(n => '0o' + n.toString(8)),\n    //   op: String.fromCharCode(op),\n    //   perm: '0o' + perm.toString(8),\n    // })\n  } // for each m in modifier\n  return mode\n}\n\n\ndeclare const DEBUG :boolean\n\n// lil' unit test for editFileMode\nif (DEBUG) {\n  const asserteq = require(\"assert\").strictEqual\n  const oct = (v :number) => \"0o\" + v.toString(8).padStart(3, '0')\n  //  input, modifiers, expected\n  const samples :\n    [ number, string[], number ][] = [\n    [ 0o444, [\"u+r\"],   0o444 ],\n    [ 0o444, [\"u+x\"],   0o544 ],\n    [ 0o444, [\"u+w\"],   0o644 ],\n    [ 0o444, [\"u+wx\"],  0o744 ],\n    [ 0o444, [\"u+rwx\"], 0o744 ],\n    [ 0o444, [\"u+r,u+w,u+x\"],    0o744 ],\n    [ 0o444, [\"u+r\", \"u+w,u+x\"], 0o744 ],\n    [ 0o444, [\"u+\"],    0o744 ], // no perm spec = all\n\n    [ 0o777, [\"u-r\"],   0o377 ],\n    [ 0o777, [\"u-wx\"],  0o477 ],\n    [ 0o777, [\"u-w\"],   0o577 ],\n    [ 0o777, [\"u-x\"],   0o677 ],\n    [ 0o777, [\"u-\"],    0o077 ],\n    [ 0o777, [\"u-rwx\"], 0o077 ],\n\n    [ 0o444, [\"g+r\"],   0o444 ],\n    [ 0o444, [\"g+x\"],   0o454 ],\n    [ 0o444, [\"g+w\"],   0o464 ],\n    [ 0o444, [\"g+wx\"],  0o474 ],\n    [ 0o444, [\"g+rwx\"], 0o474 ],\n    [ 0o444, [\"g+\"],    0o474 ],\n\n    [ 0o777, [\"g-r\"],   0o737 ],\n    [ 0o777, [\"g-wx\"],  0o747 ],\n    [ 0o777, [\"g-w\"],   0o757 ],\n    [ 0o777, [\"g-x\"],   0o767 ],\n    [ 0o777, [\"g-\"],    0o707 ],\n    [ 0o777, [\"g-rwx\"], 0o707 ],\n\n    [ 0o444, [\"o+r\"],   0o444 ],\n    [ 0o444, [\"o+x\"],   0o445 ],\n    [ 0o444, [\"o+w\"],   0o446 ],\n    [ 0o444, [\"o+wx\"],  0o447 ],\n    [ 0o444, [\"o+rwx\"], 0o447 ],\n    [ 0o444, [\"o+\"],    0o447 ],\n\n    [ 0o777, [\"o-r\"],   0o773 ],\n    [ 0o777, [\"o-wx\"],  0o774 ],\n    [ 0o777, [\"o-w\"],   0o775 ],\n    [ 0o777, [\"o-x\"],   0o776 ],\n    [ 0o777, [\"o-\"],    0o770 ],\n    [ 0o777, [\"o-rwx\"], 0o770 ],\n\n\n    [ 0o444, [\"ug+r\"],   0o444 ],\n    [ 0o444, [\"ug+x\"],   0o554 ],\n    [ 0o444, [\"ug+w\"],   0o664 ],\n    [ 0o444, [\"ug+wx\"],  0o774 ],\n    [ 0o444, [\"ug+rwx\"], 0o774 ],\n    [ 0o444, [\"ug+\"],    0o774 ],\n\n    [ 0o444, [\"ugo+r\"],   0o444 ],  [ 0o444, [\"a+r\"],   0o444 ],\n    [ 0o444, [\"ugo+x\"],   0o555 ],  [ 0o444, [\"a+x\"],   0o555 ],\n    [ 0o444, [\"ugo+w\"],   0o666 ],  [ 0o444, [\"a+w\"],   0o666 ],\n    [ 0o444, [\"ugo+wx\"],  0o777 ],  [ 0o444, [\"a+wx\"],  0o777 ],\n    [ 0o444, [\"ugo+rwx\"], 0o777 ],  [ 0o444, [\"a+rwx\"], 0o777 ],\n    [ 0o444, [\"ugo+\"],    0o777 ],  [ 0o444, [\"a+\"],    0o777 ],\n\n    [ 0o777, [\"ug-r\"],   0o337 ],\n    [ 0o777, [\"ug-wx\"],  0o447 ],\n    [ 0o777, [\"ug-w\"],   0o557 ],\n    [ 0o777, [\"ug-x\"],   0o667 ],\n    [ 0o777, [\"ug-\"],    0o007 ],\n    [ 0o777, [\"ug-rwx\"], 0o007 ],\n\n    [ 0o777, [\"ugo-r\"],   0o333 ],  [ 0o777, [\"a-r\"],   0o333 ],\n    [ 0o777, [\"ugo-wx\"],  0o444 ],  [ 0o777, [\"a-wx\"],  0o444 ],\n    [ 0o777, [\"ugo-w\"],   0o555 ],  [ 0o777, [\"a-w\"],   0o555 ],\n    [ 0o777, [\"ugo-x\"],   0o666 ],  [ 0o777, [\"a-x\"],   0o666 ],\n    [ 0o777, [\"ugo-\"],    0o000 ],  [ 0o777, [\"a-\"],    0o000 ],\n    [ 0o777, [\"ugo-rwx\"], 0o000 ],  [ 0o777, [\"a-rwx\"], 0o000 ],\n  ] // samples\n\n  samples.map(([input, mods, expect]) => {\n    let actual = editFileMode(input, mods)\n    asserteq(actual, expect,\n      `editFileMode(${oct(input)}, ${json(mods)}) => ` +\n      `${oct(actual)} != expected ${oct(expect)}`\n    )\n  })\n} // end of editFileMode tests\n", "import * as extra from \"./extra\"\nimport { stderrStyle } from \"./termstyle\"\nimport { getModulePackageJSON } from \"./util\"\nimport * as typeinfo from \"./typeinfo\"\n\n\nexport class UserError extends Error {\n  constructor(msg :string) {\n    super(msg)\n    this.name = \"UserError\"\n  }\n}\n\n\n// captureStackTrace captures a stack trace, returning the formatted stack.\n// If sourcemap is true, then translate locations via source map (loads debug module.)\nexport function captureStackTrace(cons? :Function, sourcemap? :boolean) :string {\n  const Error_prepareStackTrace = Error.prepareStackTrace\n  if (!sourcemap) {\n    Error.prepareStackTrace = undefined\n  }\n  let stack = \"\"\n  try {\n    const e :any = {}\n    Error.captureStackTrace(e, cons)\n    // note: accessing e.stack invokes Error.prepareStackTrace so this must be done\n    // before restoring Error.prepareStackTrace\n    stack = e.stack as string\n  } finally {\n    Error.prepareStackTrace = Error_prepareStackTrace\n  }\n  return stack\n}\n\n\nexport function bugReportMessage(mode :\"confident\"|\"guess\", reportContextField? :string) {\n  return extra.debug().bugReportMessage(mode, reportContextField)\n}\n\n\nexport function printErrorAndExit(err :any, origin? :string) {\n  return extra.debug().printErrorAndExit(err, origin)\n}\n\n\n// attempt to install source-map-support just-in-time when an error occurs to avoid\n// taking the startup cost of 10-20ms for loading the source-map-support module.\nfunction Error_prepareStackTrace(error: Error, stack: NodeJS.CallSite[]) {\n  Error.prepareStackTrace = undefined\n  try {\n    extra.debug().installSourceMapSupport()\n    if (Error.prepareStackTrace !== Error_prepareStackTrace) {\n      return Error.prepareStackTrace!(error, stack)\n    }\n  } catch(_) {}\n  return error.stack || String(error)\n}\n\n\n// install process-level exception and rejection handlers\nError.prepareStackTrace = Error_prepareStackTrace\nprocess.on(\"uncaughtException\", printErrorAndExit)\nprocess.on(\"unhandledRejection\", (reason :{} | null | undefined, _promise :Promise<any>) => {\n  printErrorAndExit(reason||\"PromiseRejection\", \"unhandledRejection\")\n})\n", "import * as Path from \"path\"\nimport * as chokidar from \"chokidar\"\n\nimport { WatchOptions, WatchCallback, FileEvent, FileEvent1, FileEvent2 } from \"../../estrella.d\"\n\nimport { repr, clock, fmtDuration } from \"../util\"\nimport log from \"../log\"\n\ntype ChangeEvent = 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir'\ntype CancellablePromise<T> = Promise<T>&{ cancel(reason?:any):void }\n\nexport interface FSWatcherOptions extends WatchOptions {\n  isChangeSelfOriginating(filename :string) :boolean\n}\n\n\nexport class FSWatcher {\n  options :FSWatcherOptions\n  promise :CancellablePromise<void>\n  basedir :string = \"\"\n\n  onStart? :()=>{}\n  onChange? :WatchCallback\n\n  _resolve = (_?:void|PromiseLike<void>|undefined, _rejectReason?:any)=>{}\n  _cancelled :boolean = false\n  _watcher :chokidar.FSWatcher | null = null\n  _fileset = new Set<string>()   // observed files\n\n\n  constructor(options :FSWatcherOptions) {\n    this.options = options\n    this.promise = new Promise<void>(r => {\n      this._resolve = r\n    }) as CancellablePromise<void>\n    this.promise.cancel = () => {\n      this._cancelled = true\n    }\n  }\n\n\n  setFiles(files :Iterable<string>) {\n    const newfileset = new Set(files)\n\n    if (!this._watcher) {\n      this._fileset = newfileset\n      this._start()\n      return\n    }\n\n    // find files being added and removed\n    let gonefiles :string[] = []\n    for (let f of this._fileset) {\n      if (!newfileset.has(f)) {\n        gonefiles.push(f)\n      }\n    }\n    let addfiles :string[] = []\n    for (let f of newfileset) {\n      if (!this._fileset.has(f)) {\n        addfiles.push(f)\n      }\n    }\n\n    this._fileset = newfileset\n\n    if (gonefiles.length > 0) {\n      log.debug(()=> `fswatch stop watching files ${this._relnames(gonefiles)}`)\n      this._watcher.unwatch(gonefiles)\n    }\n\n    if (addfiles.length > 0) {\n      log.debug(()=> `fswatch start watching files ${this._relnames(addfiles)}`)\n      this._watcher.add(addfiles)\n    }\n  }\n\n\n  close() :Promise<void> {\n    if (!this._watcher) {\n      return Promise.resolve()\n    }\n    log.debug(()=> `fswatch closing`)\n    this._watcher.close()\n      .then(() => this._resolve())\n      .catch(err => this._resolve(undefined, err))\n    this._watcher = null\n    return this.promise\n  }\n\n\n  _relnames(filenames :string[]) :string {\n    if (filenames.length == 1) {\n      return this._relname(filenames[0])\n    }\n    return filenames.map(fn => \"\\n  \" + this._relname(fn)).join(\"\")\n  }\n\n\n  _relname(fn :string) :string {\n    if (this.basedir && fn.startsWith(this.basedir)) {\n      return Path.relative(this.basedir, fn)\n    }\n    return Path.relative(process.cwd(), fn)\n  }\n\n\n  _start() {\n    if (this._cancelled) {\n      return\n    }\n\n    const initialFiles = Array.from(this._fileset)\n    if (initialFiles.length == 0) {\n      // chokidar has some odd behavior (bug?) where starting a watcher in \"persistent\" mode\n      // without initial files to watch causes it to not prevent the program runloop from ending.\n      return\n    }\n\n    if (this.basedir) {\n      this.basedir = Path.resolve(this.basedir)\n    }\n\n    let flushLatency = 50\n    let filter :RegExp|null = null\n\n    // copy user options and extract non-chokidar options\n    const options :WatchOptions = {...this.options}\n    if (typeof options.latency == \"number\") {\n      flushLatency = options.latency\n      delete options.latency\n    }\n    if (options.filter) {\n      filter = options.filter\n      delete options.filter\n    }\n\n    // build chokidar options from default options + user options + required options\n    const chokidarOptions :chokidar.WatchOptions = {\n      disableGlobbing: true,\n      followSymlinks: false,\n\n      // ups the reliability of change events\n      awaitWriteFinish: {\n        stabilityThreshold: 20,\n        pollInterval: 100,\n      },\n\n      // user options may override any options listed above\n      ...options,\n\n      // required options; for guaranteeing the promised semantics of FSWatcher\n      persistent: true,\n      ignoreInitial: true,\n    }\n\n    let changedFiles = new Map<string,FileEvent>() // changed files (to be flushed to callback)\n    let timer :any = null\n\n    const flush = () => {\n      timer = null\n      const p = this.onChange ? this.onChange(Array.from(changedFiles.values())) : null\n      changedFiles.clear()\n      if (p instanceof Promise) {\n        // pause dispatch (just enqueue) until resolved\n        p.then(() => {\n          timer = null\n          if (changedFiles.size > 0) {\n            // changes recorded while waiting for promise; flush again\n            flush()\n          }\n        }).catch(err => {\n          this.promise.cancel(err)\n        })\n        timer = 1 // this prevents flushing\n      }\n    }\n\n    const scheduleFlush = () => {\n      if (timer === null) {\n        timer = setTimeout(flush, flushLatency)\n      }\n    }\n\n    const maybeFilter = (file :string) => {\n      if (filter && !filter.test(file)) {\n        log.debug(()=>`fswatch ignoring ${file} (filter)`)\n        return true\n      }\n      return false\n    }\n\n    // macOS issues two consecutive \"move\" events when a file is renamed\n    // This contains state of a previous move event\n    const renameState = {\n      time: 0 as number, // clock() when oldname event was recorded\n      oldname: \"\",\n      newname: \"INIT\",\n    }\n\n    const onchange = (ev :ChangeEvent, file :string) => {\n      if (this.options.isChangeSelfOriginating(file)) {\n        log.debug(()=> `fswatch ignoring self-originating event ${ev} ${file}`)\n        return\n      }\n      if (maybeFilter(file)) {\n        return\n      }\n      log.debug(()=> `fsevent ${repr(ev)} ${repr(file)}`)\n      const evmap :{[k:string]:FileEvent[\"type\"]} = { // map chokidar event name to our event names\n        'addDir':\"add\",\n        'unlink':\"delete\",\n        'unlinkDir':\"delete\",\n      }\n      if (ev != \"unlink\" || !changedFiles.has(file) || changedFiles.get(file)!.type != \"move\") {\n        changedFiles.set(file, {\n          type: evmap[ev] || ev,\n          name: file,\n        } as FileEvent1)\n      }\n      scheduleFlush()\n    }\n\n    const onRawEvent = (ev: string, file: string, details: any) => {\n      if (ev != \"moved\") {\n        // note: we only care about \"moved\" here; other events are handled by onchange\n        return\n      }\n      file = this._relname(file)\n      log.debug(()=> `fsevent (raw) ${repr(ev)} ${repr(file)} ${repr(details)}`)\n      if (maybeFilter(file)) {\n        return\n      }\n      const time = clock()\n      const timeWindow = 100 // ms\n      if (renameState.newname != \"\") {\n        // start of a new pair of \"moved\" events\n        renameState.oldname = file\n        renameState.newname = \"\"\n        renameState.time = time\n      } else {\n        // end of a pair of \"moved\" events\n        renameState.newname = file\n        renameState.time = time\n        if (time - renameState.time <= timeWindow) {\n          // this is the second of two move events\n          log.debug(`fsevent (derived) move ${renameState.oldname} -> ${file}`)\n          if (this._watcher) {\n            this._watcher.add(file)\n            this._fileset.add(file)\n            this._watcher.unwatch(renameState.oldname)\n            this._fileset.delete(renameState.oldname)\n          }\n          changedFiles.delete(renameState.oldname)\n          changedFiles.set(renameState.oldname, {\n            type: \"move\",\n            name: renameState.oldname,\n            newname: file,\n          } as FileEvent2)\n          scheduleFlush()\n        }\n      }\n    }\n\n    this.promise.cancel = (reason? :any) => {\n      log.debug(`fswatcher is being cancelled`)\n      clearTimeout(timer)\n      if (!this._cancelled) {\n        this._cancelled = true\n        this.close()\n      }\n      if (reason) {\n        this._resolve(undefined, reason)\n      }\n    }\n\n    const time = clock()\n\n    this._watcher = chokidar.watch(initialFiles, chokidarOptions)\n      .on('all', onchange)\n      .on('raw', onRawEvent)\n      .on('error', error => log.warn(`fswatch ${error}`))\n      .on('ready', () => {\n        log.debug(()=>`fswatch initial scan complete (${fmtDuration(clock() - time)})`)\n        this.onStart && this.onStart()\n      })\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
